"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+web3.js@1.98.0_bufferutil@4.0.9_encoding@0.1.13_utf-8-validate@5.0.10";
exports.ids = ["vendor-chunks/@solana+web3.js@1.98.0_bufferutil@4.0.9_encoding@0.1.13_utf-8-validate@5.0.10"];
exports.modules = {

/***/ "../node_modules/.pnpm/@solana+web3.js@1.98.0_bufferutil@4.0.9_encoding@0.1.13_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.cjs.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@solana+web3.js@1.98.0_bufferutil@4.0.9_encoding@0.1.13_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.cjs.js ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar _Object$getOwnPropertySymbols = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols */ \"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\");\nvar _Object$getOwnPropertyDescriptors = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors */ \"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\");\nvar _Object$defineProperties = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/define-properties */ \"@babel/runtime-corejs3/core-js-stable/object/define-properties\");\nvar _objectWithoutProperties = __webpack_require__(/*! @babel/runtime-corejs3/helpers/objectWithoutProperties */ \"@babel/runtime-corejs3/helpers/objectWithoutProperties\");\nvar _defineProperty = __webpack_require__(/*! @babel/runtime-corejs3/helpers/defineProperty */ \"@babel/runtime-corejs3/helpers/defineProperty\");\nvar _Object$create = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/create */ \"@babel/runtime-corejs3/core-js-stable/object/create\");\nvar _forEachInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/for-each */ \"@babel/runtime-corejs3/core-js-stable/instance/for-each\");\nvar _Object$keys = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/keys */ \"@babel/runtime-corejs3/core-js-stable/object/keys\");\nvar _Object$getOwnPropertyDescriptor = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor */ \"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _Object$defineProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/define-property */ \"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _Object$freeze = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/freeze */ \"@babel/runtime-corejs3/core-js-stable/object/freeze\");\nvar _sliceInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/slice */ \"@babel/runtime-corejs3/core-js-stable/instance/slice\");\nvar _Object$assign = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/assign */ \"@babel/runtime-corejs3/core-js-stable/object/assign\");\nvar _mapInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/map */ \"@babel/runtime-corejs3/core-js-stable/instance/map\");\nvar _Map = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/map */ \"@babel/runtime-corejs3/core-js-stable/map\");\nvar _Symbol$toStringTag = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/symbol/to-string-tag */ \"@babel/runtime-corejs3/core-js-stable/symbol/to-string-tag\");\nvar _concatInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/concat */ \"@babel/runtime-corejs3/core-js-stable/instance/concat\");\nvar _flatInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/flat */ \"@babel/runtime-corejs3/core-js-stable/instance/flat\");\nvar _keysInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/keys */ \"@babel/runtime-corejs3/core-js-stable/instance/keys\");\nvar _bindInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/bind */ \"@babel/runtime-corejs3/core-js-stable/instance/bind\");\nvar _Array$isArray = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/array/is-array */ \"@babel/runtime-corejs3/core-js-stable/array/is-array\");\nvar _entriesInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/entries */ \"@babel/runtime-corejs3/core-js-stable/instance/entries\");\nvar _filterInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/filter */ \"@babel/runtime-corejs3/core-js-stable/instance/filter\");\nvar _findIndexInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/find-index */ \"@babel/runtime-corejs3/core-js-stable/instance/find-index\");\nvar _spliceInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/splice */ \"@babel/runtime-corejs3/core-js-stable/instance/splice\");\nvar _valuesInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/values */ \"@babel/runtime-corejs3/core-js-stable/instance/values\");\nvar _Array$from = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/array/from */ \"@babel/runtime-corejs3/core-js-stable/array/from\");\nvar _reduceInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/reduce */ \"@babel/runtime-corejs3/core-js-stable/instance/reduce\");\nvar _findInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/find */ \"@babel/runtime-corejs3/core-js-stable/instance/find\");\nvar _fillInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/fill */ \"@babel/runtime-corejs3/core-js-stable/instance/fill\");\nvar _JSON$stringify = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/json/stringify */ \"@babel/runtime-corejs3/core-js-stable/json/stringify\");\nvar _includesInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/includes */ \"@babel/runtime-corejs3/core-js-stable/instance/includes\");\nvar _sortInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/sort */ \"@babel/runtime-corejs3/core-js-stable/instance/sort\");\nvar _indexOfInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/index-of */ \"@babel/runtime-corejs3/core-js-stable/instance/index-of\");\nvar _everyInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/every */ \"@babel/runtime-corejs3/core-js-stable/instance/every\");\nvar _Set = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/set */ \"@babel/runtime-corejs3/core-js-stable/set\");\nvar _someInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/some */ \"@babel/runtime-corejs3/core-js-stable/instance/some\");\nvar _Promise = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/promise */ \"@babel/runtime-corejs3/core-js-stable/promise\");\nvar _setTimeout = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/set-timeout */ \"@babel/runtime-corejs3/core-js-stable/set-timeout\");\nvar _Object$entries = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/entries */ \"@babel/runtime-corejs3/core-js-stable/object/entries\");\nvar _parseFloat = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/parse-float */ \"@babel/runtime-corejs3/core-js-stable/parse-float\");\nvar _Symbol = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/symbol */ \"@babel/runtime-corejs3/core-js-stable/symbol\");\nvar _parseInt = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/parse-int */ \"@babel/runtime-corejs3/core-js-stable/parse-int\");\nvar _Date$now = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/date/now */ \"@babel/runtime-corejs3/core-js-stable/date/now\");\nvar _Number$MAX_SAFE_INTEGER = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/number/max-safe-integer */ \"@babel/runtime-corejs3/core-js-stable/number/max-safe-integer\");\nvar _globalThis = __webpack_require__(/*! @babel/runtime-corejs3/core-js/global-this */ \"@babel/runtime-corejs3/core-js/global-this\");\nvar _startsWithInstanceProperty = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/starts-with */ \"@babel/runtime-corejs3/core-js-stable/instance/starts-with\");\nvar _setInterval = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/set-interval */ \"@babel/runtime-corejs3/core-js-stable/set-interval\");\nconst _excluded = [\"commitment\"],\n  _excluded2 = [\"encoding\"],\n  _excluded3 = [\"commitment\"],\n  _excluded4 = [\"commitment\"];\nvar _context26;\nfunction ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context83, _context84; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context83 = ownKeys(Object(t), !0)).call(_context83, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context84 = ownKeys(Object(t))).call(_context84, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\");\nvar ed25519 = __webpack_require__(/*! @noble/curves/ed25519 */ \"../node_modules/.pnpm/@noble+curves@1.8.0/node_modules/@noble/curves/ed25519.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\");\nvar bs58 = __webpack_require__(/*! bs58 */ \"../node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js\");\nvar sha256 = __webpack_require__(/*! @noble/hashes/sha256 */ \"../node_modules/.pnpm/@noble+hashes@1.7.0/node_modules/@noble/hashes/sha256.js\");\nvar borsh = __webpack_require__(/*! borsh */ \"../node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js\");\nvar BufferLayout = __webpack_require__(/*! @solana/buffer-layout */ \"../node_modules/.pnpm/@solana+buffer-layout@4.0.1/node_modules/@solana/buffer-layout/lib/Layout.js\");\nvar bigintBuffer = __webpack_require__(/*! bigint-buffer */ \"../node_modules/.pnpm/bigint-buffer@1.1.5/node_modules/bigint-buffer/dist/node.js\");\nvar require$$0 = __webpack_require__(/*! util */ \"util\");\nvar require$$0$1 = __webpack_require__(/*! http */ \"http\");\nvar require$$0$2 = __webpack_require__(/*! https */ \"https\");\nvar superstruct = __webpack_require__(/*! superstruct */ \"../node_modules/.pnpm/superstruct@2.0.2/node_modules/superstruct/dist/index.cjs\");\nvar RpcClient = __webpack_require__(/*! jayson/lib/client/browser */ \"../node_modules/.pnpm/jayson@4.1.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/jayson/lib/client/browser/index.js\");\nvar nodeFetch = __webpack_require__(/*! node-fetch */ \"../node_modules/.pnpm/node-fetch@2.7.0_encoding@0.1.13/node_modules/node-fetch/lib/index.js\");\nvar rpcWebsockets = __webpack_require__(/*! rpc-websockets */ \"../node_modules/.pnpm/rpc-websockets@9.0.4/node_modules/rpc-websockets/dist/index.cjs\");\nvar sha3 = __webpack_require__(/*! @noble/hashes/sha3 */ \"../node_modules/.pnpm/@noble+hashes@1.7.0/node_modules/@noble/hashes/sha3.js\");\nvar secp256k1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"../node_modules/.pnpm/@noble+curves@1.8.0/node_modules/@noble/curves/secp256k1.js\");\nfunction _interopDefaultCompat(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    default: e\n  };\n}\nfunction _interopNamespaceCompat(e) {\n  if (e && typeof e === 'object' && 'default' in e) return e;\n  var n = _Object$create(null);\n  if (e) {\n    var _context;\n    _forEachInstanceProperty(_context = _Object$keys(e)).call(_context, function (k) {\n      if (k !== 'default') {\n        var d = _Object$getOwnPropertyDescriptor(e, k);\n        _Object$defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return _Object$freeze(n);\n}\nvar BN__default = /*#__PURE__*/_interopDefaultCompat(BN);\nvar bs58__default = /*#__PURE__*/_interopDefaultCompat(bs58);\nvar BufferLayout__namespace = /*#__PURE__*/_interopNamespaceCompat(BufferLayout);\nvar require$$0__default = /*#__PURE__*/_interopDefaultCompat(require$$0);\nvar require$$0__default$1 = /*#__PURE__*/_interopDefaultCompat(require$$0$1);\nvar require$$0__default$2 = /*#__PURE__*/_interopDefaultCompat(require$$0$2);\nvar RpcClient__default = /*#__PURE__*/_interopDefaultCompat(RpcClient);\nvar nodeFetch__namespace = /*#__PURE__*/_interopNamespaceCompat(nodeFetch);\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */\n\n/**\n * Ed25519 Keypair\n */\n\nconst generatePrivateKey = ed25519.ed25519.utils.randomPrivateKey;\nconst generateKeypair = () => {\n  const privateScalar = ed25519.ed25519.utils.randomPrivateKey();\n  const publicKey = getPublicKey(privateScalar);\n  const secretKey = new Uint8Array(64);\n  secretKey.set(privateScalar);\n  secretKey.set(publicKey, 32);\n  return {\n    publicKey,\n    secretKey\n  };\n};\nconst getPublicKey = ed25519.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n  try {\n    ed25519.ed25519.ExtendedPoint.fromHex(publicKey);\n    return true;\n  } catch {\n    return false;\n  }\n}\nconst sign = (message, secretKey) => ed25519.ed25519.sign(message, _sliceInstanceProperty(secretKey).call(secretKey, 0, 32));\nconst verify = ed25519.ed25519.verify;\nconst toBuffer = arr => {\n  if (buffer.Buffer.isBuffer(arr)) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return buffer.Buffer.from(arr);\n  }\n};\n\n// Class wrapping a plain object\nclass Struct {\n  constructor(properties) {\n    _Object$assign(this, properties);\n  }\n  encode() {\n    return buffer.Buffer.from(borsh.serialize(SOLANA_SCHEMA, this));\n  }\n  static decode(data) {\n    return borsh.deserialize(SOLANA_SCHEMA, this, data);\n  }\n  static decodeUnchecked(data) {\n    return borsh.deserializeUnchecked(SOLANA_SCHEMA, this, data);\n  }\n}\n\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n  constructor(properties) {\n    var _context2;\n    super(properties);\n    this.enum = '';\n    if (_Object$keys(properties).length !== 1) {\n      throw new Error('Enum can only take single value');\n    }\n    _mapInstanceProperty(_context2 = _Object$keys(properties)).call(_context2, key => {\n      this.enum = key;\n    });\n  }\n}\nconst SOLANA_SCHEMA = new _Map();\nvar _PublicKey;\n\n/**\n * Maximum length of derived pubkey seed\n */\nconst MAX_SEED_LENGTH = 32;\n\n/**\n * Size of public key in bytes\n */\nconst PUBLIC_KEY_LENGTH = 32;\n\n/**\n * Value to be converted into public key\n */\n\n/**\n * JSON object representation of PublicKey class\n */\n\nfunction isPublicKeyData(value) {\n  return value._bn !== undefined;\n}\n\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n\n/**\n * A public key\n */\nclass PublicKey extends Struct {\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  constructor(value) {\n    super({});\n    /** @internal */\n    this._bn = void 0;\n    if (isPublicKeyData(value)) {\n      this._bn = value._bn;\n    } else {\n      if (typeof value === 'string') {\n        // assume base 58 encoding by default\n        const decoded = bs58__default.default.decode(value);\n        if (decoded.length != PUBLIC_KEY_LENGTH) {\n          throw new Error(`Invalid public key input`);\n        }\n        this._bn = new BN__default.default(decoded);\n      } else {\n        this._bn = new BN__default.default(value);\n      }\n      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n        throw new Error(`Invalid public key input`);\n      }\n    }\n  }\n\n  /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */\n  static unique() {\n    const key = new PublicKey(uniquePublicKeyCounter);\n    uniquePublicKeyCounter += 1;\n    return new PublicKey(key.toBuffer());\n  }\n\n  /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */\n\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(publicKey) {\n    return this._bn.eq(publicKey._bn);\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58() {\n    return bs58__default.default.encode(this.toBytes());\n  }\n  toJSON() {\n    return this.toBase58();\n  }\n\n  /**\n   * Return the byte array representation of the public key in big endian\n   */\n  toBytes() {\n    const buf = this.toBuffer();\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  /**\n   * Return the Buffer representation of the public key in big endian\n   */\n  toBuffer() {\n    const b = this._bn.toArrayLike(buffer.Buffer);\n    if (b.length === PUBLIC_KEY_LENGTH) {\n      return b;\n    }\n    const zeroPad = buffer.Buffer.alloc(32);\n    b.copy(zeroPad, 32 - b.length);\n    return zeroPad;\n  }\n  get [_Symbol$toStringTag]() {\n    return `PublicKey(${this.toString()})`;\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toString() {\n    return this.toBase58();\n  }\n\n  /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */\n  /* eslint-disable require-await */\n  static async createWithSeed(fromPublicKey, seed, programId) {\n    var _context3;\n    const buffer$1 = _concatInstanceProperty(_context3 = buffer.Buffer).call(_context3, [fromPublicKey.toBuffer(), buffer.Buffer.from(seed), programId.toBuffer()]);\n    const publicKeyBytes = sha256.sha256(buffer$1);\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Derive a program address from seeds and a program ID.\n   */\n  /* eslint-disable require-await */\n  static createProgramAddressSync(seeds, programId) {\n    var _context5;\n    let buffer$1 = buffer.Buffer.alloc(0);\n    _forEachInstanceProperty(seeds).call(seeds, function (seed) {\n      var _context4;\n      if (seed.length > MAX_SEED_LENGTH) {\n        throw new TypeError(`Max seed length exceeded`);\n      }\n      buffer$1 = _concatInstanceProperty(_context4 = buffer.Buffer).call(_context4, [buffer$1, toBuffer(seed)]);\n    });\n    buffer$1 = _concatInstanceProperty(_context5 = buffer.Buffer).call(_context5, [buffer$1, programId.toBuffer(), buffer.Buffer.from('ProgramDerivedAddress')]);\n    const publicKeyBytes = sha256.sha256(buffer$1);\n    if (isOnCurve(publicKeyBytes)) {\n      throw new Error(`Invalid seeds, address must fall off the curve`);\n    }\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */\n  /* eslint-disable require-await */\n  static async createProgramAddress(seeds, programId) {\n    return this.createProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */\n  static findProgramAddressSync(seeds, programId) {\n    let nonce = 255;\n    let address;\n    while (nonce != 0) {\n      try {\n        const seedsWithNonce = _concatInstanceProperty(seeds).call(seeds, buffer.Buffer.from([nonce]));\n        address = this.createProgramAddressSync(seedsWithNonce, programId);\n      } catch (err) {\n        if (err instanceof TypeError) {\n          throw err;\n        }\n        nonce--;\n        continue;\n      }\n      return [address, nonce];\n    }\n    throw new Error(`Unable to find a viable program address nonce`);\n  }\n\n  /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */\n  static async findProgramAddress(seeds, programId) {\n    return this.findProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Check that a pubkey is on the ed25519 curve.\n   */\n  static isOnCurve(pubkeyData) {\n    const pubkey = new PublicKey(pubkeyData);\n    return isOnCurve(pubkey.toBytes());\n  }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey('11111111111111111111111111111111');\nSOLANA_SCHEMA.set(PublicKey, {\n  kind: 'struct',\n  fields: [['_bn', 'u256']]\n});\n\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */\nclass Account {\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  constructor(secretKey) {\n    /** @internal */\n    this._publicKey = void 0;\n    /** @internal */\n    this._secretKey = void 0;\n    if (secretKey) {\n      const secretKeyBuffer = toBuffer(secretKey);\n      if (secretKey.length !== 64) {\n        throw new Error('bad secret key size');\n      }\n      this._publicKey = _sliceInstanceProperty(secretKeyBuffer).call(secretKeyBuffer, 32, 64);\n      this._secretKey = _sliceInstanceProperty(secretKeyBuffer).call(secretKeyBuffer, 0, 32);\n    } else {\n      this._secretKey = toBuffer(generatePrivateKey());\n      this._publicKey = toBuffer(getPublicKey(this._secretKey));\n    }\n  }\n\n  /**\n   * The public key for this account\n   */\n  get publicKey() {\n    return new PublicKey(this._publicKey);\n  }\n\n  /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */\n  get secretKey() {\n    var _context6;\n    return _concatInstanceProperty(_context6 = buffer.Buffer).call(_context6, [this._secretKey, this._publicKey], 64);\n  }\n}\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');\n\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nconst PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nclass TransactionExpiredBlockheightExceededError extends Error {\n  constructor(signature) {\n    super(`Signature ${signature} has expired: block height exceeded.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\n_Object$defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {\n  value: 'TransactionExpiredBlockheightExceededError'\n});\nclass TransactionExpiredTimeoutError extends Error {\n  constructor(signature, timeoutSeconds) {\n    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + 'unknown if it succeeded or failed. Check signature ' + `${signature} using the Solana Explorer or CLI tools.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\n_Object$defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {\n  value: 'TransactionExpiredTimeoutError'\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n  constructor(signature) {\n    super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\n_Object$defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {\n  value: 'TransactionExpiredNonceInvalidError'\n});\nclass MessageAccountKeys {\n  constructor(staticAccountKeys, accountKeysFromLookups) {\n    this.staticAccountKeys = void 0;\n    this.accountKeysFromLookups = void 0;\n    this.staticAccountKeys = staticAccountKeys;\n    this.accountKeysFromLookups = accountKeysFromLookups;\n  }\n  keySegments() {\n    const keySegments = [this.staticAccountKeys];\n    if (this.accountKeysFromLookups) {\n      keySegments.push(this.accountKeysFromLookups.writable);\n      keySegments.push(this.accountKeysFromLookups.readonly);\n    }\n    return keySegments;\n  }\n  get(index) {\n    for (const keySegment of this.keySegments()) {\n      if (index < keySegment.length) {\n        return keySegment[index];\n      } else {\n        index -= keySegment.length;\n      }\n    }\n    return;\n  }\n  get length() {\n    var _context7;\n    return _flatInstanceProperty(_context7 = this.keySegments()).call(_context7).length;\n  }\n  compileInstructions(instructions) {\n    var _context8, _context9;\n    // Bail early if any account indexes would overflow a u8\n    const U8_MAX = 255;\n    if (this.length > U8_MAX + 1) {\n      throw new Error('Account index overflow encountered during compilation');\n    }\n    const keyIndexMap = new _Map();\n    _forEachInstanceProperty(_context8 = _flatInstanceProperty(_context9 = this.keySegments()).call(_context9)).call(_context8, (key, index) => {\n      keyIndexMap.set(key.toBase58(), index);\n    });\n    const findKeyIndex = key => {\n      const keyIndex = keyIndexMap.get(key.toBase58());\n      if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');\n      return keyIndex;\n    };\n    return _mapInstanceProperty(instructions).call(instructions, instruction => {\n      var _context10;\n      return {\n        programIdIndex: findKeyIndex(instruction.programId),\n        accountKeyIndexes: _mapInstanceProperty(_context10 = _keysInstanceProperty(instruction)).call(_context10, meta => findKeyIndex(meta.pubkey)),\n        data: instruction.data\n      };\n    });\n  }\n}\n\n/**\n * Layout for a public key\n */\nconst publicKey = (property = 'publicKey') => {\n  return BufferLayout__namespace.blob(32, property);\n};\n\n/**\n * Layout for a signature\n */\nconst signature = (property = 'signature') => {\n  return BufferLayout__namespace.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */\nconst rustString = (property = 'string') => {\n  var _context11, _context12;\n  const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32('length'), BufferLayout__namespace.u32('lengthPadding'), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'chars')], property);\n  const _decode = _bindInstanceProperty(_context11 = rsl.decode).call(_context11, rsl);\n  const _encode = _bindInstanceProperty(_context12 = rsl.encode).call(_context12, rsl);\n  const rslShim = rsl;\n  rslShim.decode = (b, offset) => {\n    const data = _decode(b, offset);\n    return data['chars'].toString();\n  };\n  rslShim.encode = (str, b, offset) => {\n    const data = {\n      chars: buffer.Buffer.from(str, 'utf8')\n    };\n    return _encode(data, b, offset);\n  };\n  rslShim.alloc = str => {\n    return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str, 'utf8').length;\n  };\n  return rslShim;\n};\n\n/**\n * Layout for an Authorized object\n */\nconst authorized = (property = 'authorized') => {\n  return BufferLayout__namespace.struct([publicKey('staker'), publicKey('withdrawer')], property);\n};\n\n/**\n * Layout for a Lockup object\n */\nconst lockup = (property = 'lockup') => {\n  return BufferLayout__namespace.struct([BufferLayout__namespace.ns64('unixTimestamp'), BufferLayout__namespace.ns64('epoch'), publicKey('custodian')], property);\n};\n\n/**\n *  Layout for a VoteInit object\n */\nconst voteInit = (property = 'voteInit') => {\n  return BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission')], property);\n};\n\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */\nconst voteAuthorizeWithSeedArgs = (property = 'voteAuthorizeWithSeedArgs') => {\n  return BufferLayout__namespace.struct([BufferLayout__namespace.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);\n};\nfunction getAlloc(type, fields) {\n  var _context13;\n  const getItemAlloc = item => {\n    if (item.span >= 0) {\n      return item.span;\n    } else if (typeof item.alloc === 'function') {\n      return item.alloc(fields[item.property]);\n    } else if ('count' in item && 'elementLayout' in item) {\n      const field = fields[item.property];\n      if (_Array$isArray(field)) {\n        return field.length * getItemAlloc(item.elementLayout);\n      }\n    } else if ('fields' in item) {\n      // This is a `Structure` whose size needs to be recursively measured.\n      return getAlloc({\n        layout: item\n      }, fields[item.property]);\n    }\n    // Couldn't determine allocated size of layout\n    return 0;\n  };\n  let alloc = 0;\n  _forEachInstanceProperty(_context13 = type.layout.fields).call(_context13, item => {\n    alloc += getItemAlloc(item);\n  });\n  return alloc;\n}\nfunction decodeLength(bytes) {\n  let len = 0;\n  let size = 0;\n  for (;;) {\n    let elem = bytes.shift();\n    len |= (elem & 0x7f) << size * 7;\n    size += 1;\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n  return len;\n}\nfunction encodeLength(bytes, len) {\n  let rem_len = len;\n  for (;;) {\n    let elem = rem_len & 0x7f;\n    rem_len >>= 7;\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\nclass CompiledKeys {\n  constructor(payer, keyMetaMap) {\n    this.payer = void 0;\n    this.keyMetaMap = void 0;\n    this.payer = payer;\n    this.keyMetaMap = keyMetaMap;\n  }\n  static compile(instructions, payer) {\n    const keyMetaMap = new _Map();\n    const getOrInsertDefault = pubkey => {\n      const address = pubkey.toBase58();\n      let keyMeta = keyMetaMap.get(address);\n      if (keyMeta === undefined) {\n        keyMeta = {\n          isSigner: false,\n          isWritable: false,\n          isInvoked: false\n        };\n        keyMetaMap.set(address, keyMeta);\n      }\n      return keyMeta;\n    };\n    const payerKeyMeta = getOrInsertDefault(payer);\n    payerKeyMeta.isSigner = true;\n    payerKeyMeta.isWritable = true;\n    for (const ix of instructions) {\n      getOrInsertDefault(ix.programId).isInvoked = true;\n      for (const accountMeta of _keysInstanceProperty(ix)) {\n        const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n        keyMeta.isSigner ||= accountMeta.isSigner;\n        keyMeta.isWritable ||= accountMeta.isWritable;\n      }\n    }\n    return new CompiledKeys(payer, keyMetaMap);\n  }\n  getMessageComponents() {\n    var _context14;\n    const mapEntries = [..._entriesInstanceProperty(_context14 = this.keyMetaMap).call(_context14)];\n    assert(mapEntries.length <= 256, 'Max static account keys length exceeded');\n    const writableSigners = _filterInstanceProperty(mapEntries).call(mapEntries, ([, meta]) => meta.isSigner && meta.isWritable);\n    const readonlySigners = _filterInstanceProperty(mapEntries).call(mapEntries, ([, meta]) => meta.isSigner && !meta.isWritable);\n    const writableNonSigners = _filterInstanceProperty(mapEntries).call(mapEntries, ([, meta]) => !meta.isSigner && meta.isWritable);\n    const readonlyNonSigners = _filterInstanceProperty(mapEntries).call(mapEntries, ([, meta]) => !meta.isSigner && !meta.isWritable);\n    const header = {\n      numRequiredSignatures: writableSigners.length + readonlySigners.length,\n      numReadonlySignedAccounts: readonlySigners.length,\n      numReadonlyUnsignedAccounts: readonlyNonSigners.length\n    };\n\n    // sanity checks\n    {\n      assert(writableSigners.length > 0, 'Expected at least one writable signer key');\n      const [payerAddress] = writableSigners[0];\n      assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');\n    }\n    const staticAccountKeys = [..._mapInstanceProperty(writableSigners).call(writableSigners, ([address]) => new PublicKey(address)), ..._mapInstanceProperty(readonlySigners).call(readonlySigners, ([address]) => new PublicKey(address)), ..._mapInstanceProperty(writableNonSigners).call(writableNonSigners, ([address]) => new PublicKey(address)), ..._mapInstanceProperty(readonlyNonSigners).call(readonlyNonSigners, ([address]) => new PublicKey(address))];\n    return [header, staticAccountKeys];\n  }\n  extractTableLookup(lookupTable) {\n    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n\n    // Don't extract lookup if no keys were found\n    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n      return;\n    }\n    return [{\n      accountKey: lookupTable.key,\n      writableIndexes,\n      readonlyIndexes\n    }, {\n      writable: drainedWritableKeys,\n      readonly: drainedReadonlyKeys\n    }];\n  }\n\n  /** @internal */\n  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n    const lookupTableIndexes = new Array();\n    const drainedKeys = new Array();\n    for (const [address, keyMeta] of _entriesInstanceProperty(_context15 = this.keyMetaMap).call(_context15)) {\n      var _context15;\n      if (keyMetaFilter(keyMeta)) {\n        const key = new PublicKey(address);\n        const lookupTableIndex = _findIndexInstanceProperty(lookupTableEntries).call(lookupTableEntries, entry => entry.equals(key));\n        if (lookupTableIndex >= 0) {\n          assert(lookupTableIndex < 256, 'Max lookup table index exceeded');\n          lookupTableIndexes.push(lookupTableIndex);\n          drainedKeys.push(key);\n          this.keyMetaMap.delete(address);\n        }\n      }\n    }\n    return [lookupTableIndexes, drainedKeys];\n  }\n}\nconst END_OF_BUFFER_ERROR_MESSAGE = 'Reached end of buffer unexpectedly';\n\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */\nfunction guardedShift(byteArray) {\n  if (byteArray.length === 0) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return byteArray.shift();\n}\n\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */\nfunction guardedSplice(byteArray, ...args) {\n  const [start] = args;\n  if (args.length === 2 // Implies that `deleteCount` was supplied\n  ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return _spliceInstanceProperty(byteArray).call(byteArray, ...args);\n}\n\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */\n\n/**\n * Message constructor arguments\n */\n\n/**\n * List of instructions to be processed atomically\n */\nclass Message {\n  constructor(args) {\n    var _context16, _context17;\n    this.header = void 0;\n    this.accountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.instructions = void 0;\n    this.indexToProgramIds = new _Map();\n    this.header = args.header;\n    this.accountKeys = _mapInstanceProperty(_context16 = args.accountKeys).call(_context16, account => new PublicKey(account));\n    this.recentBlockhash = args.recentBlockhash;\n    this.instructions = args.instructions;\n    _forEachInstanceProperty(_context17 = this.instructions).call(_context17, ix => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n  }\n  get version() {\n    return 'legacy';\n  }\n  get staticAccountKeys() {\n    return this.accountKeys;\n  }\n  get compiledInstructions() {\n    var _context18;\n    return _mapInstanceProperty(_context18 = this.instructions).call(_context18, ix => ({\n      programIdIndex: ix.programIdIndex,\n      accountKeyIndexes: ix.accounts,\n      data: bs58__default.default.decode(ix.data)\n    }));\n  }\n  get addressTableLookups() {\n    return [];\n  }\n  getAccountKeys() {\n    return new MessageAccountKeys(this.staticAccountKeys);\n  }\n  static compile(args) {\n    var _context19;\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(staticAccountKeys);\n    const instructions = _mapInstanceProperty(_context19 = accountKeys.compileInstructions(args.instructions)).call(_context19, ix => ({\n      programIdIndex: ix.programIdIndex,\n      accounts: ix.accountKeyIndexes,\n      data: bs58__default.default.encode(ix.data)\n    }));\n    return new Message({\n      header,\n      accountKeys: staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      instructions\n    });\n  }\n  isAccountSigner(index) {\n    return index < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(index) {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n  isProgramId(index) {\n    return this.indexToProgramIds.has(index);\n  }\n  programIds() {\n    var _context20;\n    return [..._valuesInstanceProperty(_context20 = this.indexToProgramIds).call(_context20)];\n  }\n  nonProgramIds() {\n    var _context21;\n    return _filterInstanceProperty(_context21 = this.accountKeys).call(_context21, (_, index) => !this.isProgramId(index));\n  }\n  serialize() {\n    var _context22, _context23;\n    const numKeys = this.accountKeys.length;\n    let keyCount = [];\n    encodeLength(keyCount, numKeys);\n    const instructions = _mapInstanceProperty(_context22 = this.instructions).call(_context22, instruction => {\n      const {\n        accounts,\n        programIdIndex\n      } = instruction;\n      const data = _Array$from(bs58__default.default.decode(instruction.data));\n      let keyIndicesCount = [];\n      encodeLength(keyIndicesCount, accounts.length);\n      let dataCount = [];\n      encodeLength(dataCount, data.length);\n      return {\n        programIdIndex,\n        keyIndicesCount: buffer.Buffer.from(keyIndicesCount),\n        keyIndices: accounts,\n        dataLength: buffer.Buffer.from(dataCount),\n        data\n      };\n    });\n    let instructionCount = [];\n    encodeLength(instructionCount, instructions.length);\n    let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);\n    buffer.Buffer.from(instructionCount).copy(instructionBuffer);\n    let instructionBufferLength = instructionCount.length;\n    _forEachInstanceProperty(instructions).call(instructions, instruction => {\n      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), BufferLayout__namespace.blob(instruction.dataLength.length, 'dataLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('userdatum'), instruction.data.length, 'data')]);\n      const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n      instructionBufferLength += length;\n    });\n    instructionBuffer = _sliceInstanceProperty(instructionBuffer).call(instructionBuffer, 0, instructionBufferLength);\n    const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, 'numRequiredSignatures'), BufferLayout__namespace.blob(1, 'numReadonlySignedAccounts'), BufferLayout__namespace.blob(1, 'numReadonlyUnsignedAccounts'), BufferLayout__namespace.blob(keyCount.length, 'keyCount'), BufferLayout__namespace.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);\n    const transaction = {\n      numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),\n      numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),\n      numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),\n      keyCount: buffer.Buffer.from(keyCount),\n      keys: _mapInstanceProperty(_context23 = this.accountKeys).call(_context23, key => toBuffer(key.toBytes())),\n      recentBlockhash: bs58__default.default.decode(this.recentBlockhash)\n    };\n    let signData = buffer.Buffer.alloc(2048);\n    const length = signDataLayout.encode(transaction, signData);\n    instructionBuffer.copy(signData, length);\n    return _sliceInstanceProperty(signData).call(signData, 0, length + instructionBuffer.length);\n  }\n\n  /**\n   * Decode a compiled message into a Message object.\n   */\n  static from(buffer$1) {\n    // Slice up wire data\n    let byteArray = [...buffer$1];\n    const numRequiredSignatures = guardedShift(byteArray);\n    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n      throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');\n    }\n    const numReadonlySignedAccounts = guardedShift(byteArray);\n    const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n    const accountCount = decodeLength(byteArray);\n    let accountKeys = [];\n    for (let i = 0; i < accountCount; i++) {\n      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n      accountKeys.push(new PublicKey(buffer.Buffer.from(account)));\n    }\n    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n    const instructionCount = decodeLength(byteArray);\n    let instructions = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountCount = decodeLength(byteArray);\n      const accounts = guardedSplice(byteArray, 0, accountCount);\n      const dataLength = decodeLength(byteArray);\n      const dataSlice = guardedSplice(byteArray, 0, dataLength);\n      const data = bs58__default.default.encode(buffer.Buffer.from(dataSlice));\n      instructions.push({\n        programIdIndex,\n        accounts,\n        data\n      });\n    }\n    const messageArgs = {\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts\n      },\n      recentBlockhash: bs58__default.default.encode(buffer.Buffer.from(recentBlockhash)),\n      accountKeys,\n      instructions\n    };\n    return new Message(messageArgs);\n  }\n}\n\n/**\n * Message constructor arguments\n */\n\nclass MessageV0 {\n  constructor(args) {\n    this.header = void 0;\n    this.staticAccountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.compiledInstructions = void 0;\n    this.addressTableLookups = void 0;\n    this.header = args.header;\n    this.staticAccountKeys = args.staticAccountKeys;\n    this.recentBlockhash = args.recentBlockhash;\n    this.compiledInstructions = args.compiledInstructions;\n    this.addressTableLookups = args.addressTableLookups;\n  }\n  get version() {\n    return 0;\n  }\n  get numAccountKeysFromLookups() {\n    let count = 0;\n    for (const lookup of this.addressTableLookups) {\n      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n    }\n    return count;\n  }\n  getAccountKeys(args) {\n    let accountKeysFromLookups;\n    if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {\n      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n        throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');\n      }\n      accountKeysFromLookups = args.accountKeysFromLookups;\n    } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {\n      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n    } else if (this.addressTableLookups.length > 0) {\n      throw new Error('Failed to get account keys because address table lookups were not resolved');\n    }\n    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n  }\n  isAccountSigner(index) {\n    return index < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(index) {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    const numStaticAccountKeys = this.staticAccountKeys.length;\n    if (index >= numStaticAccountKeys) {\n      var _context24;\n      const lookupAccountKeysIndex = index - numStaticAccountKeys;\n      const numWritableLookupAccountKeys = _reduceInstanceProperty(_context24 = this.addressTableLookups).call(_context24, (count, lookup) => count + lookup.writableIndexes.length, 0);\n      return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n    } else if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n  resolveAddressTableLookups(addressLookupTableAccounts) {\n    const accountKeysFromLookups = {\n      writable: [],\n      readonly: []\n    };\n    for (const tableLookup of this.addressTableLookups) {\n      const tableAccount = _findInstanceProperty(addressLookupTableAccounts).call(addressLookupTableAccounts, account => account.key.equals(tableLookup.accountKey));\n      if (!tableAccount) {\n        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n      }\n      for (const index of tableLookup.writableIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n        } else {\n          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n        }\n      }\n      for (const index of tableLookup.readonlyIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n        } else {\n          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n        }\n      }\n    }\n    return accountKeysFromLookups;\n  }\n  static compile(args) {\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n    const addressTableLookups = new Array();\n    const accountKeysFromLookups = {\n      writable: new Array(),\n      readonly: new Array()\n    };\n    const lookupTableAccounts = args.addressLookupTableAccounts || [];\n    for (const lookupTable of lookupTableAccounts) {\n      const extractResult = compiledKeys.extractTableLookup(lookupTable);\n      if (extractResult !== undefined) {\n        const [addressTableLookup, {\n          writable,\n          readonly\n        }] = extractResult;\n        addressTableLookups.push(addressTableLookup);\n        accountKeysFromLookups.writable.push(...writable);\n        accountKeysFromLookups.readonly.push(...readonly);\n      }\n    }\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n    const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      compiledInstructions,\n      addressTableLookups\n    });\n  }\n  serialize() {\n    var _context25;\n    const encodedStaticAccountKeysLength = Array();\n    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n    const serializedInstructions = this.serializeInstructions();\n    const encodedInstructionsLength = Array();\n    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n    const serializedAddressTableLookups = this.serializeAddressTableLookups();\n    const encodedAddressTableLookupsLength = Array();\n    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n    const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('prefix'), BufferLayout__namespace.struct([BufferLayout__namespace.u8('numRequiredSignatures'), BufferLayout__namespace.u8('numReadonlySignedAccounts'), BufferLayout__namespace.u8('numReadonlyUnsignedAccounts')], 'header'), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), BufferLayout__namespace.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), BufferLayout__namespace.blob(encodedInstructionsLength.length, 'instructionsLength'), BufferLayout__namespace.blob(serializedInstructions.length, 'serializedInstructions'), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), BufferLayout__namespace.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);\n    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n    const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n    const serializedMessageLength = messageLayout.encode({\n      prefix: MESSAGE_VERSION_0_PREFIX,\n      header: this.header,\n      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n      staticAccountKeys: _mapInstanceProperty(_context25 = this.staticAccountKeys).call(_context25, key => key.toBytes()),\n      recentBlockhash: bs58__default.default.decode(this.recentBlockhash),\n      instructionsLength: new Uint8Array(encodedInstructionsLength),\n      serializedInstructions,\n      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n      serializedAddressTableLookups\n    }, serializedMessage);\n    return _sliceInstanceProperty(serializedMessage).call(serializedMessage, 0, serializedMessageLength);\n  }\n  serializeInstructions() {\n    let serializedLength = 0;\n    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n    for (const instruction of this.compiledInstructions) {\n      const encodedAccountKeyIndexesLength = Array();\n      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n      const encodedDataLength = Array();\n      encodeLength(encodedDataLength, instruction.data.length);\n      const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8('programIdIndex'), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), BufferLayout__namespace.blob(encodedDataLength.length, 'encodedDataLength'), BufferLayout__namespace.blob(instruction.data.length, 'data')]);\n      serializedLength += instructionLayout.encode({\n        programIdIndex: instruction.programIdIndex,\n        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n        accountKeyIndexes: instruction.accountKeyIndexes,\n        encodedDataLength: new Uint8Array(encodedDataLength),\n        data: instruction.data\n      }, serializedInstructions, serializedLength);\n    }\n    return _sliceInstanceProperty(serializedInstructions).call(serializedInstructions, 0, serializedLength);\n  }\n  serializeAddressTableLookups() {\n    let serializedLength = 0;\n    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n    for (const lookup of this.addressTableLookups) {\n      const encodedWritableIndexesLength = Array();\n      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n      const encodedReadonlyIndexesLength = Array();\n      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n      const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey('accountKey'), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, 'writableIndexes'), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);\n      serializedLength += addressTableLookupLayout.encode({\n        accountKey: lookup.accountKey.toBytes(),\n        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n        writableIndexes: lookup.writableIndexes,\n        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n        readonlyIndexes: lookup.readonlyIndexes\n      }, serializedAddressTableLookups, serializedLength);\n    }\n    return _sliceInstanceProperty(serializedAddressTableLookups).call(serializedAddressTableLookups, 0, serializedLength);\n  }\n  static deserialize(serializedMessage) {\n    let byteArray = [...serializedMessage];\n    const prefix = guardedShift(byteArray);\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n    assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n    const version = maskedPrefix;\n    assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n    const header = {\n      numRequiredSignatures: guardedShift(byteArray),\n      numReadonlySignedAccounts: guardedShift(byteArray),\n      numReadonlyUnsignedAccounts: guardedShift(byteArray)\n    };\n    const staticAccountKeys = [];\n    const staticAccountKeysLength = decodeLength(byteArray);\n    for (let i = 0; i < staticAccountKeysLength; i++) {\n      staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n    }\n    const recentBlockhash = bs58__default.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n    const instructionCount = decodeLength(byteArray);\n    const compiledInstructions = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountKeyIndexesLength = decodeLength(byteArray);\n      const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n      const dataLength = decodeLength(byteArray);\n      const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n      compiledInstructions.push({\n        programIdIndex,\n        accountKeyIndexes,\n        data\n      });\n    }\n    const addressTableLookupsCount = decodeLength(byteArray);\n    const addressTableLookups = [];\n    for (let i = 0; i < addressTableLookupsCount; i++) {\n      const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n      const writableIndexesLength = decodeLength(byteArray);\n      const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n      const readonlyIndexesLength = decodeLength(byteArray);\n      const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n      addressTableLookups.push({\n        accountKey,\n        writableIndexes,\n        readonlyIndexes\n      });\n    }\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash,\n      compiledInstructions,\n      addressTableLookups\n    });\n  }\n}\n\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n  deserializeMessageVersion(serializedMessage) {\n    const prefix = serializedMessage[0];\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n\n    // if the highest bit of the prefix is not set, the message is not versioned\n    if (maskedPrefix === prefix) {\n      return 'legacy';\n    }\n\n    // the lower 7 bits of the prefix indicate the message version\n    return maskedPrefix;\n  },\n  deserialize: serializedMessage => {\n    const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n    if (version === 'legacy') {\n      return Message.from(serializedMessage);\n    }\n    if (version === 0) {\n      return MessageV0.deserialize(serializedMessage);\n    } else {\n      throw new Error(`Transaction message version ${version} deserialization is not supported`);\n    }\n  }\n};\n\n/** @internal */\n\n/**\n * Transaction signature as base-58 encoded string\n */\n\nlet TransactionStatus = /*#__PURE__*/function (TransactionStatus) {\n  TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n  TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n  TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n  return TransactionStatus;\n}({});\n\n/**\n * Default (empty) signature\n */\nconst DEFAULT_SIGNATURE = _fillInstanceProperty(_context26 = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES)).call(_context26, 0);\n\n/**\n * Account metadata used to define instructions\n */\n\n/**\n * List of TransactionInstruction object fields that may be initialized at construction\n */\n\n/**\n * Configuration object for Transaction.serialize()\n */\n\n/**\n * @internal\n */\n\n/**\n * Transaction Instruction class\n */\nclass TransactionInstruction {\n  constructor(opts) {\n    /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */\n    this.keys = void 0;\n    /**\n     * Program Id to execute\n     */\n    this.programId = void 0;\n    /**\n     * Program input\n     */\n    this.data = buffer.Buffer.alloc(0);\n    this.programId = opts.programId;\n    this.keys = _keysInstanceProperty(opts);\n    if (opts.data) {\n      this.data = opts.data;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON() {\n    var _context27;\n    return {\n      keys: _mapInstanceProperty(_context27 = _keysInstanceProperty(this)).call(_context27, ({\n        pubkey,\n        isSigner,\n        isWritable\n      }) => ({\n        pubkey: pubkey.toJSON(),\n        isSigner,\n        isWritable\n      })),\n      programId: this.programId.toJSON(),\n      data: [...this.data]\n    };\n  }\n}\n\n/**\n * Pair of signature and corresponding public key\n */\n\n/**\n * List of Transaction object fields that may be initialized at construction\n */\n\n// For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */\n\n/**\n * Use these options to construct a durable nonce transaction.\n */\n\n/**\n * Nonce information to be used to build an offline Transaction.\n */\n\n/**\n * @internal\n */\n\n/**\n * Transaction class\n */\nclass Transaction {\n  /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */\n  get signature() {\n    if (this.signatures.length > 0) {\n      return this.signatures[0].signature;\n    }\n    return null;\n  }\n\n  /**\n   * The transaction fee payer\n   */\n\n  // Construct a transaction with a blockhash and lastValidBlockHeight\n\n  // Construct a transaction using a durable nonce\n\n  /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */\n\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(opts) {\n    /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */\n    this.signatures = [];\n    this.feePayer = void 0;\n    /**\n     * The instructions to atomically execute\n     */\n    this.instructions = [];\n    /**\n     * A recent transaction id. Must be populated by the caller\n     */\n    this.recentBlockhash = void 0;\n    /**\n     * the last block chain can advance to before tx is declared expired\n     * */\n    this.lastValidBlockHeight = void 0;\n    /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */\n    this.nonceInfo = void 0;\n    /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */\n    this.minNonceContextSlot = void 0;\n    /**\n     * @internal\n     */\n    this._message = void 0;\n    /**\n     * @internal\n     */\n    this._json = void 0;\n    if (!opts) {\n      return;\n    }\n    if (opts.feePayer) {\n      this.feePayer = opts.feePayer;\n    }\n    if (opts.signatures) {\n      this.signatures = opts.signatures;\n    }\n    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {\n      const {\n        minContextSlot,\n        nonceInfo\n      } = opts;\n      this.minNonceContextSlot = minContextSlot;\n      this.nonceInfo = nonceInfo;\n    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {\n      const {\n        blockhash,\n        lastValidBlockHeight\n      } = opts;\n      this.recentBlockhash = blockhash;\n      this.lastValidBlockHeight = lastValidBlockHeight;\n    } else {\n      const {\n        recentBlockhash,\n        nonceInfo\n      } = opts;\n      if (nonceInfo) {\n        this.nonceInfo = nonceInfo;\n      }\n      this.recentBlockhash = recentBlockhash;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON() {\n    var _context28, _context29;\n    return {\n      recentBlockhash: this.recentBlockhash || null,\n      feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n      nonceInfo: this.nonceInfo ? {\n        nonce: this.nonceInfo.nonce,\n        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n      } : null,\n      instructions: _mapInstanceProperty(_context28 = this.instructions).call(_context28, instruction => instruction.toJSON()),\n      signers: _mapInstanceProperty(_context29 = this.signatures).call(_context29, ({\n        publicKey\n      }) => {\n        return publicKey.toJSON();\n      })\n    };\n  }\n\n  /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */\n  add(...items) {\n    if (items.length === 0) {\n      throw new Error('No instructions');\n    }\n    _forEachInstanceProperty(items).call(items, item => {\n      if ('instructions' in item) {\n        var _context30;\n        this.instructions = _concatInstanceProperty(_context30 = this.instructions).call(_context30, item.instructions);\n      } else if ('data' in item && 'programId' in item && 'keys' in item) {\n        this.instructions.push(item);\n      } else {\n        this.instructions.push(new TransactionInstruction(item));\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Compile transaction data\n   */\n  compileMessage() {\n    if (this._message && _JSON$stringify(this.toJSON()) === _JSON$stringify(this._json)) {\n      return this._message;\n    }\n    let recentBlockhash;\n    let instructions;\n    if (this.nonceInfo) {\n      recentBlockhash = this.nonceInfo.nonce;\n      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];\n      } else {\n        instructions = this.instructions;\n      }\n    } else {\n      recentBlockhash = this.recentBlockhash;\n      instructions = this.instructions;\n    }\n    if (!recentBlockhash) {\n      throw new Error('Transaction recentBlockhash required');\n    }\n    if (instructions.length < 1) {\n      console.warn('No instructions provided');\n    }\n    let feePayer;\n    if (this.feePayer) {\n      feePayer = this.feePayer;\n    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n      // Use implicit fee payer\n      feePayer = this.signatures[0].publicKey;\n    } else {\n      throw new Error('Transaction fee payer required');\n    }\n    for (let i = 0; i < instructions.length; i++) {\n      if (instructions[i].programId === undefined) {\n        throw new Error(`Transaction instruction index ${i} has undefined program id`);\n      }\n    }\n    const programIds = [];\n    const accountMetas = [];\n    _forEachInstanceProperty(instructions).call(instructions, instruction => {\n      var _context31;\n      _forEachInstanceProperty(_context31 = _keysInstanceProperty(instruction)).call(_context31, accountMeta => {\n        accountMetas.push(_objectSpread({}, accountMeta));\n      });\n      const programId = instruction.programId.toString();\n      if (!_includesInstanceProperty(programIds).call(programIds, programId)) {\n        programIds.push(programId);\n      }\n    });\n\n    // Append programID account metas\n    _forEachInstanceProperty(programIds).call(programIds, programId => {\n      accountMetas.push({\n        pubkey: new PublicKey(programId),\n        isSigner: false,\n        isWritable: false\n      });\n    });\n\n    // Cull duplicate account metas\n    const uniqueMetas = [];\n    _forEachInstanceProperty(accountMetas).call(accountMetas, accountMeta => {\n      const pubkeyString = accountMeta.pubkey.toString();\n      const uniqueIndex = _findIndexInstanceProperty(uniqueMetas).call(uniqueMetas, x => {\n        return x.pubkey.toString() === pubkeyString;\n      });\n      if (uniqueIndex > -1) {\n        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n      } else {\n        uniqueMetas.push(accountMeta);\n      }\n    });\n\n    // Sort. Prioritizing first by signer, then by writable\n    _sortInstanceProperty(uniqueMetas).call(uniqueMetas, function (x, y) {\n      if (x.isSigner !== y.isSigner) {\n        // Signers always come before non-signers\n        return x.isSigner ? -1 : 1;\n      }\n      if (x.isWritable !== y.isWritable) {\n        // Writable accounts always come before read-only accounts\n        return x.isWritable ? -1 : 1;\n      }\n      // Otherwise, sort by pubkey, stringwise.\n      const options = {\n        localeMatcher: 'best fit',\n        usage: 'sort',\n        sensitivity: 'variant',\n        ignorePunctuation: false,\n        numeric: false,\n        caseFirst: 'lower'\n      };\n      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), 'en', options);\n    });\n\n    // Move fee payer to the front\n    const feePayerIndex = _findIndexInstanceProperty(uniqueMetas).call(uniqueMetas, x => {\n      return x.pubkey.equals(feePayer);\n    });\n    if (feePayerIndex > -1) {\n      const [payerMeta] = _spliceInstanceProperty(uniqueMetas).call(uniqueMetas, feePayerIndex, 1);\n      payerMeta.isSigner = true;\n      payerMeta.isWritable = true;\n      uniqueMetas.unshift(payerMeta);\n    } else {\n      uniqueMetas.unshift({\n        pubkey: feePayer,\n        isSigner: true,\n        isWritable: true\n      });\n    }\n\n    // Disallow unknown signers\n    for (const signature of this.signatures) {\n      const uniqueIndex = _findIndexInstanceProperty(uniqueMetas).call(uniqueMetas, x => {\n        return x.pubkey.equals(signature.publicKey);\n      });\n      if (uniqueIndex > -1) {\n        if (!uniqueMetas[uniqueIndex].isSigner) {\n          uniqueMetas[uniqueIndex].isSigner = true;\n          console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');\n        }\n      } else {\n        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n      }\n    }\n    let numRequiredSignatures = 0;\n    let numReadonlySignedAccounts = 0;\n    let numReadonlyUnsignedAccounts = 0;\n\n    // Split out signing from non-signing keys and count header values\n    const signedKeys = [];\n    const unsignedKeys = [];\n    _forEachInstanceProperty(uniqueMetas).call(uniqueMetas, ({\n      pubkey,\n      isSigner,\n      isWritable\n    }) => {\n      if (isSigner) {\n        signedKeys.push(pubkey.toString());\n        numRequiredSignatures += 1;\n        if (!isWritable) {\n          numReadonlySignedAccounts += 1;\n        }\n      } else {\n        unsignedKeys.push(pubkey.toString());\n        if (!isWritable) {\n          numReadonlyUnsignedAccounts += 1;\n        }\n      }\n    });\n    const accountKeys = _concatInstanceProperty(signedKeys).call(signedKeys, unsignedKeys);\n    const compiledInstructions = _mapInstanceProperty(instructions).call(instructions, instruction => {\n      var _context32;\n      const {\n        data,\n        programId\n      } = instruction;\n      return {\n        programIdIndex: _indexOfInstanceProperty(accountKeys).call(accountKeys, programId.toString()),\n        accounts: _mapInstanceProperty(_context32 = _keysInstanceProperty(instruction)).call(_context32, meta => _indexOfInstanceProperty(accountKeys).call(accountKeys, meta.pubkey.toString())),\n        data: bs58__default.default.encode(data)\n      };\n    });\n    _forEachInstanceProperty(compiledInstructions).call(compiledInstructions, instruction => {\n      var _context33;\n      assert(instruction.programIdIndex >= 0);\n      _forEachInstanceProperty(_context33 = instruction.accounts).call(_context33, keyIndex => assert(keyIndex >= 0));\n    });\n    return new Message({\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts\n      },\n      accountKeys,\n      recentBlockhash,\n      instructions: compiledInstructions\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _compile() {\n    var _context34;\n    const message = this.compileMessage();\n    const signedKeys = _sliceInstanceProperty(_context34 = message.accountKeys).call(_context34, 0, message.header.numRequiredSignatures);\n    if (this.signatures.length === signedKeys.length) {\n      var _context35;\n      const valid = _everyInstanceProperty(_context35 = this.signatures).call(_context35, (pair, index) => {\n        return signedKeys[index].equals(pair.publicKey);\n      });\n      if (valid) return message;\n    }\n    this.signatures = _mapInstanceProperty(signedKeys).call(signedKeys, publicKey => ({\n      signature: null,\n      publicKey\n    }));\n    return message;\n  }\n\n  /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */\n  serializeMessage() {\n    return this._compile().serialize();\n  }\n\n  /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */\n  async getEstimatedFee(connection) {\n    return (await connection.getFeeForMessage(this.compileMessage())).value;\n  }\n\n  /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */\n  setSigners(...signers) {\n    var _context36;\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n    const seen = new _Set();\n    this.signatures = _mapInstanceProperty(_context36 = _filterInstanceProperty(signers).call(signers, publicKey => {\n      const key = publicKey.toString();\n      if (seen.has(key)) {\n        return false;\n      } else {\n        seen.add(key);\n        return true;\n      }\n    })).call(_context36, publicKey => ({\n      signature: null,\n      publicKey\n    }));\n  }\n\n  /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  sign(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new _Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n    this.signatures = _mapInstanceProperty(uniqueSigners).call(uniqueSigners, signer => ({\n      signature: null,\n      publicKey: signer.publicKey\n    }));\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  partialSign(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new _Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * @internal\n   */\n  _partialSign(message, ...signers) {\n    const signData = message.serialize();\n    _forEachInstanceProperty(signers).call(signers, signer => {\n      const signature = sign(signData, signer.secretKey);\n      this._addSignature(signer.publicKey, toBuffer(signature));\n    });\n  }\n\n  /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */\n  addSignature(pubkey, signature) {\n    this._compile(); // Ensure signatures array is populated\n    this._addSignature(pubkey, signature);\n  }\n\n  /**\n   * @internal\n   */\n  _addSignature(pubkey, signature) {\n    var _context37;\n    assert(signature.length === 64);\n    const index = _findIndexInstanceProperty(_context37 = this.signatures).call(_context37, sigpair => pubkey.equals(sigpair.publicKey));\n    if (index < 0) {\n      throw new Error(`unknown signer: ${pubkey.toString()}`);\n    }\n    this.signatures[index].signature = buffer.Buffer.from(signature);\n  }\n\n  /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */\n  verifySignatures(requireAllSignatures = true) {\n    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n    return !signatureErrors;\n  }\n\n  /**\n   * @internal\n   */\n  _getMessageSignednessErrors(message, requireAllSignatures) {\n    const errors = {};\n    for (const {\n      signature,\n      publicKey\n    } of this.signatures) {\n      if (signature === null) {\n        if (requireAllSignatures) {\n          (errors.missing ||= []).push(publicKey);\n        }\n      } else {\n        if (!verify(signature, message, publicKey.toBytes())) {\n          (errors.invalid ||= []).push(publicKey);\n        }\n      }\n    }\n    return errors.invalid || errors.missing ? errors : undefined;\n  }\n\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */\n  serialize(config) {\n    const {\n      requireAllSignatures,\n      verifySignatures\n    } = _Object$assign({\n      requireAllSignatures: true,\n      verifySignatures: true\n    }, config);\n    const signData = this.serializeMessage();\n    if (verifySignatures) {\n      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n      if (sigErrors) {\n        let errorMessage = 'Signature verification failed.';\n        if (sigErrors.invalid) {\n          var _context38;\n          errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? '' : '(s)'} [\\`${_mapInstanceProperty(_context38 = sigErrors.invalid).call(_context38, p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        if (sigErrors.missing) {\n          var _context39;\n          errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? '' : '(s)'} [\\`${_mapInstanceProperty(_context39 = sigErrors.missing).call(_context39, p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        throw new Error(errorMessage);\n      }\n    }\n    return this._serialize(signData);\n  }\n\n  /**\n   * @internal\n   */\n  _serialize(signData) {\n    const {\n      signatures\n    } = this;\n    const signatureCount = [];\n    encodeLength(signatureCount, signatures.length);\n    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n    const wireTransaction = buffer.Buffer.alloc(transactionLength);\n    assert(signatures.length < 256);\n    buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);\n    _forEachInstanceProperty(signatures).call(signatures, ({\n      signature\n    }, index) => {\n      if (signature !== null) {\n        assert(signature.length === 64, `signature has invalid length`);\n        buffer.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n      }\n    });\n    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n    assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n    return wireTransaction;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get keys() {\n    var _context40;\n    assert(this.instructions.length === 1);\n    return _mapInstanceProperty(_context40 = _keysInstanceProperty(this.instructions[0])).call(_context40, keyObj => keyObj.pubkey);\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get programId() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].programId;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get data() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].data;\n  }\n\n  /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */\n  static from(buffer$1) {\n    // Slice up wire data\n    let byteArray = [...buffer$1];\n    const signatureCount = decodeLength(byteArray);\n    let signatures = [];\n    for (let i = 0; i < signatureCount; i++) {\n      const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n      signatures.push(bs58__default.default.encode(buffer.Buffer.from(signature)));\n    }\n    return Transaction.populate(Message.from(byteArray), signatures);\n  }\n\n  /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */\n  static populate(message, signatures = []) {\n    var _context41;\n    const transaction = new Transaction();\n    transaction.recentBlockhash = message.recentBlockhash;\n    if (message.header.numRequiredSignatures > 0) {\n      transaction.feePayer = message.accountKeys[0];\n    }\n    _forEachInstanceProperty(signatures).call(signatures, (signature, index) => {\n      const sigPubkeyPair = {\n        signature: signature == bs58__default.default.encode(DEFAULT_SIGNATURE) ? null : bs58__default.default.decode(signature),\n        publicKey: message.accountKeys[index]\n      };\n      transaction.signatures.push(sigPubkeyPair);\n    });\n    _forEachInstanceProperty(_context41 = message.instructions).call(_context41, instruction => {\n      var _context42;\n      const keys = _mapInstanceProperty(_context42 = instruction.accounts).call(_context42, account => {\n        var _context43;\n        const pubkey = message.accountKeys[account];\n        return {\n          pubkey,\n          isSigner: _someInstanceProperty(_context43 = transaction.signatures).call(_context43, keyObj => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n          isWritable: message.isAccountWritable(account)\n        };\n      });\n      transaction.instructions.push(new TransactionInstruction({\n        keys,\n        programId: message.accountKeys[instruction.programIdIndex],\n        data: bs58__default.default.decode(instruction.data)\n      }));\n    });\n    transaction._message = message;\n    transaction._json = transaction.toJSON();\n    return transaction;\n  }\n}\nclass TransactionMessage {\n  constructor(args) {\n    this.payerKey = void 0;\n    this.instructions = void 0;\n    this.recentBlockhash = void 0;\n    this.payerKey = args.payerKey;\n    this.instructions = args.instructions;\n    this.recentBlockhash = args.recentBlockhash;\n  }\n  static decompile(message, args) {\n    const {\n      header,\n      compiledInstructions,\n      recentBlockhash\n    } = message;\n    const {\n      numRequiredSignatures,\n      numReadonlySignedAccounts,\n      numReadonlyUnsignedAccounts\n    } = header;\n    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n    assert(numWritableSignedAccounts > 0, 'Message header is invalid');\n    const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n    assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');\n    const accountKeys = message.getAccountKeys(args);\n    const payerKey = accountKeys.get(0);\n    if (payerKey === undefined) {\n      throw new Error('Failed to decompile message because no account keys were found');\n    }\n    const instructions = [];\n    for (const compiledIx of compiledInstructions) {\n      const keys = [];\n      for (const keyIndex of compiledIx.accountKeyIndexes) {\n        const pubkey = accountKeys.get(keyIndex);\n        if (pubkey === undefined) {\n          throw new Error(`Failed to find key for account key index ${keyIndex}`);\n        }\n        const isSigner = keyIndex < numRequiredSignatures;\n        let isWritable;\n        if (isSigner) {\n          isWritable = keyIndex < numWritableSignedAccounts;\n        } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n        } else {\n          isWritable = keyIndex - accountKeys.staticAccountKeys.length <\n          // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n          accountKeys.accountKeysFromLookups.writable.length;\n        }\n        keys.push({\n          pubkey,\n          isSigner: keyIndex < header.numRequiredSignatures,\n          isWritable\n        });\n      }\n      const programId = accountKeys.get(compiledIx.programIdIndex);\n      if (programId === undefined) {\n        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n      }\n      instructions.push(new TransactionInstruction({\n        programId,\n        data: toBuffer(compiledIx.data),\n        keys\n      }));\n    }\n    return new TransactionMessage({\n      payerKey,\n      instructions,\n      recentBlockhash\n    });\n  }\n  compileToLegacyMessage() {\n    return Message.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions\n    });\n  }\n  compileToV0Message(addressLookupTableAccounts) {\n    return MessageV0.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions,\n      addressLookupTableAccounts\n    });\n  }\n}\n\n/**\n * Versioned transaction class\n */\nclass VersionedTransaction {\n  get version() {\n    return this.message.version;\n  }\n  constructor(message, signatures) {\n    this.signatures = void 0;\n    this.message = void 0;\n    if (signatures !== undefined) {\n      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');\n      this.signatures = signatures;\n    } else {\n      const defaultSignatures = [];\n      for (let i = 0; i < message.header.numRequiredSignatures; i++) {\n        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n      }\n      this.signatures = defaultSignatures;\n    }\n    this.message = message;\n  }\n  serialize() {\n    const serializedMessage = this.message.serialize();\n    const encodedSignaturesLength = Array();\n    encodeLength(encodedSignaturesLength, this.signatures.length);\n    const transactionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), BufferLayout__namespace.seq(signature(), this.signatures.length, 'signatures'), BufferLayout__namespace.blob(serializedMessage.length, 'serializedMessage')]);\n    const serializedTransaction = new Uint8Array(2048);\n    const serializedTransactionLength = transactionLayout.encode({\n      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n      signatures: this.signatures,\n      serializedMessage\n    }, serializedTransaction);\n    return _sliceInstanceProperty(serializedTransaction).call(serializedTransaction, 0, serializedTransactionLength);\n  }\n  static deserialize(serializedTransaction) {\n    let byteArray = [...serializedTransaction];\n    const signatures = [];\n    const signaturesLength = decodeLength(byteArray);\n    for (let i = 0; i < signaturesLength; i++) {\n      signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n    }\n    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n    return new VersionedTransaction(message, signatures);\n  }\n  sign(signers) {\n    var _context44;\n    const messageData = this.message.serialize();\n    const signerPubkeys = _sliceInstanceProperty(_context44 = this.message.staticAccountKeys).call(_context44, 0, this.message.header.numRequiredSignatures);\n    for (const signer of signers) {\n      const signerIndex = _findIndexInstanceProperty(signerPubkeys).call(signerPubkeys, pubkey => pubkey.equals(signer.publicKey));\n      assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n      this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n    }\n  }\n  addSignature(publicKey, signature) {\n    var _context45;\n    assert(signature.byteLength === 64, 'Signature must be 64 bytes long');\n    const signerPubkeys = _sliceInstanceProperty(_context45 = this.message.staticAccountKeys).call(_context45, 0, this.message.header.numRequiredSignatures);\n    const signerIndex = _findIndexInstanceProperty(signerPubkeys).call(signerPubkeys, pubkey => pubkey.equals(publicKey));\n    assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n    this.signatures[signerIndex] = signature;\n  }\n}\n\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @internal\n */\nconst NUM_TICKS_PER_SECOND = 160;\n\n/**\n * @internal\n */\nconst DEFAULT_TICKS_PER_SLOT = 64;\n\n/**\n * @internal\n */\nconst NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n\n/**\n * @internal\n */\nconst MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');\nconst SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');\nclass SendTransactionError extends Error {\n  constructor({\n    action,\n    signature,\n    transactionMessage,\n    logs\n  }) {\n    const maybeLogsOutput = logs ? `Logs: \\n${_JSON$stringify(_sliceInstanceProperty(logs).call(logs, -10), null, 2)}. ` : '';\n    const guideText = '\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.';\n    let message;\n    switch (action) {\n      case 'send':\n        message = `Transaction ${signature} resulted in an error. \\n` + `${transactionMessage}. ` + maybeLogsOutput + guideText;\n        break;\n      case 'simulate':\n        message = `Simulation failed. \\nMessage: ${transactionMessage}. \\n` + maybeLogsOutput + guideText;\n        break;\n      default:\n        {\n          message = `Unknown action '${(a => a)(action)}'`;\n        }\n    }\n    super(message);\n    this.signature = void 0;\n    this.transactionMessage = void 0;\n    this.transactionLogs = void 0;\n    this.signature = signature;\n    this.transactionMessage = transactionMessage;\n    this.transactionLogs = logs ? logs : undefined;\n  }\n  get transactionError() {\n    return {\n      message: this.transactionMessage,\n      logs: _Array$isArray(this.transactionLogs) ? this.transactionLogs : undefined\n    };\n  }\n\n  /* @deprecated Use `await getLogs()` instead */\n  get logs() {\n    const cachedLogs = this.transactionLogs;\n    if (cachedLogs != null && typeof cachedLogs === 'object' && 'then' in cachedLogs) {\n      return undefined;\n    }\n    return cachedLogs;\n  }\n  async getLogs(connection) {\n    if (!_Array$isArray(this.transactionLogs)) {\n      this.transactionLogs = new _Promise((resolve, reject) => {\n        connection.getTransaction(this.signature).then(tx => {\n          if (tx && tx.meta && tx.meta.logMessages) {\n            const logs = tx.meta.logMessages;\n            this.transactionLogs = logs;\n            resolve(logs);\n          } else {\n            reject(new Error('Log messages not found'));\n          }\n        }).catch(reject);\n      });\n    }\n    return await this.transactionLogs;\n  }\n}\n\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n  JSON_RPC_SCAN_ERROR: -32012,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n  constructor({\n    code,\n    message,\n    data\n  }, customMessage) {\n    super(customMessage != null ? `${customMessage}: ${message}` : message);\n    this.code = void 0;\n    this.data = void 0;\n    this.code = code;\n    this.data = data;\n    this.name = 'SolanaJSONRPCError';\n  }\n}\n\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\nasync function sendAndConfirmTransaction(connection, transaction, signers, options) {\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    maxRetries: options.maxRetries,\n    minContextSlot: options.minContextSlot\n  };\n  const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n  let status;\n  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n    status = (await connection.confirmTransaction({\n      abortSignal: options?.abortSignal,\n      signature: signature,\n      blockhash: transaction.recentBlockhash,\n      lastValidBlockHeight: transaction.lastValidBlockHeight\n    }, options && options.commitment)).value;\n  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n    const {\n      nonceInstruction\n    } = transaction.nonceInfo;\n    const nonceAccountPubkey = _keysInstanceProperty(nonceInstruction)[0].pubkey;\n    status = (await connection.confirmTransaction({\n      abortSignal: options?.abortSignal,\n      minContextSlot: transaction.minNonceContextSlot,\n      nonceAccountPubkey,\n      nonceValue: transaction.nonceInfo.nonce,\n      signature\n    }, options && options.commitment)).value;\n  } else {\n    if (options?.abortSignal != null) {\n      console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');\n    }\n    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n  }\n  if (status.err) {\n    if (signature != null) {\n      throw new SendTransactionError({\n        action: 'send',\n        signature: signature,\n        transactionMessage: `Status: (${_JSON$stringify(status)})`\n      });\n    }\n    throw new Error(`Transaction ${signature} failed (${_JSON$stringify(status)})`);\n  }\n  return signature;\n}\n\n// zzz\nfunction sleep(ms) {\n  return new _Promise(resolve => _setTimeout(resolve, ms));\n}\n\n/**\n * @internal\n */\n\n/**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */\nfunction encodeData(type, fields) {\n  const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n  const data = buffer.Buffer.alloc(allocLength);\n  const layoutFields = _Object$assign({\n    instruction: type.index\n  }, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */\nfunction decodeData$1(type, buffer) {\n  let data;\n  try {\n    data = type.layout.decode(buffer);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (data.instruction !== type.index) {\n    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n  }\n  return data;\n}\n\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */\nconst FeeCalculatorLayout = BufferLayout__namespace.nu64('lamportsPerSignature');\n\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */\nconst NonceAccountLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('version'), BufferLayout__namespace.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), BufferLayout__namespace.struct([FeeCalculatorLayout], 'feeCalculator')]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */\n\n/**\n * NonceAccount class\n */\nclass NonceAccount {\n  /**\n   * @internal\n   */\n  constructor(args) {\n    this.authorizedPubkey = void 0;\n    this.nonce = void 0;\n    this.feeCalculator = void 0;\n    this.authorizedPubkey = args.authorizedPubkey;\n    this.nonce = args.nonce;\n    this.feeCalculator = args.feeCalculator;\n  }\n\n  /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */\n  static fromAccountData(buffer) {\n    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n    return new NonceAccount({\n      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n      nonce: new PublicKey(nonceAccount.nonce).toString(),\n      feeCalculator: nonceAccount.feeCalculator\n    });\n  }\n}\nconst encodeDecode = layout => {\n  var _context46, _context47;\n  const decode = _bindInstanceProperty(_context46 = layout.decode).call(_context46, layout);\n  const encode = _bindInstanceProperty(_context47 = layout.encode).call(_context47, layout);\n  return {\n    decode,\n    encode\n  };\n};\nconst bigInt = length => property => {\n  const layout = BufferLayout.blob(length, property);\n  const {\n    encode,\n    decode\n  } = encodeDecode(layout);\n  const bigIntLayout = layout;\n  bigIntLayout.decode = (buffer$1, offset) => {\n    const src = decode(buffer$1, offset);\n    return bigintBuffer.toBigIntLE(buffer.Buffer.from(src));\n  };\n  bigIntLayout.encode = (bigInt, buffer, offset) => {\n    const src = bigintBuffer.toBufferLE(bigInt, length);\n    return encode(src, buffer, offset);\n  };\n  return bigIntLayout;\n};\nconst u64 = bigInt(8);\n\n/**\n * Create account system transaction params\n */\n\n/**\n * Transfer system transaction params\n */\n\n/**\n * Assign system transaction params\n */\n\n/**\n * Create account with seed system transaction params\n */\n\n/**\n * Create nonce account system transaction params\n */\n\n/**\n * Create nonce account with seed system transaction params\n */\n\n/**\n * Initialize nonce account system instruction params\n */\n\n/**\n * Advance nonce account system instruction params\n */\n\n/**\n * Withdraw nonce account system transaction params\n */\n\n/**\n * Authorize nonce account system transaction params\n */\n\n/**\n * Allocate account system transaction params\n */\n\n/**\n * Allocate account with seed system transaction params\n */\n\n/**\n * Assign account with seed system transaction params\n */\n\n/**\n * Transfer with seed system transaction params\n */\n\n/** Decoded transfer system transaction instruction */\n\n/** Decoded transferWithSeed system transaction instruction */\n\n/**\n * System Instruction class\n */\nclass SystemInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a system instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of _Object$entries(SYSTEM_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a SystemInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */\n  static decodeCreateAccount(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 2);\n    const {\n      lamports,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n    return {\n      fromPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      newAccountPubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      lamports,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */\n  static decodeTransfer(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 2);\n    const {\n      lamports\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n    return {\n      fromPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      toPubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */\n  static decodeTransferWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    const {\n      lamports,\n      seed,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n    return {\n      fromPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      basePubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      toPubkey: _keysInstanceProperty(instruction)[2].pubkey,\n      lamports,\n      seed,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */\n  static decodeAllocate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 1);\n    const {\n      space\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n    return {\n      accountPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      space\n    };\n  }\n\n  /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAllocateWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 1);\n    const {\n      base,\n      seed,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n    return {\n      accountPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */\n  static decodeAssign(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 1);\n    const {\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n    return {\n      accountPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAssignWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 1);\n    const {\n      base,\n      seed,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n    return {\n      accountPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */\n  static decodeCreateWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 2);\n    const {\n      base,\n      seed,\n      lamports,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n    return {\n      fromPubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      newAccountPubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      lamports,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceInitialize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    const {\n      authorized\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n    return {\n      noncePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorizedPubkey: new PublicKey(authorized)\n    };\n  }\n\n  /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAdvance(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n    return {\n      noncePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[2].pubkey\n    };\n  }\n\n  /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */\n  static decodeNonceWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 5);\n    const {\n      lamports\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n    return {\n      noncePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      toPubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[4].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 2);\n    const {\n      authorized\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n    return {\n      noncePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      newAuthorizedPubkey: new PublicKey(authorized)\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(SystemProgram.programId)) {\n      throw new Error('invalid instruction; programId is not SystemProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid SystemInstructionType's\n */\n\n/**\n * An enumeration of valid system InstructionType's\n * @internal\n */\nconst SYSTEM_INSTRUCTION_LAYOUTS = _Object$freeze({\n  Create: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])\n  },\n  Assign: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('programId')])\n  },\n  Transfer: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports')])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('lamports'), BufferLayout__namespace.ns64('space'), publicKey('programId')])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('authorized')])\n  },\n  Allocate: {\n    index: 8,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('space')])\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), BufferLayout__namespace.ns64('space'), publicKey('programId')])\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  }\n});\n\n/**\n * Factory class for transactions to interact with the System program\n */\nclass SystemProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the System program\n   */\n\n  /**\n   * Generate a transaction instruction that creates a new account\n   */\n  static createAccount(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n    const data = encodeData(type, {\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer())\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.newAccountPubkey,\n        isSigner: true,\n        isWritable: true\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */\n  static transfer(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n      data = encodeData(type, {\n        lamports: BigInt(params.lamports),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n      data = encodeData(type, {\n        lamports: BigInt(params.lamports)\n      });\n      keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that assigns an account to a program\n   */\n  static assign(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n      data = encodeData(type, {\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: true,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */\n  static createAccountWithSeed(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n    const data = encodeData(type, {\n      base: toBuffer(params.basePubkey.toBuffer()),\n      seed: params.seed,\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer())\n    });\n    let keys = [{\n      pubkey: params.fromPubkey,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: params.newAccountPubkey,\n      isSigner: false,\n      isWritable: true\n    }];\n    if (!params.basePubkey.equals(params.fromPubkey)) {\n      keys.push({\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction that creates a new Nonce account\n   */\n  static createNonceAccount(params) {\n    const transaction = new Transaction();\n    if ('basePubkey' in params && 'seed' in params) {\n      transaction.add(SystemProgram.createAccountWithSeed({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.noncePubkey,\n        basePubkey: params.basePubkey,\n        seed: params.seed,\n        lamports: params.lamports,\n        space: NONCE_ACCOUNT_LENGTH,\n        programId: this.programId\n      }));\n    } else {\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.noncePubkey,\n        lamports: params.lamports,\n        space: NONCE_ACCOUNT_LENGTH,\n        programId: this.programId\n      }));\n    }\n    const initParams = {\n      noncePubkey: params.noncePubkey,\n      authorizedPubkey: params.authorizedPubkey\n    };\n    transaction.add(this.nonceInitialize(initParams));\n    return transaction;\n  }\n\n  /**\n   * Generate an instruction to initialize a Nonce account\n   */\n  static nonceInitialize(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.authorizedPubkey.toBuffer())\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */\n  static nonceAdvance(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n    const data = encodeData(type);\n    const instructionData = {\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */\n  static nonceWithdraw(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n    const data = encodeData(type, {\n      lamports: params.lamports\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */\n  static nonceAuthorize(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */\n  static allocate(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n      data = encodeData(type, {\n        space: params.space\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: true,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n}\nSystemProgram.programId = new PublicKey('11111111111111111111111111111111');\n\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n\n/**\n * Program loader interface\n */\nclass Loader {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Amount of program data placed in each load Transaction\n   */\n\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength) {\n    return 2 * (\n    // Every transaction requires two signatures (payer + program)\n    Math.ceil(dataLength / Loader.chunkSize) + 1 +\n    // Add one for Create transaction\n    1) // Add one for Finalize transaction\n    ;\n  }\n\n  /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static async load(connection, payer, program, programId, data) {\n    {\n      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n\n      // Fetch program account info to check if it has already been created\n      const programInfo = await connection.getAccountInfo(program.publicKey, 'confirmed');\n      let transaction = null;\n      if (programInfo !== null) {\n        if (programInfo.executable) {\n          console.error('Program load failed, account is already executable');\n          return false;\n        }\n        if (programInfo.data.length !== data.length) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.allocate({\n            accountPubkey: program.publicKey,\n            space: data.length\n          }));\n        }\n        if (!programInfo.owner.equals(programId)) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.assign({\n            accountPubkey: program.publicKey,\n            programId\n          }));\n        }\n        if (programInfo.lamports < balanceNeeded) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: program.publicKey,\n            lamports: balanceNeeded - programInfo.lamports\n          }));\n        }\n      } else {\n        transaction = new Transaction().add(SystemProgram.createAccount({\n          fromPubkey: payer.publicKey,\n          newAccountPubkey: program.publicKey,\n          lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n          space: data.length,\n          programId\n        }));\n      }\n\n      // If the account is already created correctly, skip this step\n      // and proceed directly to loading instructions\n      if (transaction !== null) {\n        await sendAndConfirmTransaction(connection, transaction, [payer, program], {\n          commitment: 'confirmed'\n        });\n      }\n    }\n    const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.u32('offset'), BufferLayout__namespace.u32('bytesLength'), BufferLayout__namespace.u32('bytesLengthPadding'), BufferLayout__namespace.seq(BufferLayout__namespace.u8('byte'), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'bytes')]);\n    const chunkSize = Loader.chunkSize;\n    let offset = 0;\n    let array = data;\n    let transactions = [];\n    while (array.length > 0) {\n      var _context48;\n      const bytes = _sliceInstanceProperty(array).call(array, 0, chunkSize);\n      const data = buffer.Buffer.alloc(chunkSize + 16);\n      dataLayout.encode({\n        instruction: 0,\n        // Load instruction\n        offset,\n        bytes: bytes,\n        bytesLength: 0,\n        bytesLengthPadding: 0\n      }, data);\n      const transaction = new Transaction().add({\n        keys: [{\n          pubkey: program.publicKey,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId,\n        data\n      });\n      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {\n        commitment: 'confirmed'\n      }));\n\n      // Delay between sends in an attempt to reduce rate limit errors\n      if (_includesInstanceProperty(_context48 = connection._rpcEndpoint).call(_context48, 'solana.com')) {\n        const REQUESTS_PER_SECOND = 4;\n        await sleep(1000 / REQUESTS_PER_SECOND);\n      }\n      offset += chunkSize;\n      array = _sliceInstanceProperty(array).call(array, chunkSize);\n    }\n    await _Promise.all(transactions);\n\n    // Finalize the account loaded with program data for execution\n    {\n      const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')]);\n      const data = buffer.Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 1 // Finalize instruction\n      }, data);\n      const transaction = new Transaction().add({\n        keys: [{\n          pubkey: program.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId,\n        data\n      });\n      const deployCommitment = 'processed';\n      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {\n        preflightCommitment: deployCommitment\n      });\n      const {\n        context,\n        value\n      } = await connection.confirmTransaction({\n        signature: finalizeSignature,\n        lastValidBlockHeight: transaction.lastValidBlockHeight,\n        blockhash: transaction.recentBlockhash\n      }, deployCommitment);\n      if (value.err) {\n        throw new Error(`Transaction ${finalizeSignature} failed (${_JSON$stringify(value)})`);\n      }\n      // We prevent programs from being usable until the slot after their deployment.\n      // See https://github.com/solana-labs/solana/pull/29654\n      while (true // eslint-disable-line no-constant-condition\n      ) {\n        try {\n          const currentSlot = await connection.getSlot({\n            commitment: deployCommitment\n          });\n          if (currentSlot > context.slot) {\n            break;\n          }\n        } catch {\n          /* empty */\n        }\n        await new _Promise(resolve => _setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n      }\n    }\n\n    // success\n    return true;\n  }\n}\nLoader.chunkSize = CHUNK_SIZE;\n\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */\nconst BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');\n\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */\nclass BpfLoader {\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength) {\n    return Loader.getMinNumSignatures(dataLength);\n  }\n\n  /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static load(connection, payer, program, elf, loaderProgramId) {\n    return Loader.load(connection, payer, program, loaderProgramId, elf);\n  }\n}\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar agentkeepalive = {\n  exports: {}\n};\n\n/**\n * Helpers.\n */\n\nvar ms;\nvar hasRequiredMs;\nfunction requireMs() {\n  if (hasRequiredMs) return ms;\n  hasRequiredMs = 1;\n  var s = 1000;\n  var m = s * 60;\n  var h = m * 60;\n  var d = h * 24;\n  var w = d * 7;\n  var y = d * 365.25;\n\n  /**\n   * Parse or format the given `val`.\n   *\n   * Options:\n   *\n   *  - `long` verbose formatting [false]\n   *\n   * @param {String|Number} val\n   * @param {Object} [options]\n   * @throws {Error} throw an error if val is not a non-empty string or a number\n   * @return {String|Number}\n   * @api public\n   */\n\n  ms = function (val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === 'string' && val.length > 0) {\n      return parse(val);\n    } else if (type === 'number' && isFinite(val)) {\n      return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error('val is not a non-empty string or a valid number. val=' + _JSON$stringify(val));\n  };\n\n  /**\n   * Parse the given `str` and return milliseconds.\n   *\n   * @param {String} str\n   * @return {Number}\n   * @api private\n   */\n\n  function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n      return;\n    }\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n      return;\n    }\n    var n = _parseFloat(match[1]);\n    var type = (match[2] || 'ms').toLowerCase();\n    switch (type) {\n      case 'years':\n      case 'year':\n      case 'yrs':\n      case 'yr':\n      case 'y':\n        return n * y;\n      case 'weeks':\n      case 'week':\n      case 'w':\n        return n * w;\n      case 'days':\n      case 'day':\n      case 'd':\n        return n * d;\n      case 'hours':\n      case 'hour':\n      case 'hrs':\n      case 'hr':\n      case 'h':\n        return n * h;\n      case 'minutes':\n      case 'minute':\n      case 'mins':\n      case 'min':\n      case 'm':\n        return n * m;\n      case 'seconds':\n      case 'second':\n      case 'secs':\n      case 'sec':\n      case 's':\n        return n * s;\n      case 'milliseconds':\n      case 'millisecond':\n      case 'msecs':\n      case 'msec':\n      case 'ms':\n        return n;\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Short format for `ms`.\n   *\n   * @param {Number} ms\n   * @return {String}\n   * @api private\n   */\n\n  function fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n      return Math.round(ms / d) + 'd';\n    }\n    if (msAbs >= h) {\n      return Math.round(ms / h) + 'h';\n    }\n    if (msAbs >= m) {\n      return Math.round(ms / m) + 'm';\n    }\n    if (msAbs >= s) {\n      return Math.round(ms / s) + 's';\n    }\n    return ms + 'ms';\n  }\n\n  /**\n   * Long format for `ms`.\n   *\n   * @param {Number} ms\n   * @return {String}\n   * @api private\n   */\n\n  function fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n      return plural(ms, msAbs, d, 'day');\n    }\n    if (msAbs >= h) {\n      return plural(ms, msAbs, h, 'hour');\n    }\n    if (msAbs >= m) {\n      return plural(ms, msAbs, m, 'minute');\n    }\n    if (msAbs >= s) {\n      return plural(ms, msAbs, s, 'second');\n    }\n    return ms + ' ms';\n  }\n\n  /**\n   * Pluralization helper.\n   */\n\n  function plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n  }\n  return ms;\n}\n\n/*!\n * humanize-ms - index.js\n * Copyright(c) 2014 dead_horse <dead_horse@qq.com>\n * MIT Licensed\n */\n\nvar humanizeMs;\nvar hasRequiredHumanizeMs;\nfunction requireHumanizeMs() {\n  if (hasRequiredHumanizeMs) return humanizeMs;\n  hasRequiredHumanizeMs = 1;\n\n  /**\n   * Module dependencies.\n   */\n\n  var util = require$$0__default.default;\n  var ms = /*@__PURE__*/requireMs();\n  humanizeMs = function (t) {\n    if (typeof t === 'number') return t;\n    var r = ms(t);\n    if (r === undefined) {\n      var err = new Error(util.format('humanize-ms(%j) result undefined', t));\n      console.warn(err.stack);\n    }\n    return r;\n  };\n  return humanizeMs;\n}\nvar constants;\nvar hasRequiredConstants;\nfunction requireConstants() {\n  if (hasRequiredConstants) return constants;\n  hasRequiredConstants = 1;\n  constants = {\n    // agent\n    CURRENT_ID: _Symbol('agentkeepalive#currentId'),\n    CREATE_ID: _Symbol('agentkeepalive#createId'),\n    INIT_SOCKET: _Symbol('agentkeepalive#initSocket'),\n    CREATE_HTTPS_CONNECTION: _Symbol('agentkeepalive#createHttpsConnection'),\n    // socket\n    SOCKET_CREATED_TIME: _Symbol('agentkeepalive#socketCreatedTime'),\n    SOCKET_NAME: _Symbol('agentkeepalive#socketName'),\n    SOCKET_REQUEST_COUNT: _Symbol('agentkeepalive#socketRequestCount'),\n    SOCKET_REQUEST_FINISHED_COUNT: _Symbol('agentkeepalive#socketRequestFinishedCount')\n  };\n  return constants;\n}\nvar agent;\nvar hasRequiredAgent;\nfunction requireAgent() {\n  if (hasRequiredAgent) return agent;\n  hasRequiredAgent = 1;\n  const OriginalAgent = require$$0__default$1.default.Agent;\n  const ms = /*@__PURE__*/requireHumanizeMs();\n  const debug = require$$0__default.default.debuglog('agentkeepalive');\n  const {\n    INIT_SOCKET,\n    CURRENT_ID,\n    CREATE_ID,\n    SOCKET_CREATED_TIME,\n    SOCKET_NAME,\n    SOCKET_REQUEST_COUNT,\n    SOCKET_REQUEST_FINISHED_COUNT\n  } = /*@__PURE__*/requireConstants();\n\n  // OriginalAgent come from\n  // - https://github.com/nodejs/node/blob/v8.12.0/lib/_http_agent.js\n  // - https://github.com/nodejs/node/blob/v10.12.0/lib/_http_agent.js\n\n  // node <= 10\n  let defaultTimeoutListenerCount = 1;\n  const majorVersion = _parseInt(process.version.split('.', 1)[0].substring(1));\n  if (majorVersion >= 11 && majorVersion <= 12) {\n    defaultTimeoutListenerCount = 2;\n  } else if (majorVersion >= 13) {\n    defaultTimeoutListenerCount = 3;\n  }\n  function deprecate(message) {\n    console.log('[agentkeepalive:deprecated] %s', message);\n  }\n  class Agent extends OriginalAgent {\n    constructor(options) {\n      options = options || {};\n      options.keepAlive = options.keepAlive !== false;\n      // default is keep-alive and 4s free socket timeout\n      // see https://medium.com/ssense-tech/reduce-networking-errors-in-nodejs-23b4eb9f2d83\n      if (options.freeSocketTimeout === undefined) {\n        options.freeSocketTimeout = 4000;\n      }\n      // Legacy API: keepAliveTimeout should be rename to `freeSocketTimeout`\n      if (options.keepAliveTimeout) {\n        deprecate('options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');\n        options.freeSocketTimeout = options.keepAliveTimeout;\n        delete options.keepAliveTimeout;\n      }\n      // Legacy API: freeSocketKeepAliveTimeout should be rename to `freeSocketTimeout`\n      if (options.freeSocketKeepAliveTimeout) {\n        deprecate('options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead');\n        options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;\n        delete options.freeSocketKeepAliveTimeout;\n      }\n\n      // Sets the socket to timeout after timeout milliseconds of inactivity on the socket.\n      // By default is double free socket timeout.\n      if (options.timeout === undefined) {\n        // make sure socket default inactivity timeout >= 8s\n        options.timeout = Math.max(options.freeSocketTimeout * 2, 8000);\n      }\n\n      // support humanize format\n      options.timeout = ms(options.timeout);\n      options.freeSocketTimeout = ms(options.freeSocketTimeout);\n      options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;\n      super(options);\n      this[CURRENT_ID] = 0;\n\n      // create socket success counter\n      this.createSocketCount = 0;\n      this.createSocketCountLastCheck = 0;\n      this.createSocketErrorCount = 0;\n      this.createSocketErrorCountLastCheck = 0;\n      this.closeSocketCount = 0;\n      this.closeSocketCountLastCheck = 0;\n\n      // socket error event count\n      this.errorSocketCount = 0;\n      this.errorSocketCountLastCheck = 0;\n\n      // request finished counter\n      this.requestCount = 0;\n      this.requestCountLastCheck = 0;\n\n      // including free socket timeout counter\n      this.timeoutSocketCount = 0;\n      this.timeoutSocketCountLastCheck = 0;\n      this.on('free', socket => {\n        // https://github.com/nodejs/node/pull/32000\n        // Node.js native agent will check socket timeout eqs agent.options.timeout.\n        // Use the ttl or freeSocketTimeout to overwrite.\n        const timeout = this.calcSocketTimeout(socket);\n        if (timeout > 0 && socket.timeout !== timeout) {\n          socket.setTimeout(timeout);\n        }\n      });\n    }\n    get freeSocketKeepAliveTimeout() {\n      deprecate('agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead');\n      return this.options.freeSocketTimeout;\n    }\n    get timeout() {\n      deprecate('agent.timeout is deprecated, please use agent.options.timeout instead');\n      return this.options.timeout;\n    }\n    get socketActiveTTL() {\n      deprecate('agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead');\n      return this.options.socketActiveTTL;\n    }\n    calcSocketTimeout(socket) {\n      /**\n       * return <= 0: should free socket\n       * return > 0: should update socket timeout\n       * return undefined: not find custom timeout\n       */\n      let freeSocketTimeout = this.options.freeSocketTimeout;\n      const socketActiveTTL = this.options.socketActiveTTL;\n      if (socketActiveTTL) {\n        // check socketActiveTTL\n        const aliveTime = _Date$now() - socket[SOCKET_CREATED_TIME];\n        const diff = socketActiveTTL - aliveTime;\n        if (diff <= 0) {\n          return diff;\n        }\n        if (freeSocketTimeout && diff < freeSocketTimeout) {\n          freeSocketTimeout = diff;\n        }\n      }\n      // set freeSocketTimeout\n      if (freeSocketTimeout) {\n        // set free keepalive timer\n        // try to use socket custom freeSocketTimeout first, support headers['keep-alive']\n        // https://github.com/node-modules/urllib/blob/b76053020923f4d99a1c93cf2e16e0c5ba10bacf/lib/urllib.js#L498\n        const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;\n        return customFreeSocketTimeout || freeSocketTimeout;\n      }\n    }\n    keepSocketAlive(socket) {\n      const result = super.keepSocketAlive(socket);\n      // should not keepAlive, do nothing\n      if (!result) return result;\n      const customTimeout = this.calcSocketTimeout(socket);\n      if (typeof customTimeout === 'undefined') {\n        return true;\n      }\n      if (customTimeout <= 0) {\n        debug('%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], customTimeout);\n        return false;\n      }\n      if (socket.timeout !== customTimeout) {\n        socket.setTimeout(customTimeout);\n      }\n      return true;\n    }\n\n    // only call on addRequest\n    reuseSocket(...args) {\n      // reuseSocket(socket, req)\n      super.reuseSocket(...args);\n      const socket = args[0];\n      const req = args[1];\n      req.reusedSocket = true;\n      const agentTimeout = this.options.timeout;\n      if (getSocketTimeout(socket) !== agentTimeout) {\n        // reset timeout before use\n        socket.setTimeout(agentTimeout);\n        debug('%s reset timeout to %sms', socket[SOCKET_NAME], agentTimeout);\n      }\n      socket[SOCKET_REQUEST_COUNT]++;\n      debug('%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], getSocketTimeout(socket));\n    }\n    [CREATE_ID]() {\n      const id = this[CURRENT_ID]++;\n      if (this[CURRENT_ID] === _Number$MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;\n      return id;\n    }\n    [INIT_SOCKET](socket, options) {\n      // bugfix here.\n      // https on node 8, 10 won't set agent.options.timeout by default\n      // TODO: need to fix on node itself\n      if (options.timeout) {\n        const timeout = getSocketTimeout(socket);\n        if (!timeout) {\n          socket.setTimeout(options.timeout);\n        }\n      }\n      if (this.options.keepAlive) {\n        // Disable Nagle's algorithm: http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/\n        // https://fengmk2.com/benchmark/nagle-algorithm-delayed-ack-mock.html\n        socket.setNoDelay(true);\n      }\n      this.createSocketCount++;\n      if (this.options.socketActiveTTL) {\n        socket[SOCKET_CREATED_TIME] = _Date$now();\n      }\n      // don't show the hole '-----BEGIN CERTIFICATE----' key string\n      socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split('-----BEGIN', 1)[0];\n      socket[SOCKET_REQUEST_COUNT] = 1;\n      socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;\n      installListeners(this, socket, options);\n    }\n    createConnection(options, oncreate) {\n      let called = false;\n      const onNewCreate = (err, socket) => {\n        if (called) return;\n        called = true;\n        if (err) {\n          this.createSocketErrorCount++;\n          return oncreate(err);\n        }\n        this[INIT_SOCKET](socket, options);\n        oncreate(err, socket);\n      };\n      const newSocket = super.createConnection(options, onNewCreate);\n      if (newSocket) onNewCreate(null, newSocket);\n      return newSocket;\n    }\n    get statusChanged() {\n      const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;\n      if (changed) {\n        this.createSocketCountLastCheck = this.createSocketCount;\n        this.createSocketErrorCountLastCheck = this.createSocketErrorCount;\n        this.closeSocketCountLastCheck = this.closeSocketCount;\n        this.errorSocketCountLastCheck = this.errorSocketCount;\n        this.timeoutSocketCountLastCheck = this.timeoutSocketCount;\n        this.requestCountLastCheck = this.requestCount;\n      }\n      return changed;\n    }\n    getCurrentStatus() {\n      return {\n        createSocketCount: this.createSocketCount,\n        createSocketErrorCount: this.createSocketErrorCount,\n        closeSocketCount: this.closeSocketCount,\n        errorSocketCount: this.errorSocketCount,\n        timeoutSocketCount: this.timeoutSocketCount,\n        requestCount: this.requestCount,\n        freeSockets: inspect(this.freeSockets),\n        sockets: inspect(this.sockets),\n        requests: inspect(this.requests)\n      };\n    }\n  }\n\n  // node 8 don't has timeout attribute on socket\n  // https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\n  function getSocketTimeout(socket) {\n    return socket.timeout || socket._idleTimeout;\n  }\n  function installListeners(agent, socket, options) {\n    debug('%s create, timeout %sms', socket[SOCKET_NAME], getSocketTimeout(socket));\n\n    // listener socket events: close, timeout, error, free\n    function onFree() {\n      // create and socket.emit('free') logic\n      // https://github.com/nodejs/node/blob/master/lib/_http_agent.js#L311\n      // no req on the socket, it should be the new socket\n      if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;\n      socket[SOCKET_REQUEST_FINISHED_COUNT]++;\n      agent.requestCount++;\n      debug('%s(requests: %s, finished: %s) free', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n\n      // should reuse on pedding requests?\n      const name = agent.getName(options);\n      if (socket.writable && agent.requests[name] && agent.requests[name].length) {\n        // will be reuse on agent free listener\n        socket[SOCKET_REQUEST_COUNT]++;\n        debug('%s(requests: %s, finished: %s) will be reuse on agent free event', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n      }\n    }\n    socket.on('free', onFree);\n    function onClose(isError) {\n      debug('%s(requests: %s, finished: %s) close, isError: %s', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], isError);\n      agent.closeSocketCount++;\n    }\n    socket.on('close', onClose);\n\n    // start socket timeout handler\n    function onTimeout() {\n      var _context50;\n      // onTimeout and emitRequestTimeout(_http_client.js)\n      // https://github.com/nodejs/node/blob/v12.x/lib/_http_client.js#L711\n      const listenerCount = socket.listeners('timeout').length;\n      // node <= 10, default listenerCount is 1, onTimeout\n      // 11 < node <= 12, default listenerCount is 2, onTimeout and emitRequestTimeout\n      // node >= 13, default listenerCount is 3, onTimeout,\n      //   onTimeout(https://github.com/nodejs/node/pull/32000/files#diff-5f7fb0850412c6be189faeddea6c5359R333)\n      //   and emitRequestTimeout\n      const timeout = getSocketTimeout(socket);\n      const req = socket._httpMessage;\n      const reqTimeoutListenerCount = req && req.listeners('timeout').length || 0;\n      debug('%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], timeout, listenerCount, defaultTimeoutListenerCount, !!req, reqTimeoutListenerCount);\n      if (debug.enabled) {\n        var _context49;\n        debug('timeout listeners: %s', _mapInstanceProperty(_context49 = socket.listeners('timeout')).call(_context49, f => f.name).join(', '));\n      }\n      agent.timeoutSocketCount++;\n      const name = agent.getName(options);\n      if (agent.freeSockets[name] && _indexOfInstanceProperty(_context50 = agent.freeSockets[name]).call(_context50, socket) !== -1) {\n        // free socket timeout, destroy quietly\n        socket.destroy();\n        // Remove it from freeSockets list immediately to prevent new requests\n        // from being sent through this socket.\n        agent.removeSocket(socket, options);\n        debug('%s is free, destroy quietly', socket[SOCKET_NAME]);\n      } else {\n        // if there is no any request socket timeout handler,\n        // agent need to handle socket timeout itself.\n        //\n        // custom request socket timeout handle logic must follow these rules:\n        //  1. Destroy socket first\n        //  2. Must emit socket 'agentRemove' event tell agent remove socket\n        //     from freeSockets list immediately.\n        //     Otherise you may be get 'socket hang up' error when reuse\n        //     free socket and timeout happen in the same time.\n        if (reqTimeoutListenerCount === 0) {\n          const error = new Error('Socket timeout');\n          error.code = 'ERR_SOCKET_TIMEOUT';\n          error.timeout = timeout;\n          // must manually call socket.end() or socket.destroy() to end the connection.\n          // https://nodejs.org/dist/latest-v10.x/docs/api/net.html#net_socket_settimeout_timeout_callback\n          socket.destroy(error);\n          agent.removeSocket(socket, options);\n          debug('%s destroy with timeout error', socket[SOCKET_NAME]);\n        }\n      }\n    }\n    socket.on('timeout', onTimeout);\n    function onError(err) {\n      const listenerCount = socket.listeners('error').length;\n      debug('%s(requests: %s, finished: %s) error: %s, listenerCount: %s', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT], err, listenerCount);\n      agent.errorSocketCount++;\n      if (listenerCount === 1) {\n        // if socket don't contain error event handler, don't catch it, emit it again\n        debug('%s emit uncaught error event', socket[SOCKET_NAME]);\n        socket.removeListener('error', onError);\n        socket.emit('error', err);\n      }\n    }\n    socket.on('error', onError);\n    function onRemove() {\n      debug('%s(requests: %s, finished: %s) agentRemove', socket[SOCKET_NAME], socket[SOCKET_REQUEST_COUNT], socket[SOCKET_REQUEST_FINISHED_COUNT]);\n      // We need this function for cases like HTTP 'upgrade'\n      // (defined by WebSockets) where we need to remove a socket from the\n      // pool because it'll be locked up indefinitely\n      socket.removeListener('close', onClose);\n      socket.removeListener('error', onError);\n      socket.removeListener('free', onFree);\n      socket.removeListener('timeout', onTimeout);\n      socket.removeListener('agentRemove', onRemove);\n    }\n    socket.on('agentRemove', onRemove);\n  }\n  agent = Agent;\n  function inspect(obj) {\n    const res = {};\n    for (const key in obj) {\n      res[key] = obj[key].length;\n    }\n    return res;\n  }\n  return agent;\n}\nvar https_agent;\nvar hasRequiredHttps_agent;\nfunction requireHttps_agent() {\n  var _context51;\n  if (hasRequiredHttps_agent) return https_agent;\n  hasRequiredHttps_agent = 1;\n  const OriginalHttpsAgent = require$$0__default$2.default.Agent;\n  const HttpAgent = /*@__PURE__*/requireAgent();\n  const {\n    INIT_SOCKET,\n    CREATE_HTTPS_CONNECTION\n  } = /*@__PURE__*/requireConstants();\n  class HttpsAgent extends HttpAgent {\n    constructor(options) {\n      super(options);\n      this.defaultPort = 443;\n      this.protocol = 'https:';\n      this.maxCachedSessions = this.options.maxCachedSessions;\n      /* istanbul ignore next */\n      if (this.maxCachedSessions === undefined) {\n        this.maxCachedSessions = 100;\n      }\n      this._sessionCache = {\n        map: {},\n        list: []\n      };\n    }\n    createConnection(options, oncreate) {\n      const socket = this[CREATE_HTTPS_CONNECTION](options, oncreate);\n      this[INIT_SOCKET](socket, options);\n      return socket;\n    }\n  }\n\n  // https://github.com/nodejs/node/blob/master/lib/https.js#L89\n  HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;\n  _forEachInstanceProperty(_context51 = ['getName', '_getSession', '_cacheSession',\n  // https://github.com/nodejs/node/pull/4982\n  '_evictSession']).call(_context51, function (method) {\n    /* istanbul ignore next */\n    if (typeof OriginalHttpsAgent.prototype[method] === 'function') {\n      HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];\n    }\n  });\n  https_agent = HttpsAgent;\n  return https_agent;\n}\nvar hasRequiredAgentkeepalive;\nfunction requireAgentkeepalive() {\n  if (hasRequiredAgentkeepalive) return agentkeepalive.exports;\n  hasRequiredAgentkeepalive = 1;\n  agentkeepalive.exports = /*@__PURE__*/requireAgent();\n  agentkeepalive.exports.HttpsAgent = /*@__PURE__*/requireHttps_agent();\n  agentkeepalive.exports.constants = /*@__PURE__*/requireConstants();\n  return agentkeepalive.exports;\n}\nvar agentkeepaliveExports = /*@__PURE__*/requireAgentkeepalive();\nvar HttpKeepAliveAgent = /*@__PURE__*/getDefaultExportFromCjs(agentkeepaliveExports);\nvar fastStableStringify$1;\nvar hasRequiredFastStableStringify;\nfunction requireFastStableStringify() {\n  if (hasRequiredFastStableStringify) return fastStableStringify$1;\n  hasRequiredFastStableStringify = 1;\n  var objToString = Object.prototype.toString;\n  var objKeys = _Object$keys || function (obj) {\n    var keys = [];\n    for (var name in obj) {\n      keys.push(name);\n    }\n    return keys;\n  };\n  function stringify(val, isArrayProp) {\n    var i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n      return \"true\";\n    }\n    if (val === false) {\n      return \"false\";\n    }\n    switch (typeof val) {\n      case \"object\":\n        if (val === null) {\n          return null;\n        } else if (val.toJSON && typeof val.toJSON === \"function\") {\n          return stringify(val.toJSON(), isArrayProp);\n        } else {\n          toStr = objToString.call(val);\n          if (toStr === \"[object Array]\") {\n            str = '[';\n            max = val.length - 1;\n            for (i = 0; i < max; i++) {\n              str += stringify(val[i], true) + ',';\n            }\n            if (max > -1) {\n              str += stringify(val[i], true);\n            }\n            return str + ']';\n          } else if (toStr === \"[object Object]\") {\n            var _context52;\n            // only object is left\n            keys = _sortInstanceProperty(_context52 = objKeys(val)).call(_context52);\n            max = keys.length;\n            str = \"\";\n            i = 0;\n            while (i < max) {\n              key = keys[i];\n              propVal = stringify(val[key], false);\n              if (propVal !== undefined) {\n                if (str) {\n                  str += ',';\n                }\n                str += _JSON$stringify(key) + ':' + propVal;\n              }\n              i++;\n            }\n            return '{' + str + '}';\n          } else {\n            return _JSON$stringify(val);\n          }\n        }\n      case \"function\":\n      case \"undefined\":\n        return isArrayProp ? null : undefined;\n      case \"string\":\n        return _JSON$stringify(val);\n      default:\n        return isFinite(val) ? val : null;\n    }\n  }\n  fastStableStringify$1 = function (val) {\n    var returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n      return '' + returnVal;\n    }\n  };\n  return fastStableStringify$1;\n}\nvar fastStableStringifyExports = /*@__PURE__*/requireFastStableStringify();\nvar fastStableStringify = /*@__PURE__*/getDefaultExportFromCjs(fastStableStringifyExports);\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n  let trailingZeros = 0;\n  while (n > 1) {\n    n /= 2;\n    trailingZeros++;\n  }\n  return trailingZeros;\n}\n\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n  if (n === 0) return 1;\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  return n + 1;\n}\n\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */\nclass EpochSchedule {\n  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {\n    /** The maximum number of slots in each epoch */\n    this.slotsPerEpoch = void 0;\n    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */\n    this.leaderScheduleSlotOffset = void 0;\n    /** Indicates whether epochs start short and grow */\n    this.warmup = void 0;\n    /** The first epoch with `slotsPerEpoch` slots */\n    this.firstNormalEpoch = void 0;\n    /** The first slot of `firstNormalEpoch` */\n    this.firstNormalSlot = void 0;\n    this.slotsPerEpoch = slotsPerEpoch;\n    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n    this.warmup = warmup;\n    this.firstNormalEpoch = firstNormalEpoch;\n    this.firstNormalSlot = firstNormalSlot;\n  }\n  getEpoch(slot) {\n    return this.getEpochAndSlotIndex(slot)[0];\n  }\n  getEpochAndSlotIndex(slot) {\n    if (slot < this.firstNormalSlot) {\n      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n      const epochLen = this.getSlotsInEpoch(epoch);\n      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n      return [epoch, slotIndex];\n    } else {\n      const normalSlotIndex = slot - this.firstNormalSlot;\n      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n      const epoch = this.firstNormalEpoch + normalEpochIndex;\n      const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n      return [epoch, slotIndex];\n    }\n  }\n  getFirstSlotInEpoch(epoch) {\n    if (epoch <= this.firstNormalEpoch) {\n      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n    } else {\n      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n    }\n  }\n  getLastSlotInEpoch(epoch) {\n    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n  }\n  getSlotsInEpoch(epoch) {\n    if (epoch < this.firstNormalEpoch) {\n      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n    } else {\n      return this.slotsPerEpoch;\n    }\n  }\n}\nvar fetchImpl = typeof _globalThis.fetch === 'function' ?\n// The Fetch API is supported experimentally in Node 17.5+ and natively in Node 18+.\n_globalThis.fetch :\n// Otherwise use the polyfill.\nasync function (input, init) {\n  const processedInput = typeof input === 'string' && _sliceInstanceProperty(input).call(input, 0, 2) === '//' ? 'https:' + input : input;\n  return await nodeFetch__namespace.default(processedInput, init);\n};\nclass RpcWebSocketClient extends rpcWebsockets.CommonClient {\n  constructor(address, options, generate_request_id) {\n    const webSocketFactory = url => {\n      const rpc = rpcWebsockets.WebSocket(url, _objectSpread({\n        autoconnect: true,\n        max_reconnects: 5,\n        reconnect: true,\n        reconnect_interval: 1000\n      }, options));\n      if ('socket' in rpc) {\n        this.underlyingSocket = rpc.socket;\n      } else {\n        this.underlyingSocket = rpc;\n      }\n      return rpc;\n    };\n    super(webSocketFactory, address, options, generate_request_id);\n    this.underlyingSocket = void 0;\n  }\n  call(...args) {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.call(...args);\n    }\n    return _Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n  }\n  notify(...args) {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.notify(...args);\n    }\n    return _Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n  }\n}\n\n/**\n * @internal\n */\n\n/**\n * Decode account data buffer using an AccountType\n * @internal\n */\nfunction decodeData(type, data) {\n  let decoded;\n  try {\n    decoded = type.layout.decode(data);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (decoded.typeIndex !== type.index) {\n    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n  }\n  return decoded;\n}\n\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n  constructor(args) {\n    this.key = void 0;\n    this.state = void 0;\n    this.key = args.key;\n    this.state = args.state;\n  }\n  isActive() {\n    const U64_MAX = BigInt('0xffffffffffffffff');\n    return this.state.deactivationSlot === U64_MAX;\n  }\n  static deserialize(accountData) {\n    const meta = decodeData(LookupTableMetaLayout, accountData);\n    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n    assert(serializedAddressesLen >= 0, 'lookup table is invalid');\n    assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');\n    const numSerializedAddresses = serializedAddressesLen / 32;\n    const {\n      addresses\n    } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(_sliceInstanceProperty(accountData).call(accountData, LOOKUP_TABLE_META_SIZE));\n    return {\n      deactivationSlot: meta.deactivationSlot,\n      lastExtendedSlot: meta.lastExtendedSlot,\n      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n      addresses: _mapInstanceProperty(addresses).call(addresses, address => new PublicKey(address))\n    };\n  }\n}\nconst LookupTableMetaLayout = {\n  index: 1,\n  layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('typeIndex'), u64('deactivationSlot'), BufferLayout__namespace.nu64('lastExtendedSlot'), BufferLayout__namespace.u8('lastExtendedStartIndex'), BufferLayout__namespace.u8(),\n  // option\n  BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), 'authority')])\n};\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n  const matches = endpoint.match(URL_RE);\n  if (matches == null) {\n    throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n  }\n  const [_,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  hostish, portWithColon, rest] = matches;\n  const protocol = _startsWithInstanceProperty(endpoint).call(endpoint, 'https:') ? 'wss:' : 'ws:';\n  const startPort = portWithColon == null ? null : _parseInt(_sliceInstanceProperty(portWithColon).call(portWithColon, 1), 10);\n  const websocketPort =\n  // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n  // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n  // we're directly trying to connect to agave-validator's ws listening port.\n  // When the endpoint omits the port, we're connecting to the protocol\n  // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n  // proxy which manages WebSocket upgrade and backend port redirection.\n  startPort == null ? '' : `:${startPort + 1}`;\n  return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\nconst PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey), superstruct.string(), value => new PublicKey(value));\nconst RawAccountDataResult = superstruct.tuple([superstruct.string(), superstruct.literal('base64')]);\nconst BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, value => buffer.Buffer.from(value[0], 'base64'));\n\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */\nconst BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */\n\n/** @internal */\n/** @internal */\n/** @internal */\n/** @internal */\n\n/** @internal */\n/**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */\n\n/**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */\n\n/**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */\n\n/**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */\n\n/**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */\n\n/**\n * @internal\n */\n\n/**\n * Extra contextual information for RPC responses\n */\n\n/**\n * Options for sending transactions\n */\n\n/**\n * Options for confirming transactions\n */\n\n/**\n * Options for getConfirmedSignaturesForAddress2\n */\n\n/**\n * Options for getSignaturesForAddress\n */\n\n/**\n * RPC Response with extra contextual information\n */\n\n/**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */\n\n/**\n * A strategy for confirming durable nonce transactions.\n */\n\n/**\n * Properties shared by all transaction confirmation strategies\n */\n\n/**\n * This type represents all transaction confirmation strategies\n */\n\n/* @internal */\nfunction assertEndpointUrl(putativeUrl) {\n  if (/^https?:/.test(putativeUrl) === false) {\n    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');\n  }\n  return putativeUrl;\n}\n\n/** @internal */\nfunction extractCommitmentFromConfig(commitmentOrConfig) {\n  let commitment;\n  let config;\n  if (typeof commitmentOrConfig === 'string') {\n    commitment = commitmentOrConfig;\n  } else if (commitmentOrConfig) {\n    const {\n        commitment: specifiedCommitment\n      } = commitmentOrConfig,\n      specifiedConfig = _objectWithoutProperties(commitmentOrConfig, _excluded);\n    commitment = specifiedCommitment;\n    config = specifiedConfig;\n  }\n  return {\n    commitment,\n    config\n  };\n}\n\n/**\n * @internal\n */\nfunction applyDefaultMemcmpEncodingToFilters(filters) {\n  return _mapInstanceProperty(filters).call(filters, filter => 'memcmp' in filter ? _objectSpread(_objectSpread({}, filter), {}, {\n    memcmp: _objectSpread(_objectSpread({}, filter.memcmp), {}, {\n      encoding: filter.memcmp.encoding ?? 'base58'\n    })\n  }) : filter);\n}\n\n/**\n * @internal\n */\nfunction createRpcResult(result) {\n  return superstruct.union([superstruct.type({\n    jsonrpc: superstruct.literal('2.0'),\n    id: superstruct.string(),\n    result\n  }), superstruct.type({\n    jsonrpc: superstruct.literal('2.0'),\n    id: superstruct.string(),\n    error: superstruct.type({\n      code: superstruct.unknown(),\n      message: superstruct.string(),\n      data: superstruct.optional(superstruct.any())\n    })\n  })]);\n}\nconst UnknownRpcResult = createRpcResult(superstruct.unknown());\n\n/**\n * @internal\n */\nfunction jsonRpcResult(schema) {\n  return superstruct.coerce(createRpcResult(schema), UnknownRpcResult, value => {\n    if ('error' in value) {\n      return value;\n    } else {\n      return _objectSpread(_objectSpread({}, value), {}, {\n        result: superstruct.create(value.result, schema)\n      });\n    }\n  });\n}\n\n/**\n * @internal\n */\nfunction jsonRpcResultAndContext(value) {\n  return jsonRpcResult(superstruct.type({\n    context: superstruct.type({\n      slot: superstruct.number()\n    }),\n    value\n  }));\n}\n\n/**\n * @internal\n */\nfunction notificationResultAndContext(value) {\n  return superstruct.type({\n    context: superstruct.type({\n      slot: superstruct.number()\n    }),\n    value\n  });\n}\n\n/**\n * @internal\n */\nfunction versionedMessageFromResponse(version, response) {\n  if (version === 0) {\n    var _context53, _context54;\n    return new MessageV0({\n      header: response.header,\n      staticAccountKeys: _mapInstanceProperty(_context53 = response.accountKeys).call(_context53, accountKey => new PublicKey(accountKey)),\n      recentBlockhash: response.recentBlockhash,\n      compiledInstructions: _mapInstanceProperty(_context54 = response.instructions).call(_context54, ix => ({\n        programIdIndex: ix.programIdIndex,\n        accountKeyIndexes: ix.accounts,\n        data: bs58__default.default.decode(ix.data)\n      })),\n      addressTableLookups: response.addressTableLookups\n    });\n  } else {\n    return new Message(response);\n  }\n}\n\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n// Deprecated as of v1.5.5\n\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n/**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */\n\n/**\n * Configuration object for changing `getAccountInfo` query behavior\n */\n\n/**\n * Configuration object for changing `getBalance` query behavior\n */\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n\n/**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */\n\n/**\n * Configuration object for changing `getBlockHeight` query behavior\n */\n\n/**\n * Configuration object for changing `getEpochInfo` query behavior\n */\n\n/**\n * Configuration object for changing `getInflationReward` query behavior\n */\n\n/**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */\n\n/**\n * Configuration object for changing `isBlockhashValid` query behavior\n */\n\n/**\n * Configuration object for changing `getSlot` query behavior\n */\n\n/**\n * Configuration object for changing `getSlotLeader` query behavior\n */\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n\n/**\n * Configuration object for changing `getLargestAccounts` query behavior\n */\n\n/**\n * Configuration object for changing `getSupply` request behavior\n */\n\n/**\n * Configuration object for changing query behavior\n */\n\n/**\n * Information describing a cluster node\n */\n\n/**\n * Information describing a vote account\n */\n\n/**\n * A collection of cluster vote accounts\n */\n\n/**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */\n\nconst GetInflationGovernorResult = superstruct.type({\n  foundation: superstruct.number(),\n  foundationTerm: superstruct.number(),\n  initial: superstruct.number(),\n  taper: superstruct.number(),\n  terminal: superstruct.number()\n});\n\n/**\n * The inflation reward for an epoch\n */\n\n/**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */\nconst GetInflationRewardResult = jsonRpcResult(superstruct.array(superstruct.nullable(superstruct.type({\n  epoch: superstruct.number(),\n  effectiveSlot: superstruct.number(),\n  amount: superstruct.number(),\n  postBalance: superstruct.number(),\n  commission: superstruct.optional(superstruct.nullable(superstruct.number()))\n}))));\n\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesResult = superstruct.array(superstruct.type({\n  slot: superstruct.number(),\n  prioritizationFee: superstruct.number()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateResult = superstruct.type({\n  total: superstruct.number(),\n  validator: superstruct.number(),\n  foundation: superstruct.number(),\n  epoch: superstruct.number()\n});\n\n/**\n * Information about the current epoch\n */\n\nconst GetEpochInfoResult = superstruct.type({\n  epoch: superstruct.number(),\n  slotIndex: superstruct.number(),\n  slotsInEpoch: superstruct.number(),\n  absoluteSlot: superstruct.number(),\n  blockHeight: superstruct.optional(superstruct.number()),\n  transactionCount: superstruct.optional(superstruct.number())\n});\nconst GetEpochScheduleResult = superstruct.type({\n  slotsPerEpoch: superstruct.number(),\n  leaderScheduleSlotOffset: superstruct.number(),\n  warmup: superstruct.boolean(),\n  firstNormalEpoch: superstruct.number(),\n  firstNormalSlot: superstruct.number()\n});\n\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */\n\nconst GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));\n\n/**\n * Transaction error or null\n */\nconst TransactionErrorResult = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));\n\n/**\n * Signature status for a transaction\n */\nconst SignatureStatusResult = superstruct.type({\n  err: TransactionErrorResult\n});\n\n/**\n * Transaction signature received notification\n */\nconst SignatureReceivedResult = superstruct.literal('receivedSignature');\n\n/**\n * Version info for a node\n */\n\nconst VersionResult = superstruct.type({\n  'solana-core': superstruct.string(),\n  'feature-set': superstruct.optional(superstruct.number())\n});\nconst ParsedInstructionStruct = superstruct.type({\n  program: superstruct.string(),\n  programId: PublicKeyFromString,\n  parsed: superstruct.unknown()\n});\nconst PartiallyDecodedInstructionStruct = superstruct.type({\n  programId: PublicKeyFromString,\n  accounts: superstruct.array(PublicKeyFromString),\n  data: superstruct.string()\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext(superstruct.type({\n  err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),\n  logs: superstruct.nullable(superstruct.array(superstruct.string())),\n  accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({\n    executable: superstruct.boolean(),\n    owner: superstruct.string(),\n    lamports: superstruct.number(),\n    data: superstruct.array(superstruct.string()),\n    rentEpoch: superstruct.optional(superstruct.number())\n  }))))),\n  unitsConsumed: superstruct.optional(superstruct.number()),\n  returnData: superstruct.optional(superstruct.nullable(superstruct.type({\n    programId: superstruct.string(),\n    data: superstruct.tuple([superstruct.string(), superstruct.literal('base64')])\n  }))),\n  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n    index: superstruct.number(),\n    instructions: superstruct.array(superstruct.union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))\n  }))))\n}));\n\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */\n\n/**\n * Collection of addresses loaded by a transaction using address table lookups\n */\n\n/**\n * Metadata for a parsed transaction on the ledger\n */\n\n/**\n * Metadata for a confirmed transaction on the ledger\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction message from the RPC API\n */\n\n/**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */\n\n/**\n * A partially decoded transaction instruction\n */\n\n/**\n * A parsed transaction message account\n */\n\n/**\n * A parsed transaction instruction\n */\n\n/**\n * A parsed address table lookup\n */\n\n/**\n * A parsed transaction message\n */\n\n/**\n * A parsed transaction\n */\n\n/**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */\n\n/**\n * A parsed transaction on the ledger with meta\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A block with parsed transactions\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since RPC v1.8.0.\n */\n\n/**\n * A Block on the ledger with signatures only\n */\n\n/**\n * recent block production information\n */\n\n/**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */\nconst BlockProductionResponseStruct = jsonRpcResultAndContext(superstruct.type({\n  byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),\n  range: superstruct.type({\n    firstSlot: superstruct.number(),\n    lastSlot: superstruct.number()\n  })\n}));\n\n/**\n * A performance sample\n */\n\nfunction createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n  const fetch = customFetch ? customFetch : fetchImpl;\n  let agent;\n  {\n    if (httpAgent == null) {\n      {\n        const agentOptions = {\n          // One second fewer than the Solana RPC's keepalive timeout.\n          // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889\n          freeSocketTimeout: 19000,\n          keepAlive: true,\n          maxSockets: 25\n        };\n        if (_startsWithInstanceProperty(url).call(url, 'https:')) {\n          agent = new agentkeepaliveExports.HttpsAgent(agentOptions);\n        } else {\n          agent = new HttpKeepAliveAgent(agentOptions);\n        }\n      }\n    } else {\n      if (httpAgent !== false) {\n        const isHttps = _startsWithInstanceProperty(url).call(url, 'https:');\n        if (isHttps && !(httpAgent instanceof require$$0$2.Agent)) {\n          throw new Error('The endpoint `' + url + '` can only be paired with an `https.Agent`. You have, instead, supplied an ' + '`http.Agent` through `httpAgent`.');\n        } else if (!isHttps && httpAgent instanceof require$$0$2.Agent) {\n          throw new Error('The endpoint `' + url + '` can only be paired with an `http.Agent`. You have, instead, supplied an ' + '`https.Agent` through `httpAgent`.');\n        }\n        agent = httpAgent;\n      }\n    }\n  }\n  let fetchWithMiddleware;\n  if (fetchMiddleware) {\n    fetchWithMiddleware = async (info, init) => {\n      const modifiedFetchArgs = await new _Promise((resolve, reject) => {\n        try {\n          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));\n        } catch (error) {\n          reject(error);\n        }\n      });\n      return await fetch(...modifiedFetchArgs);\n    };\n  }\n  const clientBrowser = new RpcClient__default.default(async (request, callback) => {\n    const options = {\n      method: 'POST',\n      body: request,\n      agent,\n      headers: _Object$assign({\n        'Content-Type': 'application/json'\n      }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n    };\n    try {\n      let too_many_requests_retries = 5;\n      let res;\n      let waitTime = 500;\n      for (;;) {\n        if (fetchWithMiddleware) {\n          res = await fetchWithMiddleware(url, options);\n        } else {\n          res = await fetch(url, options);\n        }\n        if (res.status !== 429 /* Too many requests */) {\n          break;\n        }\n        if (disableRetryOnRateLimit === true) {\n          break;\n        }\n        too_many_requests_retries -= 1;\n        if (too_many_requests_retries === 0) {\n          break;\n        }\n        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n        await sleep(waitTime);\n        waitTime *= 2;\n      }\n      const text = await res.text();\n      if (res.ok) {\n        callback(null, text);\n      } else {\n        callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n      }\n    } catch (err) {\n      if (err instanceof Error) callback(err);\n    }\n  }, {});\n  return clientBrowser;\n}\nfunction createRpcRequest(client) {\n  return (method, args) => {\n    return new _Promise((resolve, reject) => {\n      client.request(method, args, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\nfunction createRpcBatchRequest(client) {\n  return requests => {\n    return new _Promise((resolve, reject) => {\n      // Do nothing if requests is empty\n      if (requests.length === 0) resolve([]);\n      const batch = _mapInstanceProperty(requests).call(requests, params => {\n        return client.request(params.methodName, params.args);\n      });\n      client.request(batch, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */\nconst GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\nconst GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\nconst GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */\nconst GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */\nconst SlotRpcResult = jsonRpcResult(superstruct.number());\n\n/**\n * Supply\n */\n\n/**\n * Expected JSON RPC response for the \"getSupply\" message\n */\nconst GetSupplyRpcResult = jsonRpcResultAndContext(superstruct.type({\n  total: superstruct.number(),\n  circulating: superstruct.number(),\n  nonCirculating: superstruct.number(),\n  nonCirculatingAccounts: superstruct.array(PublicKeyFromString)\n}));\n\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */\n\n/**\n * Expected JSON RPC structure for token amounts\n */\nconst TokenAmountResult = superstruct.type({\n  amount: superstruct.string(),\n  uiAmount: superstruct.nullable(superstruct.number()),\n  decimals: superstruct.number(),\n  uiAmountString: superstruct.optional(superstruct.string())\n});\n\n/**\n * Token address and balance.\n */\n\n/**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */\nconst GetTokenLargestAccountsResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  address: PublicKeyFromString,\n  amount: superstruct.string(),\n  uiAmount: superstruct.nullable(superstruct.number()),\n  decimals: superstruct.number(),\n  uiAmountString: superstruct.optional(superstruct.string())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */\nconst GetTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: superstruct.type({\n    executable: superstruct.boolean(),\n    owner: PublicKeyFromString,\n    lamports: superstruct.number(),\n    data: BufferFromRawAccountData,\n    rentEpoch: superstruct.number()\n  })\n})));\nconst ParsedAccountDataResult = superstruct.type({\n  program: superstruct.string(),\n  parsed: superstruct.unknown(),\n  space: superstruct.number()\n});\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */\nconst GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: superstruct.type({\n    executable: superstruct.boolean(),\n    owner: PublicKeyFromString,\n    lamports: superstruct.number(),\n    data: ParsedAccountDataResult,\n    rentEpoch: superstruct.number()\n  })\n})));\n\n/**\n * Pair of an account address and its balance\n */\n\n/**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */\nconst GetLargestAccountsRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.type({\n  lamports: superstruct.number(),\n  address: PublicKeyFromString\n})));\n\n/**\n * @internal\n */\nconst AccountInfoResult = superstruct.type({\n  executable: superstruct.boolean(),\n  owner: PublicKeyFromString,\n  lamports: superstruct.number(),\n  data: BufferFromRawAccountData,\n  rentEpoch: superstruct.number()\n});\n\n/**\n * @internal\n */\nconst KeyedAccountInfoResult = superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult]), superstruct.union([RawAccountDataResult, ParsedAccountDataResult]), value => {\n  if (_Array$isArray(value)) {\n    return superstruct.create(value, BufferFromRawAccountData);\n  } else {\n    return value;\n  }\n});\n\n/**\n * @internal\n */\nconst ParsedAccountInfoResult = superstruct.type({\n  executable: superstruct.boolean(),\n  owner: PublicKeyFromString,\n  lamports: superstruct.number(),\n  data: ParsedOrRawAccountData,\n  rentEpoch: superstruct.number()\n});\nconst KeyedParsedAccountInfoResult = superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: ParsedAccountInfoResult\n});\n\n/**\n * @internal\n */\nconst StakeActivationResult = superstruct.type({\n  state: superstruct.union([superstruct.literal('active'), superstruct.literal('inactive'), superstruct.literal('activating'), superstruct.literal('deactivating')]),\n  active: superstruct.number(),\n  inactive: superstruct.number()\n});\n\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */\n\nconst GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(superstruct.array(superstruct.type({\n  signature: superstruct.string(),\n  slot: superstruct.number(),\n  err: TransactionErrorResult,\n  memo: superstruct.nullable(superstruct.string()),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))\n})));\n\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */\nconst GetSignaturesForAddressRpcResult = jsonRpcResult(superstruct.array(superstruct.type({\n  signature: superstruct.string(),\n  slot: superstruct.number(),\n  err: TransactionErrorResult,\n  memo: superstruct.nullable(superstruct.string()),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))\n})));\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nconst AccountNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: notificationResultAndContext(AccountInfoResult)\n});\n\n/**\n * @internal\n */\nconst ProgramAccountInfoResult = superstruct.type({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\n\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\nconst ProgramAccountNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n\n/**\n * @internal\n */\nconst SlotInfoResult = superstruct.type({\n  parent: superstruct.number(),\n  slot: superstruct.number(),\n  root: superstruct.number()\n});\n\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\nconst SlotNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: SlotInfoResult\n});\n\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */\n\n/**\n * @internal\n */\nconst SlotUpdateResult = superstruct.union([superstruct.type({\n  type: superstruct.union([superstruct.literal('firstShredReceived'), superstruct.literal('completed'), superstruct.literal('optimisticConfirmation'), superstruct.literal('root')]),\n  slot: superstruct.number(),\n  timestamp: superstruct.number()\n}), superstruct.type({\n  type: superstruct.literal('createdBank'),\n  parent: superstruct.number(),\n  slot: superstruct.number(),\n  timestamp: superstruct.number()\n}), superstruct.type({\n  type: superstruct.literal('frozen'),\n  slot: superstruct.number(),\n  timestamp: superstruct.number(),\n  stats: superstruct.type({\n    numTransactionEntries: superstruct.number(),\n    numSuccessfulTransactions: superstruct.number(),\n    numFailedTransactions: superstruct.number(),\n    maxTransactionsPerEntry: superstruct.number()\n  })\n}), superstruct.type({\n  type: superstruct.literal('dead'),\n  slot: superstruct.number(),\n  timestamp: superstruct.number(),\n  err: superstruct.string()\n})]);\n\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */\nconst SlotUpdateNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: SlotUpdateResult\n});\n\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\nconst SignatureNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: notificationResultAndContext(superstruct.union([SignatureStatusResult, SignatureReceivedResult]))\n});\n\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */\nconst RootNotificationResult = superstruct.type({\n  subscription: superstruct.number(),\n  result: superstruct.number()\n});\nconst ContactInfoResult = superstruct.type({\n  pubkey: superstruct.string(),\n  gossip: superstruct.nullable(superstruct.string()),\n  tpu: superstruct.nullable(superstruct.string()),\n  rpc: superstruct.nullable(superstruct.string()),\n  version: superstruct.nullable(superstruct.string())\n});\nconst VoteAccountInfoResult = superstruct.type({\n  votePubkey: superstruct.string(),\n  nodePubkey: superstruct.string(),\n  activatedStake: superstruct.number(),\n  epochVoteAccount: superstruct.boolean(),\n  epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),\n  commission: superstruct.number(),\n  lastVote: superstruct.number(),\n  rootSlot: superstruct.nullable(superstruct.number())\n});\n\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\nconst GetVoteAccounts = jsonRpcResult(superstruct.type({\n  current: superstruct.array(VoteAccountInfoResult),\n  delinquent: superstruct.array(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = superstruct.union([superstruct.literal('processed'), superstruct.literal('confirmed'), superstruct.literal('finalized')]);\nconst SignatureStatusResponse = superstruct.type({\n  slot: superstruct.number(),\n  confirmations: superstruct.nullable(superstruct.number()),\n  err: TransactionErrorResult,\n  confirmationStatus: superstruct.optional(ConfirmationStatus)\n});\n\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */\nconst GetSignatureStatusesRpcResult = jsonRpcResultAndContext(superstruct.array(superstruct.nullable(SignatureStatusResponse)));\n\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\nconst GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(superstruct.number());\nconst AddressTableLookupStruct = superstruct.type({\n  accountKey: PublicKeyFromString,\n  writableIndexes: superstruct.array(superstruct.number()),\n  readonlyIndexes: superstruct.array(superstruct.number())\n});\nconst ConfirmedTransactionResult = superstruct.type({\n  signatures: superstruct.array(superstruct.string()),\n  message: superstruct.type({\n    accountKeys: superstruct.array(superstruct.string()),\n    header: superstruct.type({\n      numRequiredSignatures: superstruct.number(),\n      numReadonlySignedAccounts: superstruct.number(),\n      numReadonlyUnsignedAccounts: superstruct.number()\n    }),\n    instructions: superstruct.array(superstruct.type({\n      accounts: superstruct.array(superstruct.number()),\n      data: superstruct.string(),\n      programIdIndex: superstruct.number()\n    })),\n    recentBlockhash: superstruct.string(),\n    addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))\n  })\n});\nconst AnnotatedAccountKey = superstruct.type({\n  pubkey: PublicKeyFromString,\n  signer: superstruct.boolean(),\n  writable: superstruct.boolean(),\n  source: superstruct.optional(superstruct.union([superstruct.literal('transaction'), superstruct.literal('lookupTable')]))\n});\nconst ConfirmedTransactionAccountsModeResult = superstruct.type({\n  accountKeys: superstruct.array(AnnotatedAccountKey),\n  signatures: superstruct.array(superstruct.string())\n});\nconst ParsedInstructionResult = superstruct.type({\n  parsed: superstruct.unknown(),\n  program: superstruct.string(),\n  programId: PublicKeyFromString\n});\nconst RawInstructionResult = superstruct.type({\n  accounts: superstruct.array(PublicKeyFromString),\n  data: superstruct.string(),\n  programId: PublicKeyFromString\n});\nconst InstructionResult = superstruct.union([RawInstructionResult, ParsedInstructionResult]);\nconst UnknownInstructionResult = superstruct.union([superstruct.type({\n  parsed: superstruct.unknown(),\n  program: superstruct.string(),\n  programId: superstruct.string()\n}), superstruct.type({\n  accounts: superstruct.array(superstruct.string()),\n  data: superstruct.string(),\n  programId: superstruct.string()\n})]);\nconst ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, value => {\n  if ('accounts' in value) {\n    return superstruct.create(value, RawInstructionResult);\n  } else {\n    return superstruct.create(value, ParsedInstructionResult);\n  }\n});\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionResult = superstruct.type({\n  signatures: superstruct.array(superstruct.string()),\n  message: superstruct.type({\n    accountKeys: superstruct.array(AnnotatedAccountKey),\n    instructions: superstruct.array(ParsedOrRawInstruction),\n    recentBlockhash: superstruct.string(),\n    addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))\n  })\n});\nconst TokenBalanceResult = superstruct.type({\n  accountIndex: superstruct.number(),\n  mint: superstruct.string(),\n  owner: superstruct.optional(superstruct.string()),\n  programId: superstruct.optional(superstruct.string()),\n  uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = superstruct.type({\n  writable: superstruct.array(PublicKeyFromString),\n  readonly: superstruct.array(PublicKeyFromString)\n});\n\n/**\n * @internal\n */\nconst ConfirmedTransactionMetaResult = superstruct.type({\n  err: TransactionErrorResult,\n  fee: superstruct.number(),\n  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n    index: superstruct.number(),\n    instructions: superstruct.array(superstruct.type({\n      accounts: superstruct.array(superstruct.number()),\n      data: superstruct.string(),\n      programIdIndex: superstruct.number()\n    }))\n  })))),\n  preBalances: superstruct.array(superstruct.number()),\n  postBalances: superstruct.array(superstruct.number()),\n  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),\n  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  loadedAddresses: superstruct.optional(LoadedAddressesResult),\n  computeUnitsConsumed: superstruct.optional(superstruct.number())\n});\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionMetaResult = superstruct.type({\n  err: TransactionErrorResult,\n  fee: superstruct.number(),\n  innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({\n    index: superstruct.number(),\n    instructions: superstruct.array(ParsedOrRawInstruction)\n  })))),\n  preBalances: superstruct.array(superstruct.number()),\n  postBalances: superstruct.array(superstruct.number()),\n  logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),\n  preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),\n  loadedAddresses: superstruct.optional(LoadedAddressesResult),\n  computeUnitsConsumed: superstruct.optional(superstruct.number())\n});\nconst TransactionVersionStruct = superstruct.union([superstruct.literal(0), superstruct.literal('legacy')]);\n\n/** @internal */\nconst RewardsResult = superstruct.type({\n  pubkey: superstruct.string(),\n  lamports: superstruct.number(),\n  postBalance: superstruct.nullable(superstruct.number()),\n  rewardType: superstruct.nullable(superstruct.string()),\n  commission: superstruct.optional(superstruct.nullable(superstruct.number()))\n});\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionResult,\n    meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */\nconst GetNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */\nconst GetAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */\nconst GetParsedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ParsedConfirmedTransactionResult,\n    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */\nconst GetParsedAccountsModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n    version: superstruct.optional(TransactionVersionStruct)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */\nconst GetParsedNoneModeBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number()),\n  blockHeight: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since RPC v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */\nconst GetConfirmedBlockRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  transactions: superstruct.array(superstruct.type({\n    transaction: ConfirmedTransactionResult,\n    meta: superstruct.nullable(ConfirmedTransactionMetaResult)\n  })),\n  rewards: superstruct.optional(superstruct.array(RewardsResult)),\n  blockTime: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockSignaturesRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  blockhash: superstruct.string(),\n  previousBlockhash: superstruct.string(),\n  parentSlot: superstruct.number(),\n  signatures: superstruct.array(superstruct.string()),\n  blockTime: superstruct.nullable(superstruct.number())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */\nconst GetTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  slot: superstruct.number(),\n  meta: superstruct.nullable(ConfirmedTransactionMetaResult),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),\n  transaction: ConfirmedTransactionResult,\n  version: superstruct.optional(TransactionVersionStruct)\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */\nconst GetParsedTransactionRpcResult = jsonRpcResult(superstruct.nullable(superstruct.type({\n  slot: superstruct.number(),\n  transaction: ParsedConfirmedTransactionResult,\n  meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),\n  blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),\n  version: superstruct.optional(TransactionVersionStruct)\n})));\n\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */\nconst GetLatestBlockhashRpcResult = jsonRpcResultAndContext(superstruct.type({\n  blockhash: superstruct.string(),\n  lastValidBlockHeight: superstruct.number()\n}));\n\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */\nconst IsBlockhashValidRpcResult = jsonRpcResultAndContext(superstruct.boolean());\nconst PerfSampleResult = superstruct.type({\n  slot: superstruct.number(),\n  numTransactions: superstruct.number(),\n  numSlots: superstruct.number(),\n  samplePeriodSecs: superstruct.number()\n});\n\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */\nconst GetRecentPerformanceSamplesRpcResult = jsonRpcResult(superstruct.array(PerfSampleResult));\n\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */\nconst GetFeeCalculatorRpcResult = jsonRpcResultAndContext(superstruct.nullable(superstruct.type({\n  feeCalculator: superstruct.type({\n    lamportsPerSignature: superstruct.number()\n  })\n})));\n\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\nconst RequestAirdropRpcResult = jsonRpcResult(superstruct.string());\n\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\nconst SendTransactionRpcResult = jsonRpcResult(superstruct.string());\n\n/**\n * Information about the latest slot being processed by a node\n */\n\n/**\n * Parsed account data\n */\n\n/**\n * Stake Activation data\n */\n\n/**\n * Data slice argument for getProgramAccounts\n */\n\n/**\n * Memory comparison filter for getProgramAccounts\n */\n\n/**\n * Data size comparison filter for getProgramAccounts\n */\n\n/**\n * A filter object for getProgramAccounts\n */\n\n/**\n * Configuration object for getProgramAccounts requests\n */\n\n/**\n * Configuration object for getParsedProgramAccounts\n */\n\n/**\n * Configuration object for getMultipleAccounts\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getNonce`\n */\n\n/**\n * Configuration object for `getNonceAndContext`\n */\n\n/**\n * Information describing an account\n */\n\n/**\n * Account information identified by pubkey\n */\n\n/**\n * Callback function for account change notifications\n */\n\n/**\n * Callback function for program account change notifications\n */\n\n/**\n * Callback function for slot change notifications\n */\n\n/**\n * Callback function for slot update notifications\n */\n\n/**\n * Callback function for signature status notifications\n */\n\n/**\n * Signature status notification with transaction result\n */\n\n/**\n * Signature received notification\n */\n\n/**\n * Callback function for signature notifications\n */\n\n/**\n * Signature subscription options\n */\n\n/**\n * Callback function for root change notifications\n */\n\n/**\n * @internal\n */\nconst LogsResult = superstruct.type({\n  err: TransactionErrorResult,\n  logs: superstruct.array(superstruct.string()),\n  signature: superstruct.string()\n});\n\n/**\n * Logs result.\n */\n\n/**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */\nconst LogsNotificationResult = superstruct.type({\n  result: notificationResultAndContext(LogsResult),\n  subscription: superstruct.number()\n});\n\n/**\n * Filter for log subscriptions.\n */\n\n/**\n * Callback function for log notifications.\n */\n\n/**\n * Signature result\n */\n\n/**\n * Transaction error\n */\n\n/**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */\n\n/**\n * Signature status\n */\n\n/**\n * A confirmed signature with its status\n */\n\n/**\n * An object defining headers to be passed to the RPC server\n */\n\n/**\n * The type of the JavaScript `fetch()` API\n */\n\n/**\n * A callback used to augment the outgoing HTTP request\n */\n\n/**\n * Configuration for instantiating a Connection\n */\n\n/** @internal */\nconst COMMON_HTTP_HEADERS = {\n  'solana-client': `js/${\"1.0.0-maintenance\"}`\n};\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nclass Connection {\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */\n  constructor(endpoint, _commitmentOrConfig) {\n    var _context55, _context56, _context57, _context58, _context59, _context60, _context61, _context62, _context63, _context64;\n    /** @internal */\n    this._commitment = void 0;\n    /** @internal */\n    this._confirmTransactionInitialTimeout = void 0;\n    /** @internal */\n    this._rpcEndpoint = void 0;\n    /** @internal */\n    this._rpcWsEndpoint = void 0;\n    /** @internal */\n    this._rpcClient = void 0;\n    /** @internal */\n    this._rpcRequest = void 0;\n    /** @internal */\n    this._rpcBatchRequest = void 0;\n    /** @internal */\n    this._rpcWebSocket = void 0;\n    /** @internal */\n    this._rpcWebSocketConnected = false;\n    /** @internal */\n    this._rpcWebSocketHeartbeat = null;\n    /** @internal */\n    this._rpcWebSocketIdleTimeout = null;\n    /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */\n    this._rpcWebSocketGeneration = 0;\n    /** @internal */\n    this._disableBlockhashCaching = false;\n    /** @internal */\n    this._pollingBlockhash = false;\n    /** @internal */\n    this._blockhashInfo = {\n      latestBlockhash: null,\n      lastFetch: 0,\n      transactionSignatures: [],\n      simulatedSignatures: []\n    };\n    /** @internal */\n    this._nextClientSubscriptionId = 0;\n    /** @internal */\n    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionHashByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionStateChangeCallbacksByHash = {};\n    /** @internal */\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    /** @internal */\n    this._subscriptionsByHash = {};\n    /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */\n    /** @internal */\n    this._subscriptionsAutoDisposedByRpc = new _Set();\n    /*\n     * Returns the current block height of the node\n     */\n    this.getBlockHeight = (() => {\n      const requestPromises = {};\n      return async commitmentOrConfig => {\n        const {\n          commitment,\n          config\n        } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n        const requestHash = fastStableStringify(args);\n        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {\n          try {\n            const unsafeRes = await this._rpcRequest('getBlockHeight', args);\n            const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n            if ('error' in res) {\n              throw new SolanaJSONRPCError(res.error, 'failed to get block height information');\n            }\n            return res.result;\n          } finally {\n            delete requestPromises[requestHash];\n          }\n        })();\n        return await requestPromises[requestHash];\n      };\n    })();\n    let wsEndpoint;\n    let httpHeaders;\n    let fetch;\n    let fetchMiddleware;\n    let disableRetryOnRateLimit;\n    let httpAgent;\n    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {\n      this._commitment = _commitmentOrConfig;\n    } else if (_commitmentOrConfig) {\n      this._commitment = _commitmentOrConfig.commitment;\n      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n      wsEndpoint = _commitmentOrConfig.wsEndpoint;\n      httpHeaders = _commitmentOrConfig.httpHeaders;\n      fetch = _commitmentOrConfig.fetch;\n      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n      httpAgent = _commitmentOrConfig.httpAgent;\n    }\n    this._rpcEndpoint = assertEndpointUrl(endpoint);\n    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n    this._rpcRequest = createRpcRequest(this._rpcClient);\n    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n      autoconnect: false,\n      max_reconnects: Infinity\n    });\n    this._rpcWebSocket.on('open', _bindInstanceProperty(_context55 = this._wsOnOpen).call(_context55, this));\n    this._rpcWebSocket.on('error', _bindInstanceProperty(_context56 = this._wsOnError).call(_context56, this));\n    this._rpcWebSocket.on('close', _bindInstanceProperty(_context57 = this._wsOnClose).call(_context57, this));\n    this._rpcWebSocket.on('accountNotification', _bindInstanceProperty(_context58 = this._wsOnAccountNotification).call(_context58, this));\n    this._rpcWebSocket.on('programNotification', _bindInstanceProperty(_context59 = this._wsOnProgramAccountNotification).call(_context59, this));\n    this._rpcWebSocket.on('slotNotification', _bindInstanceProperty(_context60 = this._wsOnSlotNotification).call(_context60, this));\n    this._rpcWebSocket.on('slotsUpdatesNotification', _bindInstanceProperty(_context61 = this._wsOnSlotUpdatesNotification).call(_context61, this));\n    this._rpcWebSocket.on('signatureNotification', _bindInstanceProperty(_context62 = this._wsOnSignatureNotification).call(_context62, this));\n    this._rpcWebSocket.on('rootNotification', _bindInstanceProperty(_context63 = this._wsOnRootNotification).call(_context63, this));\n    this._rpcWebSocket.on('logsNotification', _bindInstanceProperty(_context64 = this._wsOnLogsNotification).call(_context64, this));\n  }\n\n  /**\n   * The default commitment used for requests\n   */\n  get commitment() {\n    return this._commitment;\n  }\n\n  /**\n   * The RPC endpoint\n   */\n  get rpcEndpoint() {\n    return this._rpcEndpoint;\n  }\n\n  /**\n   * Fetch the balance for the specified public key, return with context\n   */\n  async getBalanceAndContext(publicKey, commitmentOrConfig) {\n    /** @internal */\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getBalance', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the balance for the specified public key\n   */\n  async getBalance(publicKey, commitmentOrConfig) {\n    return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then(x => x.value).catch(e => {\n      throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);\n    });\n  }\n\n  /**\n   * Fetch the estimated production time of a block\n   */\n  async getBlockTime(slot) {\n    const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.nullable(superstruct.number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */\n  async getMinimumLedgerSlot() {\n    const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */\n  async getFirstAvailableBlock() {\n    const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);\n    const res = superstruct.create(unsafeRes, SlotRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get first available block');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch information about the current supply\n   */\n  async getSupply(config) {\n    let configArg = {};\n    if (typeof config === 'string') {\n      configArg = {\n        commitment: config\n      };\n    } else if (config) {\n      configArg = _objectSpread(_objectSpread({}, config), {}, {\n        commitment: config && config.commitment || this.commitment\n      });\n    } else {\n      configArg = {\n        commitment: this.commitment\n      };\n    }\n    const unsafeRes = await this._rpcRequest('getSupply', [configArg]);\n    const res = superstruct.create(unsafeRes, GetSupplyRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current supply of a token mint\n   */\n  async getTokenSupply(tokenMintAddress, commitment) {\n    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenSupply', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current balance of a token account\n   */\n  async getTokenAccountBalance(tokenAddress, commitment) {\n    const args = this._buildArgs([tokenAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */\n  async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    let _args = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({\n        mint: filter.mint.toBase58()\n      });\n    } else {\n      _args.push({\n        programId: filter.programId.toBase58()\n      });\n    }\n    const args = this._buildArgs(_args, commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */\n  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n    let _args = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({\n        mint: filter.mint.toBase58()\n      });\n    } else {\n      _args.push({\n        programId: filter.programId.toBase58()\n      });\n    }\n    const args = this._buildArgs(_args, commitment, 'jsonParsed');\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest accounts with their current balances\n   */\n  async getLargestAccounts(config) {\n    const arg = _objectSpread(_objectSpread({}, config), {}, {\n      commitment: config && config.commitment || this.commitment\n    });\n    const args = _filterInstanceProperty(arg) || arg.commitment ? [arg] : [];\n    const unsafeRes = await this._rpcRequest('getLargestAccounts', args);\n    const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */\n  async getTokenLargestAccounts(mintAddress, commitment) {\n    const args = this._buildArgs([mintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);\n    const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key, return with context\n   */\n  async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(AccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed account info for the specified public key\n   */\n  async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(ParsedAccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key\n   */\n  async getAccountInfo(publicKey, commitmentOrConfig) {\n    try {\n      const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + e);\n    }\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleParsedAccounts(publicKeys, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const keys = _mapInstanceProperty(publicKeys).call(publicKeys, key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(ParsedAccountInfoResult))));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const keys = _mapInstanceProperty(publicKeys).call(publicKeys, key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.array(superstruct.nullable(AccountInfoResult))));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */\n  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n    return res.value;\n  }\n\n  /**\n   * Returns epoch activation information for a stake account that has been delegated\n   *\n   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.\n   */\n  async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {\n      epoch: epoch != null ? epoch : config?.epoch\n    }));\n    const unsafeRes = await this._rpcRequest('getStakeActivation', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(StakeActivationResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getProgramAccounts(programId, configOrCommitment) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(configOrCommitment);\n    const _ref = config || {},\n      {\n        encoding\n      } = _ref,\n      configWithoutEncoding = _objectWithoutProperties(_ref, _excluded2);\n    const args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', _objectSpread(_objectSpread({}, configWithoutEncoding), configWithoutEncoding.filters ? {\n      filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)\n    } : null));\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const baseSchema = superstruct.array(KeyedAccountInfoResult);\n    const res = configWithoutEncoding.withContext === true ? superstruct.create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : superstruct.create(unsafeRes, jsonRpcResult(baseSchema));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */\n  async getParsedProgramAccounts(programId, configOrCommitment) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(configOrCommitment);\n    const args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(KeyedParsedAccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async confirmTransaction(strategy, commitment) {\n    let rawSignature;\n    if (typeof strategy == 'string') {\n      rawSignature = strategy;\n    } else {\n      const config = strategy;\n      if (config.abortSignal?.aborted) {\n        return _Promise.reject(config.abortSignal.reason);\n      }\n      rawSignature = config.signature;\n    }\n    let decodedSignature;\n    try {\n      decodedSignature = bs58__default.default.decode(rawSignature);\n    } catch (err) {\n      throw new Error('signature must be base58 encoded: ' + rawSignature);\n    }\n    assert(decodedSignature.length === 64, 'signature has invalid length');\n    if (typeof strategy === 'string') {\n      return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n        commitment: commitment || this.commitment,\n        signature: rawSignature\n      });\n    } else if ('lastValidBlockHeight' in strategy) {\n      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n        commitment: commitment || this.commitment,\n        strategy\n      });\n    } else {\n      return await this.confirmTransactionUsingDurableNonceStrategy({\n        commitment: commitment || this.commitment,\n        strategy\n      });\n    }\n  }\n  getCancellationPromise(signal) {\n    return new _Promise((_, reject) => {\n      if (signal == null) {\n        return;\n      }\n      if (signal.aborted) {\n        reject(signal.reason);\n      } else {\n        signal.addEventListener('abort', () => {\n          reject(signal.reason);\n        });\n      }\n    });\n  }\n  getTransactionConfirmationPromise({\n    commitment,\n    signature\n  }) {\n    let signatureSubscriptionId;\n    let disposeSignatureSubscriptionStateChangeObserver;\n    let done = false;\n    const confirmationPromise = new _Promise((resolve, reject) => {\n      try {\n        signatureSubscriptionId = this.onSignature(signature, (result, context) => {\n          signatureSubscriptionId = undefined;\n          const response = {\n            context,\n            value: result\n          };\n          resolve({\n            __type: TransactionStatus.PROCESSED,\n            response\n          });\n        }, commitment);\n        const subscriptionSetupPromise = new _Promise(resolveSubscriptionSetup => {\n          if (signatureSubscriptionId == null) {\n            resolveSubscriptionSetup();\n          } else {\n            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, nextState => {\n              if (nextState === 'subscribed') {\n                resolveSubscriptionSetup();\n              }\n            });\n          }\n        });\n        (async () => {\n          await subscriptionSetupPromise;\n          if (done) return;\n          const response = await this.getSignatureStatus(signature);\n          if (done) return;\n          if (response == null) {\n            return;\n          }\n          const {\n            context,\n            value\n          } = response;\n          if (value == null) {\n            return;\n          }\n          if (value?.err) {\n            reject(value.err);\n          } else {\n            switch (commitment) {\n              case 'confirmed':\n              case 'single':\n              case 'singleGossip':\n                {\n                  if (value.confirmationStatus === 'processed') {\n                    return;\n                  }\n                  break;\n                }\n              case 'finalized':\n              case 'max':\n              case 'root':\n                {\n                  if (value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed') {\n                    return;\n                  }\n                  break;\n                }\n              // exhaust enums to ensure full coverage\n              case 'processed':\n              case 'recent':\n            }\n            done = true;\n            resolve({\n              __type: TransactionStatus.PROCESSED,\n              response: {\n                context,\n                value\n              }\n            });\n          }\n        })();\n      } catch (err) {\n        reject(err);\n      }\n    });\n    const abortConfirmation = () => {\n      if (disposeSignatureSubscriptionStateChangeObserver) {\n        disposeSignatureSubscriptionStateChangeObserver();\n        disposeSignatureSubscriptionStateChangeObserver = undefined;\n      }\n      if (signatureSubscriptionId != null) {\n        this.removeSignatureListener(signatureSubscriptionId);\n        signatureSubscriptionId = undefined;\n      }\n    };\n    return {\n      abortConfirmation,\n      confirmationPromise\n    };\n  }\n  async confirmTransactionUsingBlockHeightExceedanceStrategy({\n    commitment,\n    strategy: {\n      abortSignal,\n      lastValidBlockHeight,\n      signature\n    }\n  }) {\n    let done = false;\n    const expiryPromise = new _Promise(resolve => {\n      const checkBlockHeight = async () => {\n        try {\n          const blockHeight = await this.getBlockHeight(commitment);\n          return blockHeight;\n        } catch (_e) {\n          return -1;\n        }\n      };\n      (async () => {\n        let currentBlockHeight = await checkBlockHeight();\n        if (done) return;\n        while (currentBlockHeight <= lastValidBlockHeight) {\n          await sleep(1000);\n          if (done) return;\n          currentBlockHeight = await checkBlockHeight();\n          if (done) return;\n        }\n        resolve({\n          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n        });\n      })();\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result;\n    try {\n      const outcome = await _Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredBlockheightExceededError(signature);\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n  async confirmTransactionUsingDurableNonceStrategy({\n    commitment,\n    strategy: {\n      abortSignal,\n      minContextSlot,\n      nonceAccountPubkey,\n      nonceValue,\n      signature\n    }\n  }) {\n    let done = false;\n    const expiryPromise = new _Promise(resolve => {\n      let currentNonceValue = nonceValue;\n      let lastCheckedSlot = null;\n      const getCurrentNonceValue = async () => {\n        try {\n          const {\n            context,\n            value: nonceAccount\n          } = await this.getNonceAndContext(nonceAccountPubkey, {\n            commitment,\n            minContextSlot\n          });\n          lastCheckedSlot = context.slot;\n          return nonceAccount?.nonce;\n        } catch (e) {\n          // If for whatever reason we can't reach/read the nonce\n          // account, just keep using the last-known value.\n          return currentNonceValue;\n        }\n      };\n      (async () => {\n        currentNonceValue = await getCurrentNonceValue();\n        if (done) return;\n        while (true // eslint-disable-line no-constant-condition\n        ) {\n          if (nonceValue !== currentNonceValue) {\n            resolve({\n              __type: TransactionStatus.NONCE_INVALID,\n              slotInWhichNonceDidAdvance: lastCheckedSlot\n            });\n            return;\n          }\n          await sleep(2000);\n          if (done) return;\n          currentNonceValue = await getCurrentNonceValue();\n          if (done) return;\n        }\n      })();\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result;\n    try {\n      const outcome = await _Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        // Double check that the transaction is indeed unconfirmed.\n        let signatureStatus;\n        while (true // eslint-disable-line no-constant-condition\n        ) {\n          const status = await this.getSignatureStatus(signature);\n          if (status == null) {\n            break;\n          }\n          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n            await sleep(400);\n            continue;\n          }\n          signatureStatus = status;\n          break;\n        }\n        if (signatureStatus?.value) {\n          const commitmentForStatus = commitment || 'finalized';\n          const {\n            confirmationStatus\n          } = signatureStatus.value;\n          switch (commitmentForStatus) {\n            case 'processed':\n            case 'recent':\n              if (confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'confirmed':\n            case 'single':\n            case 'singleGossip':\n              if (confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'finalized':\n            case 'max':\n            case 'root':\n              if (confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            default:\n              // Exhaustive switch.\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              (_ => {})(commitmentForStatus);\n          }\n          result = {\n            context: signatureStatus.context,\n            value: {\n              err: signatureStatus.value.err\n            }\n          };\n        } else {\n          throw new TransactionExpiredNonceInvalidError(signature);\n        }\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n  async confirmTransactionUsingLegacyTimeoutStrategy({\n    commitment,\n    signature\n  }) {\n    let timeoutId;\n    const expiryPromise = new _Promise(resolve => {\n      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n      switch (commitment) {\n        case 'processed':\n        case 'recent':\n        case 'single':\n        case 'confirmed':\n        case 'singleGossip':\n          {\n            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n            break;\n          }\n      }\n      timeoutId = _setTimeout(() => resolve({\n        __type: TransactionStatus.TIMED_OUT,\n        timeoutMs\n      }), timeoutMs);\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    let result;\n    try {\n      const outcome = await _Promise.race([confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n      }\n    } finally {\n      clearTimeout(timeoutId);\n      abortConfirmation();\n    }\n    return result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getClusterNodes() {\n    const unsafeRes = await this._rpcRequest('getClusterNodes', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(ContactInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');\n    }\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getVoteAccounts(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);\n    const res = superstruct.create(unsafeRes, GetVoteAccounts);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot that the node is processing\n   */\n  async getSlot(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getSlot', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot leader of the cluster\n   */\n  async getSlotLeader(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getSlotLeader', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */\n  async getSlotLeaders(startSlot, limit) {\n    const args = [startSlot, limit];\n    const unsafeRes = await this._rpcRequest('getSlotLeaders', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(PublicKeyFromString)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current status of a signature\n   */\n  async getSignatureStatus(signature, config) {\n    const {\n      context,\n      value: values\n    } = await this.getSignatureStatuses([signature], config);\n    assert(values.length === 1);\n    const value = values[0];\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the current statuses of a batch of signatures\n   */\n  async getSignatureStatuses(signatures, config) {\n    const params = [signatures];\n    if (config) {\n      params.push(config);\n    }\n    const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);\n    const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get signature status');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async getTransactionCount(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getTransactionCount', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.\n   */\n  async getTotalSupply(commitment) {\n    const result = await this.getSupply({\n      commitment,\n      excludeNonCirculatingAccountsList: true\n    });\n    return result.value.total;\n  }\n\n  /**\n   * Fetch the cluster InflationGovernor parameters\n   */\n  async getInflationGovernor(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getInflationGovernor', args);\n    const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */\n  async getInflationReward(addresses, epoch, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([_mapInstanceProperty(addresses).call(addresses, pubkey => pubkey.toBase58())], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {\n      epoch: epoch != null ? epoch : config?.epoch\n    }));\n    const unsafeRes = await this._rpcRequest('getInflationReward', args);\n    const res = superstruct.create(unsafeRes, GetInflationRewardResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the specific inflation values for the current epoch\n   */\n  async getInflationRate() {\n    const unsafeRes = await this._rpcRequest('getInflationRate', []);\n    const res = superstruct.create(unsafeRes, GetInflationRateRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Info parameters\n   */\n  async getEpochInfo(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getEpochInfo', args);\n    const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Schedule parameters\n   */\n  async getEpochSchedule() {\n    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);\n    const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');\n    }\n    const epochSchedule = res.result;\n    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n  }\n\n  /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */\n  async getLeaderSchedule() {\n    const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);\n    const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */\n  async getMinimumBalanceForRentExemption(dataLength, commitment) {\n    const args = this._buildArgs([dataLength], commitment);\n    const unsafeRes = await this._rpcRequest('getMinimumBalanceForRentExemption', args);\n    const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n    if ('error' in res) {\n      console.warn('Unable to fetch minimum balance for rent exemption');\n      return 0;\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhashAndContext(commitment) {\n    const {\n      context,\n      value: {\n        blockhash\n      }\n    } = await this.getLatestBlockhashAndContext(commitment);\n    const feeCalculator = {\n      get lamportsPerSignature() {\n        throw new Error('The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is ' + 'no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee ' + 'for a given message.');\n      },\n      toJSON() {\n        return {};\n      }\n    };\n    return {\n      context,\n      value: {\n        blockhash,\n        feeCalculator\n      }\n    };\n  }\n\n  /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */\n  async getRecentPerformanceSamples(limit) {\n    const unsafeRes = await this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);\n    const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.\n   */\n  async getFeeCalculatorForBlockhash(blockhash, commitment) {\n    const args = this._buildArgs([blockhash], commitment);\n    const unsafeRes = await this._rpcRequest('getFeeCalculatorForBlockhash', args);\n    const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');\n    }\n    const {\n      context,\n      value\n    } = res.result;\n    return {\n      context,\n      value: value !== null ? value.feeCalculator : null\n    };\n  }\n\n  /**\n   * Fetch the fee for a message from the cluster, return with context\n   */\n  async getFeeForMessage(message, commitment) {\n    const wireMessage = toBuffer(message.serialize()).toString('base64');\n    const args = this._buildArgs([wireMessage], commitment);\n    const unsafeRes = await this._rpcRequest('getFeeForMessage', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.nullable(superstruct.number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');\n    }\n    if (res.result === null) {\n      throw new Error('invalid blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */\n  async getRecentPrioritizationFees(config) {\n    const accounts = config?.lockedWritableAccounts?.map(key => key.toBase58());\n    const args = accounts?.length ? [accounts] : [];\n    const unsafeRes = await this._rpcRequest('getRecentPrioritizationFees', args);\n    const res = superstruct.create(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');\n    }\n    return res.result;\n  }\n  /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhash(commitment) {\n    try {\n      const res = await this.getRecentBlockhashAndContext(commitment);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhash(commitmentOrConfig) {\n    try {\n      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhashAndContext(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getLatestBlockhash', args);\n    const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns whether a blockhash is still valid or not\n   */\n  async isBlockhashValid(blockhash, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgs([blockhash], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('isBlockhashValid', args);\n    const res = superstruct.create(unsafeRes, IsBlockhashValidRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to determine if the blockhash `' + blockhash + '`is valid');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the node version\n   */\n  async getVersion() {\n    const unsafeRes = await this._rpcRequest('getVersion', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(VersionResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get version');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the genesis hash\n   */\n  async getGenesisHash() {\n    const unsafeRes = await this._rpcRequest('getGenesisHash', []);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.string()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(slot, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts':\n          {\n            const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        case 'none':\n          {\n            const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        default:\n          {\n            var _context65;\n            const res = superstruct.create(unsafeRes, GetBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            const {\n              result\n            } = res;\n            return result ? _objectSpread(_objectSpread({}, result), {}, {\n              transactions: _mapInstanceProperty(_context65 = result.transactions).call(_context65, ({\n                transaction,\n                meta,\n                version\n              }) => ({\n                meta,\n                transaction: _objectSpread(_objectSpread({}, transaction), {}, {\n                  message: versionedMessageFromResponse(version, transaction.message)\n                }),\n                version\n              }))\n            }) : null;\n          }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(e, 'failed to get confirmed block');\n    }\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getParsedBlock(slot, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts':\n          {\n            const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        case 'none':\n          {\n            const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        default:\n          {\n            const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(e, 'failed to get block');\n    }\n  }\n  /*\n   * Returns recent block production information from the current or previous epoch\n   */\n  async getBlockProduction(configOrCommitment) {\n    let extra;\n    let commitment;\n    if (typeof configOrCommitment === 'string') {\n      commitment = configOrCommitment;\n    } else if (configOrCommitment) {\n      const {\n          commitment: c\n        } = configOrCommitment,\n        rest = _objectWithoutProperties(configOrCommitment, _excluded3);\n      commitment = c;\n      extra = rest;\n    }\n    const args = this._buildArgs([], commitment, 'base64', extra);\n    const unsafeRes = await this._rpcRequest('getBlockProduction', args);\n    const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get block production information');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransaction(signature, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    const result = res.result;\n    if (!result) return result;\n    return _objectSpread(_objectSpread({}, result), {}, {\n      transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {\n        message: versionedMessageFromResponse(result.version, result.transaction.message)\n      })\n    });\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */\n  async getParsedTransaction(signature, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */\n  async getParsedTransactions(signatures, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = _mapInstanceProperty(signatures).call(signatures, signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n      return {\n        methodName: 'getTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = _mapInstanceProperty(unsafeRes).call(unsafeRes, unsafeRes => {\n      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      return res.result;\n    });\n    return res;\n  }\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransactions(signatures, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = _mapInstanceProperty(signatures).call(signatures, signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n      return {\n        methodName: 'getTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = _mapInstanceProperty(unsafeRes).call(unsafeRes, unsafeRes => {\n      const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      const result = res.result;\n      if (!result) return result;\n      return _objectSpread(_objectSpread({}, result), {}, {\n        transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {\n          message: versionedMessageFromResponse(result.version, result.transaction.message)\n        })\n      });\n    });\n    return res;\n  }\n\n  /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.\n   */\n  async getConfirmedBlock(slot, commitment) {\n    var _context66, _context67;\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    const block = _objectSpread(_objectSpread({}, result), {}, {\n      transactions: _mapInstanceProperty(_context66 = result.transactions).call(_context66, ({\n        transaction,\n        meta\n      }) => {\n        const message = new Message(transaction.message);\n        return {\n          meta,\n          transaction: _objectSpread(_objectSpread({}, transaction), {}, {\n            message\n          })\n        };\n      })\n    });\n    return _objectSpread(_objectSpread({}, block), {}, {\n      transactions: _mapInstanceProperty(_context67 = block.transactions).call(_context67, ({\n        transaction,\n        meta\n      }) => {\n        return {\n          meta,\n          transaction: Transaction.populate(transaction.message, transaction.signatures)\n        };\n      })\n    });\n  }\n\n  /**\n   * Fetch confirmed blocks between two slots\n   */\n  async getBlocks(startSlot, endSlot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);\n    const unsafeRes = await this._rpcRequest('getBlocks', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResult(superstruct.array(superstruct.number())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get blocks');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */\n  async getBlockSignatures(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n      transactionDetails: 'signatures',\n      rewards: false\n    });\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.\n   */\n  async getConfirmedBlockSignatures(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n      transactionDetails: 'signatures',\n      rewards: false\n    });\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.\n   */\n  async getConfirmedTransaction(signature, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = superstruct.create(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    const result = res.result;\n    if (!result) return result;\n    const message = new Message(result.transaction.message);\n    const signatures = result.transaction.signatures;\n    return _objectSpread(_objectSpread({}, result), {}, {\n      transaction: Transaction.populate(message, signatures)\n    });\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.\n   */\n  async getParsedConfirmedTransaction(signature, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.\n   */\n  async getParsedConfirmedTransactions(signatures, commitment) {\n    const batch = _mapInstanceProperty(signatures).call(signatures, signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n      return {\n        methodName: 'getTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = _mapInstanceProperty(unsafeRes).call(unsafeRes, unsafeRes => {\n      const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');\n      }\n      return res.result;\n    });\n    return res;\n  }\n\n  /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */\n  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n    let options = {};\n    let firstAvailableBlock = await this.getFirstAvailableBlock();\n    while (!('until' in options)) {\n      startSlot--;\n      if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n        break;\n      }\n      try {\n        const block = await this.getConfirmedBlockSignatures(startSlot, 'finalized');\n        if (block.signatures.length > 0) {\n          options.until = block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        var _context68;\n        if (err instanceof Error && _includesInstanceProperty(_context68 = err.message).call(_context68, 'skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n    let highestConfirmedRoot = await this.getSlot('finalized');\n    while (!('before' in options)) {\n      endSlot++;\n      if (endSlot > highestConfirmedRoot) {\n        break;\n      }\n      try {\n        const block = await this.getConfirmedBlockSignatures(endSlot);\n        if (block.signatures.length > 0) {\n          options.before = block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        var _context69;\n        if (err instanceof Error && _includesInstanceProperty(_context69 = err.message).call(_context69, 'skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n    return _mapInstanceProperty(confirmedSignatureInfo).call(confirmedSignatureInfo, info => info.signature);\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.\n   */\n  async getConfirmedSignaturesForAddress2(address, options, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n    const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress2', args);\n    const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */\n  async getSignaturesForAddress(address, options, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n    const unsafeRes = await this._rpcRequest('getSignaturesForAddress', args);\n    const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');\n    }\n    return res.result;\n  }\n  async getAddressLookupTable(accountKey, config) {\n    const {\n      context,\n      value: accountInfo\n    } = await this.getAccountInfoAndContext(accountKey, config);\n    let value = null;\n    if (accountInfo !== null) {\n      value = new AddressLookupTableAccount({\n        key: accountKey,\n        state: AddressLookupTableAccount.deserialize(accountInfo.data)\n      });\n    }\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */\n  async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n    const {\n      context,\n      value: accountInfo\n    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n    let value = null;\n    if (accountInfo !== null) {\n      value = NonceAccount.fromAccountData(accountInfo.data);\n    }\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster\n   */\n  async getNonce(nonceAccount, commitmentOrConfig) {\n    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(x => x.value).catch(e => {\n      throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);\n    });\n  }\n\n  /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */\n  async requestAirdrop(to, lamports) {\n    const unsafeRes = await this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);\n    const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  async _blockhashWithExpiryBlockHeight(disableCache) {\n    if (!disableCache) {\n      // Wait for polling to finish\n      while (this._pollingBlockhash) {\n        await sleep(100);\n      }\n      const timeSinceFetch = _Date$now() - this._blockhashInfo.lastFetch;\n      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n      if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n        return this._blockhashInfo.latestBlockhash;\n      }\n    }\n    return await this._pollNewBlockhash();\n  }\n\n  /**\n   * @internal\n   */\n  async _pollNewBlockhash() {\n    this._pollingBlockhash = true;\n    try {\n      const startTime = _Date$now();\n      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n      for (let i = 0; i < 50; i++) {\n        const latestBlockhash = await this.getLatestBlockhash('finalized');\n        if (cachedBlockhash !== latestBlockhash.blockhash) {\n          this._blockhashInfo = {\n            latestBlockhash,\n            lastFetch: _Date$now(),\n            transactionSignatures: [],\n            simulatedSignatures: []\n          };\n          return latestBlockhash;\n        }\n\n        // Sleep for approximately half a slot\n        await sleep(MS_PER_SLOT / 2);\n      }\n      throw new Error(`Unable to obtain a new blockhash after ${_Date$now() - startTime}ms`);\n    } finally {\n      this._pollingBlockhash = false;\n    }\n  }\n\n  /**\n   * get the stake minimum delegation\n   */\n  async getStakeMinimumDelegation(config) {\n    const {\n      commitment,\n      config: configArg\n    } = extractCommitmentFromConfig(config);\n    const args = this._buildArgs([], commitment, 'base64', configArg);\n    const unsafeRes = await this._rpcRequest('getStakeMinimumDelegation', args);\n    const res = superstruct.create(unsafeRes, jsonRpcResultAndContext(superstruct.number()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n    if ('message' in transactionOrMessage) {\n      const versionedTx = transactionOrMessage;\n      const wireTransaction = versionedTx.serialize();\n      const encodedTransaction = buffer.Buffer.from(wireTransaction).toString('base64');\n      if (_Array$isArray(configOrSigners) || includeAccounts !== undefined) {\n        throw new Error('Invalid arguments');\n      }\n      const config = configOrSigners || {};\n      config.encoding = 'base64';\n      if (!('commitment' in config)) {\n        config.commitment = this.commitment;\n      }\n      if (configOrSigners && typeof configOrSigners === 'object' && 'innerInstructions' in configOrSigners) {\n        config.innerInstructions = configOrSigners.innerInstructions;\n      }\n      const args = [encodedTransaction, config];\n      const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n      const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);\n      if ('error' in res) {\n        throw new Error('failed to simulate transaction: ' + res.error.message);\n      }\n      return res.result;\n    }\n    let transaction;\n    if (transactionOrMessage instanceof Transaction) {\n      let originalTx = transactionOrMessage;\n      transaction = new Transaction();\n      transaction.feePayer = originalTx.feePayer;\n      transaction.instructions = transactionOrMessage.instructions;\n      transaction.nonceInfo = originalTx.nonceInfo;\n      transaction.signatures = originalTx.signatures;\n    } else {\n      transaction = Transaction.populate(transactionOrMessage);\n      // HACK: this function relies on mutating the populated transaction\n      transaction._message = transaction._json = undefined;\n    }\n    if (configOrSigners !== undefined && !_Array$isArray(configOrSigners)) {\n      throw new Error('Invalid arguments');\n    }\n    const signers = configOrSigners;\n    if (transaction.nonceInfo && signers) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        var _context70, _context71;\n        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n        if (!signers) break;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n\n        const signature = transaction.signature.toString('base64');\n        if (!_includesInstanceProperty(_context70 = this._blockhashInfo.simulatedSignatures).call(_context70, signature) && !_includesInstanceProperty(_context71 = this._blockhashInfo.transactionSignatures).call(_context71, signature)) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.simulatedSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n    const message = transaction._compile();\n    const signData = message.serialize();\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString('base64');\n    const config = {\n      encoding: 'base64',\n      commitment: this.commitment\n    };\n    if (includeAccounts) {\n      var _context72;\n      const addresses = _mapInstanceProperty(_context72 = _Array$isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).call(_context72, key => key.toBase58());\n      config['accounts'] = {\n        encoding: 'base64',\n        addresses\n      };\n    }\n    if (signers) {\n      config.sigVerify = true;\n    }\n    if (configOrSigners && typeof configOrSigners === 'object' && 'innerInstructions' in configOrSigners) {\n      config.innerInstructions = configOrSigners.innerInstructions;\n    }\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n    const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct);\n    if ('error' in res) {\n      let logs;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n        if (logs && _Array$isArray(logs)) {\n          const traceIndent = '\\n    ';\n          const logTrace = traceIndent + logs.join(traceIndent);\n          console.error(res.error.message, logTrace);\n        }\n      }\n      throw new SendTransactionError({\n        action: 'simulate',\n        signature: '',\n        transactionMessage: res.error.message,\n        logs: logs\n      });\n    }\n    return res.result;\n  }\n\n  /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */\n\n  /**\n   * Send a signed transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Sign and send a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async sendTransaction(transaction, signersOrOptions, options) {\n    if ('version' in transaction) {\n      if (signersOrOptions && _Array$isArray(signersOrOptions)) {\n        throw new Error('Invalid arguments');\n      }\n      const wireTransaction = transaction.serialize();\n      return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n    }\n    if (signersOrOptions === undefined || !_Array$isArray(signersOrOptions)) {\n      throw new Error('Invalid arguments');\n    }\n    const signers = signersOrOptions;\n    if (transaction.nonceInfo) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        var _context73;\n        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n\n        const signature = transaction.signature.toString('base64');\n        if (!_includesInstanceProperty(_context73 = this._blockhashInfo.transactionSignatures).call(_context73, signature)) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.transactionSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n    const wireTransaction = transaction.serialize();\n    return await this.sendRawTransaction(wireTransaction, options);\n  }\n\n  /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */\n  async sendRawTransaction(rawTransaction, options) {\n    const encodedTransaction = toBuffer(rawTransaction).toString('base64');\n    const result = await this.sendEncodedTransaction(encodedTransaction, options);\n    return result;\n  }\n\n  /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */\n  async sendEncodedTransaction(encodedTransaction, options) {\n    const config = {\n      encoding: 'base64'\n    };\n    const skipPreflight = options && options.skipPreflight;\n    const preflightCommitment = skipPreflight === true ? 'processed' // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n    : options && options.preflightCommitment || this.commitment;\n    if (options && options.maxRetries != null) {\n      config.maxRetries = options.maxRetries;\n    }\n    if (options && options.minContextSlot != null) {\n      config.minContextSlot = options.minContextSlot;\n    }\n    if (skipPreflight) {\n      config.skipPreflight = skipPreflight;\n    }\n    if (preflightCommitment) {\n      config.preflightCommitment = preflightCommitment;\n    }\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('sendTransaction', args);\n    const res = superstruct.create(unsafeRes, SendTransactionRpcResult);\n    if ('error' in res) {\n      let logs = undefined;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n      }\n      throw new SendTransactionError({\n        action: skipPreflight ? 'send' : 'simulate',\n        signature: '',\n        transactionMessage: res.error.message,\n        logs: logs\n      });\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnOpen() {\n    this._rpcWebSocketConnected = true;\n    this._rpcWebSocketHeartbeat = _setInterval(() => {\n      // Ping server every 5s to prevent idle timeouts\n      (async () => {\n        try {\n          await this._rpcWebSocket.notify('ping');\n          // eslint-disable-next-line no-empty\n        } catch {}\n      })();\n    }, 5000);\n    this._updateSubscriptions();\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnError(err) {\n    this._rpcWebSocketConnected = false;\n    console.error('ws error:', err.message);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnClose(code) {\n    var _context74;\n    this._rpcWebSocketConnected = false;\n    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % _Number$MAX_SAFE_INTEGER;\n    if (this._rpcWebSocketIdleTimeout) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n    }\n    if (this._rpcWebSocketHeartbeat) {\n      clearInterval(this._rpcWebSocketHeartbeat);\n      this._rpcWebSocketHeartbeat = null;\n    }\n    if (code === 1000) {\n      // explicit close, check if any subscriptions have been made since close\n      this._updateSubscriptions();\n      return;\n    }\n\n    // implicit close, prepare subscriptions for auto-reconnect\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    _forEachInstanceProperty(_context74 = _Object$entries(this._subscriptionsByHash)).call(_context74, ([hash, subscription]) => {\n      this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n        state: 'pending'\n      }));\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _setSubscription(hash, nextSubscription) {\n    const prevState = this._subscriptionsByHash[hash]?.state;\n    this._subscriptionsByHash[hash] = nextSubscription;\n    if (prevState !== nextSubscription.state) {\n      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n      if (stateChangeCallbacks) {\n        _forEachInstanceProperty(stateChangeCallbacks).call(stateChangeCallbacks, cb => {\n          try {\n            cb(nextSubscription.state);\n            // eslint-disable-next-line no-empty\n          } catch {}\n        });\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _onSubscriptionStateChange(clientSubscriptionId, callback) {\n    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n    if (hash == null) {\n      return () => {};\n    }\n    const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new _Set();\n    stateChangeCallbacks.add(callback);\n    return () => {\n      stateChangeCallbacks.delete(callback);\n      if (stateChangeCallbacks.size === 0) {\n        delete this._subscriptionStateChangeCallbacksByHash[hash];\n      }\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async _updateSubscriptions() {\n    var _context75;\n    if (_Object$keys(this._subscriptionsByHash).length === 0) {\n      if (this._rpcWebSocketConnected) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketIdleTimeout = _setTimeout(() => {\n          this._rpcWebSocketIdleTimeout = null;\n          try {\n            this._rpcWebSocket.close();\n          } catch (err) {\n            // swallow error if socket has already been closed.\n            if (err instanceof Error) {\n              console.log(`Error when closing socket connection: ${err.message}`);\n            }\n          }\n        }, 500);\n      }\n      return;\n    }\n    if (this._rpcWebSocketIdleTimeout !== null) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n      this._rpcWebSocketConnected = true;\n    }\n    if (!this._rpcWebSocketConnected) {\n      this._rpcWebSocket.connect();\n      return;\n    }\n    const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n    const isCurrentConnectionStillActive = () => {\n      return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n    };\n    await _Promise.all(\n    // Don't be tempted to change this to `Object.entries`. We call\n    // `_updateSubscriptions` recursively when processing the state,\n    // so it's important that we look up the *current* version of\n    // each subscription, every time we process a hash.\n    _mapInstanceProperty(_context75 = _Object$keys(this._subscriptionsByHash)).call(_context75, async hash => {\n      const subscription = this._subscriptionsByHash[hash];\n      if (subscription === undefined) {\n        // This entry has since been deleted. Skip.\n        return;\n      }\n      switch (subscription.state) {\n        case 'pending':\n        case 'unsubscribed':\n          if (subscription.callbacks.size === 0) {\n            /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */\n            delete this._subscriptionsByHash[hash];\n            if (subscription.state === 'unsubscribed') {\n              delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n            }\n            await this._updateSubscriptions();\n            return;\n          }\n          await (async () => {\n            const {\n              args,\n              method\n            } = subscription;\n            try {\n              this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                state: 'subscribing'\n              }));\n              const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n              this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                serverSubscriptionId,\n                state: 'subscribed'\n              }));\n              this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n              await this._updateSubscriptions();\n            } catch (e) {\n              console.error(`Received ${e instanceof Error ? '' : 'JSON-RPC '}error calling \\`${method}\\``, {\n                args,\n                error: e\n              });\n              if (!isCurrentConnectionStillActive()) {\n                return;\n              }\n              // TODO: Maybe add an 'errored' state or a retry limit?\n              this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                state: 'pending'\n              }));\n              await this._updateSubscriptions();\n            }\n          })();\n          break;\n        case 'subscribed':\n          if (subscription.callbacks.size === 0) {\n            // By the time we successfully set up a subscription\n            // with the server, the client stopped caring about it.\n            // Tear it down now.\n            await (async () => {\n              const {\n                serverSubscriptionId,\n                unsubscribeMethod\n              } = subscription;\n              if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */\n                this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n              } else {\n                this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                  state: 'unsubscribing'\n                }));\n                this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                  state: 'unsubscribing'\n                }));\n                try {\n                  await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);\n                } catch (e) {\n                  if (e instanceof Error) {\n                    console.error(`${unsubscribeMethod} error:`, e.message);\n                  }\n                  if (!isCurrentConnectionStillActive()) {\n                    return;\n                  }\n                  // TODO: Maybe add an 'errored' state or a retry limit?\n                  this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                    state: 'subscribed'\n                  }));\n                  await this._updateSubscriptions();\n                  return;\n                }\n              }\n              this._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                state: 'unsubscribed'\n              }));\n              await this._updateSubscriptions();\n            })();\n          }\n          break;\n      }\n    }));\n  }\n\n  /**\n   * @internal\n   */\n  _handleServerNotification(serverSubscriptionId, callbackArgs) {\n    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n    if (callbacks === undefined) {\n      return;\n    }\n    _forEachInstanceProperty(callbacks).call(callbacks, cb => {\n      try {\n        cb(\n        // I failed to find a way to convince TypeScript that `cb` is of type\n        // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n        // See https://github.com/microsoft/TypeScript/issues/47615\n        // @ts-ignore\n        ...callbackArgs);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnAccountNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, AccountNotificationResult);\n    this._handleServerNotification(subscription, [result.value, result.context]);\n  }\n\n  /**\n   * @internal\n   */\n  _makeSubscription(subscriptionConfig,\n  /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */\n  args) {\n    const clientSubscriptionId = this._nextClientSubscriptionId++;\n    const hash = fastStableStringify([subscriptionConfig.method, args]);\n    const existingSubscription = this._subscriptionsByHash[hash];\n    if (existingSubscription === undefined) {\n      this._subscriptionsByHash[hash] = _objectSpread(_objectSpread({}, subscriptionConfig), {}, {\n        args,\n        callbacks: new _Set([subscriptionConfig.callback]),\n        state: 'pending'\n      });\n    } else {\n      existingSubscription.callbacks.add(subscriptionConfig.callback);\n    }\n    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {\n      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n      const subscription = this._subscriptionsByHash[hash];\n      assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n      subscription.callbacks.delete(subscriptionConfig.callback);\n      await this._updateSubscriptions();\n    };\n    this._updateSubscriptions();\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */\n\n  /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  onAccountChange(publicKey, callback, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized',\n    // Apply connection/server default.\n    'base64', config);\n    return this._makeSubscription({\n      callback,\n      method: 'accountSubscribe',\n      unsubscribeMethod: 'accountUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeAccountChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnProgramAccountNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, ProgramAccountNotificationResult);\n    this._handleServerNotification(subscription, [{\n      accountId: result.value.pubkey,\n      accountInfo: result.value.account\n    }, result.context]);\n  }\n\n  /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param config\n   * @return subscription id\n   */\n\n  /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized',\n    // Apply connection/server default.\n    'base64' /* encoding */, config ? config : maybeFilters ? {\n      filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)\n    } : undefined /* extra */);\n    return this._makeSubscription({\n      callback,\n      method: 'programSubscribe',\n      unsubscribeMethod: 'programUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeProgramAccountChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');\n  }\n\n  /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */\n  onLogs(filter, callback, commitment) {\n    const args = this._buildArgs([typeof filter === 'object' ? {\n      mentions: [filter.toString()]\n    } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.\n    );\n\n    return this._makeSubscription({\n      callback,\n      method: 'logsSubscribe',\n      unsubscribeMethod: 'logsUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */\n  async removeOnLogsListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnLogsNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, LogsNotificationResult);\n    this._handleServerNotification(subscription, [result.value, result.context]);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, SlotNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */\n  onSlotChange(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'slotSubscribe',\n      unsubscribeMethod: 'slotUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotUpdatesNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, SlotUpdateNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */\n  onSlotUpdate(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'slotsUpdatesSubscribe',\n      unsubscribeMethod: 'slotsUpdatesUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotUpdateListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');\n  }\n\n  /**\n   * @internal\n   */\n\n  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n    if (dispose) {\n      await dispose();\n    } else {\n      console.warn('Ignored unsubscribe request because an active subscription with id ' + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + 'could not be found.');\n    }\n  }\n  _buildArgs(args, override, encoding, extra) {\n    const commitment = override || this._commitment;\n    if (commitment || encoding || extra) {\n      let options = {};\n      if (encoding) {\n        options.encoding = encoding;\n      }\n      if (commitment) {\n        options.commitment = commitment;\n      }\n      if (extra) {\n        options = _Object$assign(options, extra);\n      }\n      args.push(options);\n    }\n    return args;\n  }\n\n  /**\n   * @internal\n   */\n  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n    var _context76;\n    const commitment = override || this._commitment;\n    if (commitment && !_includesInstanceProperty(_context76 = ['confirmed', 'finalized']).call(_context76, commitment)) {\n      throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');\n    }\n    return this._buildArgs(args, override, encoding, extra);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSignatureNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, SignatureNotificationResult);\n    if (result.value !== 'receivedSignature') {\n      /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */\n      this._subscriptionsAutoDisposedByRpc.add(subscription);\n    }\n    this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{\n      type: 'received'\n    }, result.context] : [{\n      type: 'status',\n      result: result.value\n    }, result.context]);\n  }\n\n  /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */\n  onSignature(signature, callback, commitment) {\n    const args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.\n    );\n\n    const clientSubscriptionId = this._makeSubscription({\n      callback: (notification, context) => {\n        if (notification.type === 'status') {\n          callback(notification.result, context);\n          // Signatures subscriptions are auto-removed by the RPC service\n          // so no need to explicitly send an unsubscribe message.\n          try {\n            this.removeSignatureListener(clientSubscriptionId);\n            // eslint-disable-next-line no-empty\n          } catch (_err) {\n            // Already removed.\n          }\n        }\n      },\n      method: 'signatureSubscribe',\n      unsubscribeMethod: 'signatureUnsubscribe'\n    }, args);\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */\n  onSignatureWithOptions(signature, callback, options) {\n    const _options$commitment = _objectSpread(_objectSpread({}, options), {}, {\n        commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.\n      }),\n      {\n        commitment\n      } = _options$commitment,\n      extra = _objectWithoutProperties(_options$commitment, _excluded4);\n    const args = this._buildArgs([signature], commitment, undefined /* encoding */, extra);\n    const clientSubscriptionId = this._makeSubscription({\n      callback: (notification, context) => {\n        callback(notification, context);\n        // Signatures subscriptions are auto-removed by the RPC service\n        // so no need to explicitly send an unsubscribe message.\n        try {\n          this.removeSignatureListener(clientSubscriptionId);\n          // eslint-disable-next-line no-empty\n        } catch (_err) {\n          // Already removed.\n        }\n      },\n      method: 'signatureSubscribe',\n      unsubscribeMethod: 'signatureUnsubscribe'\n    }, args);\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSignatureListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnRootNotification(notification) {\n    const {\n      result,\n      subscription\n    } = superstruct.create(notification, RootNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */\n  onRootChange(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'rootSubscribe',\n      unsubscribeMethod: 'rootUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeRootChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');\n  }\n}\n\n/**\n * Keypair signer interface\n */\n\n/**\n * An account keypair used for signing transactions.\n */\nclass Keypair {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */\n  constructor(keypair) {\n    this._keypair = void 0;\n    this._keypair = keypair ?? generateKeypair();\n  }\n\n  /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */\n  static generate() {\n    return new Keypair(generateKeypair());\n  }\n\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSecretKey(secretKey, options) {\n    if (secretKey.byteLength !== 64) {\n      throw new Error('bad secret key size');\n    }\n    const publicKey = _sliceInstanceProperty(secretKey).call(secretKey, 32, 64);\n    if (!options || !options.skipValidation) {\n      const privateScalar = _sliceInstanceProperty(secretKey).call(secretKey, 0, 32);\n      const computedPublicKey = getPublicKey(privateScalar);\n      for (let ii = 0; ii < 32; ii++) {\n        if (publicKey[ii] !== computedPublicKey[ii]) {\n          throw new Error('provided secretKey is invalid');\n        }\n      }\n    }\n    return new Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSeed(seed) {\n    const publicKey = getPublicKey(seed);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(seed);\n    secretKey.set(publicKey, 32);\n    return new Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n\n  /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */\n  get publicKey() {\n    return new PublicKey(this._keypair.publicKey);\n  }\n\n  /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */\n  get secretKey() {\n    return new Uint8Array(this._keypair.secretKey);\n  }\n}\n\n/**\n * An enumeration of valid LookupTableInstructionType's\n */\n\n/**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */\nconst LOOKUP_TABLE_INSTRUCTION_LAYOUTS = _Object$freeze({\n  CreateLookupTable: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64('recentSlot'), BufferLayout__namespace.u8('bumpSeed')])\n  },\n  FreezeLookupTable: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  ExtendLookupTable: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), u64(), BufferLayout__namespace.seq(publicKey(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'addresses')])\n  },\n  DeactivateLookupTable: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  CloseLookupTable: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  }\n});\nclass AddressLookupTableInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const index = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [layoutType, layout] of _Object$entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == index) {\n        type = layoutType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Invalid Instruction. Should be a LookupTable Instruction');\n    }\n    return type;\n  }\n  static decodeCreateLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(_keysInstanceProperty(instruction), 4);\n    const {\n      recentSlot\n    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n    return {\n      authority: _keysInstanceProperty(instruction)[1].pubkey,\n      payer: _keysInstanceProperty(instruction)[2].pubkey,\n      recentSlot: Number(recentSlot)\n    };\n  }\n  static decodeExtendLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    if (_keysInstanceProperty(instruction).length < 2) {\n      throw new Error(`invalid instruction; found ${_keysInstanceProperty(instruction).length} keys, expected at least 2`);\n    }\n    const {\n      addresses\n    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n    return {\n      lookupTable: _keysInstanceProperty(instruction)[0].pubkey,\n      authority: _keysInstanceProperty(instruction)[1].pubkey,\n      payer: _keysInstanceProperty(instruction).length > 2 ? _keysInstanceProperty(instruction)[2].pubkey : undefined,\n      addresses: _mapInstanceProperty(addresses).call(addresses, buffer => new PublicKey(buffer))\n    };\n  }\n  static decodeCloseLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(_keysInstanceProperty(instruction), 3);\n    return {\n      lookupTable: _keysInstanceProperty(instruction)[0].pubkey,\n      authority: _keysInstanceProperty(instruction)[1].pubkey,\n      recipient: _keysInstanceProperty(instruction)[2].pubkey\n    };\n  }\n  static decodeFreezeLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(_keysInstanceProperty(instruction), 2);\n    return {\n      lookupTable: _keysInstanceProperty(instruction)[0].pubkey,\n      authority: _keysInstanceProperty(instruction)[1].pubkey\n    };\n  }\n  static decodeDeactivateLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(_keysInstanceProperty(instruction), 2);\n    return {\n      lookupTable: _keysInstanceProperty(instruction)[0].pubkey,\n      authority: _keysInstanceProperty(instruction)[1].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(AddressLookupTableProgram.programId)) {\n      throw new Error('invalid instruction; programId is not AddressLookupTable Program');\n    }\n  }\n  /**\n   * @internal\n   */\n  static checkKeysLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\nclass AddressLookupTableProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n  static createLookupTable(params) {\n    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), bigintBuffer.toBufferLE(BigInt(params.recentSlot), 8)], this.programId);\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n    const data = encodeData(type, {\n      recentSlot: BigInt(params.recentSlot),\n      bumpSeed: bumpSeed\n    });\n    const keys = [{\n      pubkey: lookupTableAddress,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: params.payer,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }];\n    return [new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    }), lookupTableAddress];\n  }\n  static freezeLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static extendLookupTable(params) {\n    var _context77;\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n    const data = encodeData(type, {\n      addresses: _mapInstanceProperty(_context77 = params.addresses).call(_context77, addr => addr.toBytes())\n    });\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (params.payer) {\n      keys.push({\n        pubkey: params.payer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      });\n    }\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static deactivateLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static closeLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: params.recipient,\n      isSigner: false,\n      isWritable: true\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n}\nAddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');\n\n/**\n * Compute Budget Instruction class\n */\nclass ComputeBudgetInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u8('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of _Object$entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestUnits(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      units,\n      additionalFee\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n    return {\n      units,\n      additionalFee\n    };\n  }\n\n  /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestHeapFrame(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      bytes\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n    return {\n      bytes\n    };\n  }\n\n  /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitLimit(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      units\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n    return {\n      units\n    };\n  }\n\n  /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitPrice(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      microLamports\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n    return {\n      microLamports\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(ComputeBudgetProgram.programId)) {\n      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');\n    }\n  }\n}\n\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */\n\n/**\n * Request units instruction params\n */\n\n/**\n * Request heap frame instruction params\n */\n\n/**\n * Set compute unit limit instruction params\n */\n\n/**\n * Set compute unit price instruction params\n */\n\n/**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */\nconst COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = _Object$freeze({\n  RequestUnits: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units'), BufferLayout__namespace.u32('additionalFee')])\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('bytes')])\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), BufferLayout__namespace.u32('units')])\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8('instruction'), u64('microLamports')])\n  }\n});\n\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */\nclass ComputeBudgetProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Compute Budget program\n   */\n\n  /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */\n  static requestUnits(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static requestHeapFrame(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static setComputeUnitLimit(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static setComputeUnitPrice(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n    const data = encodeData(type, {\n      microLamports: BigInt(params.microLamports)\n    });\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n}\nComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n\n/**\n * Params for creating an ed25519 instruction using a public key\n */\n\n/**\n * Params for creating an ed25519 instruction using a private key\n */\n\nconst ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u8('padding'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u16('signatureInstructionIndex'), BufferLayout__namespace.u16('publicKeyOffset'), BufferLayout__namespace.u16('publicKeyInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u16('messageInstructionIndex')]);\nclass Ed25519Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the ed25519 program\n   */\n\n  /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */\n  static createInstructionWithPublicKey(params) {\n    const {\n      publicKey,\n      message,\n      signature,\n      instructionIndex\n    } = params;\n    assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n    assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n    const signatureOffset = publicKeyOffset + publicKey.length;\n    const messageDataOffset = signatureOffset + signature.length;\n    const numSignatures = 1;\n    const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);\n    const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n    : instructionIndex;\n    ED25519_INSTRUCTION_LAYOUT.encode({\n      numSignatures,\n      padding: 0,\n      signatureOffset,\n      signatureInstructionIndex: index,\n      publicKeyOffset,\n      publicKeyInstructionIndex: index,\n      messageDataOffset,\n      messageDataSize: message.length,\n      messageInstructionIndex: index\n    }, instructionData);\n    _fillInstanceProperty(instructionData).call(instructionData, publicKey, publicKeyOffset);\n    _fillInstanceProperty(instructionData).call(instructionData, signature, signatureOffset);\n    _fillInstanceProperty(instructionData).call(instructionData, message, messageDataOffset);\n    return new TransactionInstruction({\n      keys: [],\n      programId: Ed25519Program.programId,\n      data: instructionData\n    });\n  }\n\n  /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPrivateKey(params) {\n    const {\n      privateKey,\n      message,\n      instructionIndex\n    } = params;\n    assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n    try {\n      const keypair = Keypair.fromSecretKey(privateKey);\n      const publicKey = keypair.publicKey.toBytes();\n      const signature = sign(message, keypair.secretKey);\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        instructionIndex\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\nEd25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');\nconst ecdsaSign = (msgHash, privKey) => {\n  const signature = secp256k1.secp256k1.sign(msgHash, privKey);\n  return [signature.toCompactRawBytes(), signature.recovery];\n};\nsecp256k1.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = secp256k1.secp256k1.getPublicKey;\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n\n/**\n * Params for creating an secp256k1 instruction using a public key\n */\n\n/**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */\n\n/**\n * Params for creating an secp256k1 instruction using a private key\n */\n\nconst SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8('numSignatures'), BufferLayout__namespace.u16('signatureOffset'), BufferLayout__namespace.u8('signatureInstructionIndex'), BufferLayout__namespace.u16('ethAddressOffset'), BufferLayout__namespace.u8('ethAddressInstructionIndex'), BufferLayout__namespace.u16('messageDataOffset'), BufferLayout__namespace.u16('messageDataSize'), BufferLayout__namespace.u8('messageInstructionIndex'), BufferLayout__namespace.blob(20, 'ethAddress'), BufferLayout__namespace.blob(64, 'signature'), BufferLayout__namespace.u8('recoveryId')]);\nclass Secp256k1Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the secp256k1 program\n   */\n\n  /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */\n  static publicKeyToEthAddress(publicKey) {\n    assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n    try {\n      var _context78;\n      return _sliceInstanceProperty(_context78 = buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey)))).call(_context78, -ETHEREUM_ADDRESS_BYTES);\n    } catch (error) {\n      throw new Error(`Error constructing Ethereum address: ${error}`);\n    }\n  }\n\n  /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPublicKey(params) {\n    const {\n      publicKey,\n      message,\n      signature,\n      recoveryId,\n      instructionIndex\n    } = params;\n    return Secp256k1Program.createInstructionWithEthAddress({\n      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n      message,\n      signature,\n      recoveryId,\n      instructionIndex\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */\n  static createInstructionWithEthAddress(params) {\n    const {\n      ethAddress: rawAddress,\n      message,\n      signature,\n      recoveryId,\n      instructionIndex = 0\n    } = params;\n    let ethAddress;\n    if (typeof rawAddress === 'string') {\n      if (_startsWithInstanceProperty(rawAddress).call(rawAddress, '0x')) {\n        ethAddress = buffer.Buffer.from(rawAddress.substr(2), 'hex');\n      } else {\n        ethAddress = buffer.Buffer.from(rawAddress, 'hex');\n      }\n    } else {\n      ethAddress = rawAddress;\n    }\n    assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    const ethAddressOffset = dataStart;\n    const signatureOffset = dataStart + ethAddress.length;\n    const messageDataOffset = signatureOffset + signature.length + 1;\n    const numSignatures = 1;\n    const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n    SECP256K1_INSTRUCTION_LAYOUT.encode({\n      numSignatures,\n      signatureOffset,\n      signatureInstructionIndex: instructionIndex,\n      ethAddressOffset,\n      ethAddressInstructionIndex: instructionIndex,\n      messageDataOffset,\n      messageDataSize: message.length,\n      messageInstructionIndex: instructionIndex,\n      signature: toBuffer(signature),\n      ethAddress: toBuffer(ethAddress),\n      recoveryId\n    }, instructionData);\n    _fillInstanceProperty(instructionData).call(instructionData, toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n    return new TransactionInstruction({\n      keys: [],\n      programId: Secp256k1Program.programId,\n      data: instructionData\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */\n  static createInstructionWithPrivateKey(params) {\n    const {\n      privateKey: pkey,\n      message,\n      instructionIndex\n    } = params;\n    assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n    try {\n      var _context79;\n      const privateKey = toBuffer(pkey);\n      const publicKey = _sliceInstanceProperty(_context79 = publicKeyCreate(privateKey, false /* isCompressed */)).call(_context79, 1); // throw away leading byte\n      const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));\n      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        recoveryId,\n        instructionIndex\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\nSecp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');\nvar _Lockup;\n\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */\nconst STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');\n\n/**\n * Stake account authority info\n */\nclass Authorized {\n  /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */\n  constructor(staker, withdrawer) {\n    /** stake authority */\n    this.staker = void 0;\n    /** withdraw authority */\n    this.withdrawer = void 0;\n    this.staker = staker;\n    this.withdrawer = withdrawer;\n  }\n}\n/**\n * Stake account lockup info\n */\nclass Lockup {\n  /**\n   * Create a new Lockup object\n   */\n  constructor(unixTimestamp, epoch, custodian) {\n    /** Unix timestamp of lockup expiration */\n    this.unixTimestamp = void 0;\n    /** Epoch of lockup expiration */\n    this.epoch = void 0;\n    /** Lockup custodian authority */\n    this.custodian = void 0;\n    this.unixTimestamp = unixTimestamp;\n    this.epoch = epoch;\n    this.custodian = custodian;\n  }\n\n  /**\n   * Default, inactive Lockup value\n   */\n}\n\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */\n/**\n * Create stake account with seed transaction params\n */\n/**\n * Initialize stake instruction params\n */\n/**\n * Delegate stake instruction params\n */\n/**\n * Authorize stake instruction params\n */\n/**\n * Authorize stake instruction params using a derived key\n */\n/**\n * Split stake instruction params\n */\n/**\n * Split with seed transaction params\n */\n/**\n * Withdraw stake instruction params\n */\n/**\n * Deactivate stake instruction params\n */\n/**\n * Merge stake instruction params\n */\n/**\n * Stake Instruction class\n */\nclass StakeInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of _Object$entries(STAKE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a StakeInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */\n  static decodeInitialize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 2);\n    const {\n      authorized,\n      lockup\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n    return {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n      lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n    };\n  }\n\n  /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */\n  static decodeDelegate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 6);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n    return {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      votePubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[5].pubkey\n    };\n  }\n\n  /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    const {\n      newAuthorized,\n      stakeAuthorizationType\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n    const o = {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType\n      }\n    };\n    if (_keysInstanceProperty(instruction).length > 3) {\n      o.custodianPubkey = _keysInstanceProperty(instruction)[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 2);\n    const {\n      newAuthorized,\n      stakeAuthorizationType,\n      authoritySeed,\n      authorityOwner\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n    const o = {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorityBase: _keysInstanceProperty(instruction)[1].pubkey,\n      authoritySeed: authoritySeed,\n      authorityOwner: new PublicKey(authorityOwner),\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType\n      }\n    };\n    if (_keysInstanceProperty(instruction).length > 3) {\n      o.custodianPubkey = _keysInstanceProperty(instruction)[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */\n  static decodeSplit(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    const {\n      lamports\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n    return {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      splitStakePubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[2].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */\n  static decodeMerge(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n    return {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      sourceStakePubKey: _keysInstanceProperty(instruction)[1].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[4].pubkey\n    };\n  }\n\n  /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 5);\n    const {\n      lamports\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n    const o = {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      toPubkey: _keysInstanceProperty(instruction)[1].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[4].pubkey,\n      lamports\n    };\n    if (_keysInstanceProperty(instruction).length > 5) {\n      o.custodianPubkey = _keysInstanceProperty(instruction)[5].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */\n  static decodeDeactivate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n    return {\n      stakePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[2].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(StakeProgram.programId)) {\n      throw new Error('invalid instruction; programId is not StakeProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid StakeInstructionType's\n */\n\n/**\n * An enumeration of valid stake InstructionType's\n * @internal\n */\nconst STAKE_INSTRUCTION_LAYOUTS = _Object$freeze({\n  Initialize: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), authorized(), lockup()])\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType')])\n  },\n  Delegate: {\n    index: 2,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  Split: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  Withdraw: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  Deactivate: {\n    index: 5,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  Merge: {\n    index: 7,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])\n  }\n});\n\n/**\n * Stake authorization type\n */\n\n/**\n * An enumeration of valid StakeAuthorizationLayout's\n */\nconst StakeAuthorizationLayout = _Object$freeze({\n  Staker: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Stake program\n */\nclass StakeProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Stake program\n   */\n\n  /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */\n  static initialize(params) {\n    const {\n      stakePubkey,\n      authorized,\n      lockup: maybeLockup\n    } = params;\n    const lockup = maybeLockup || Lockup.default;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n    const data = encodeData(type, {\n      authorized: {\n        staker: toBuffer(authorized.staker.toBuffer()),\n        withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n      },\n      lockup: {\n        unixTimestamp: lockup.unixTimestamp,\n        epoch: lockup.epoch,\n        custodian: toBuffer(lockup.custodian.toBuffer())\n      }\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */\n  static createAccountWithSeed(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccountWithSeed({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.stakePubkey,\n      basePubkey: params.basePubkey,\n      seed: params.seed,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    const {\n      stakePubkey,\n      authorized,\n      lockup\n    } = params;\n    return transaction.add(this.initialize({\n      stakePubkey,\n      authorized,\n      lockup\n    }));\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account\n   */\n  static createAccount(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.stakePubkey,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    const {\n      stakePubkey,\n      authorized,\n      lockup\n    } = params;\n    return transaction.add(this.initialize({\n      stakePubkey,\n      authorized,\n      lockup\n    }));\n  }\n\n  /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */\n  static delegate(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      votePubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: STAKE_CONFIG_ID,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorize(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorizeWithSeed(params) {\n    const {\n      stakePubkey,\n      authorityBase,\n      authoritySeed,\n      authorityOwner,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index,\n      authoritySeed: authoritySeed,\n      authorityOwner: toBuffer(authorityOwner.toBuffer())\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorityBase,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * @internal\n   */\n  static splitInstruction(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      lamports\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n    const data = encodeData(type, {\n      lamports\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: splitStakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */\n  static split(params,\n  // Compute the cost of allocating the new stake account in lamports\n  rentExemptReserve) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.authorizedPubkey,\n      newAccountPubkey: params.splitStakePubkey,\n      lamports: rentExemptReserve,\n      space: this.space,\n      programId: this.programId\n    }));\n    return transaction.add(this.splitInstruction(params));\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */\n  static splitWithSeed(params,\n  // If this stake account is new, compute the cost of allocating it in lamports\n  rentExemptReserve) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      basePubkey,\n      seed,\n      lamports\n    } = params;\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.allocate({\n      accountPubkey: splitStakePubkey,\n      basePubkey,\n      seed,\n      space: this.space,\n      programId: this.programId\n    }));\n    if (rentExemptReserve && rentExemptReserve > 0) {\n      transaction.add(SystemProgram.transfer({\n        fromPubkey: params.authorizedPubkey,\n        toPubkey: splitStakePubkey,\n        lamports: rentExemptReserve\n      }));\n    }\n    return transaction.add(this.splitInstruction({\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      lamports\n    }));\n  }\n\n  /**\n   * Generate a Transaction that merges Stake accounts.\n   */\n  static merge(params) {\n    const {\n      stakePubkey,\n      sourceStakePubKey,\n      authorizedPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: sourceStakePubKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */\n  static withdraw(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      toPubkey,\n      lamports,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {\n      lamports\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: toPubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */\n  static deactivate(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n}\nStakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */\nStakeProgram.space = 200;\n\n/**\n * Vote account info\n */\nclass VoteInit {\n  /** [0, 100] */\n\n  constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {\n    this.nodePubkey = void 0;\n    this.authorizedVoter = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.nodePubkey = nodePubkey;\n    this.authorizedVoter = authorizedVoter;\n    this.authorizedWithdrawer = authorizedWithdrawer;\n    this.commission = commission;\n  }\n}\n\n/**\n * Create vote account transaction params\n */\n\n/**\n * InitializeAccount instruction params\n */\n\n/**\n * Authorize instruction params\n */\n\n/**\n * AuthorizeWithSeed instruction params\n */\n\n/**\n * Withdraw from vote account transaction params\n */\n\n/**\n * Update validator identity (node pubkey) vote account instruction params.\n */\n\n/**\n * Vote Instruction class\n */\nclass VoteInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = BufferLayout__namespace.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of _Object$entries(VOTE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a VoteInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */\n  static decodeInitializeAccount(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 4);\n    const {\n      voteInit\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n    return {\n      votePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      nodePubkey: _keysInstanceProperty(instruction)[3].pubkey,\n      voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    const {\n      newAuthorized,\n      voteAuthorizationType\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n    return {\n      votePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorizedPubkey: _keysInstanceProperty(instruction)[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType\n      }\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    const {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey,\n        currentAuthorityDerivedKeySeed,\n        newAuthorized,\n        voteAuthorizationType\n      }\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n    return {\n      currentAuthorityDerivedKeyBasePubkey: _keysInstanceProperty(instruction)[2].pubkey,\n      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n      currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType\n      },\n      votePubkey: _keysInstanceProperty(instruction)[0].pubkey\n    };\n  }\n\n  /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(_keysInstanceProperty(instruction), 3);\n    const {\n      lamports\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n    return {\n      votePubkey: _keysInstanceProperty(instruction)[0].pubkey,\n      authorizedWithdrawerPubkey: _keysInstanceProperty(instruction)[2].pubkey,\n      lamports,\n      toPubkey: _keysInstanceProperty(instruction)[1].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(VoteProgram.programId)) {\n      throw new Error('invalid instruction; programId is not VoteProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid VoteInstructionType's\n */\n\n/** @internal */\n\nconst VOTE_INSTRUCTION_LAYOUTS = _Object$freeze({\n  InitializeAccount: {\n    index: 0,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteInit()])\n  },\n  Authorize: {\n    index: 1,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), publicKey('newAuthorized'), BufferLayout__namespace.u32('voteAuthorizationType')])\n  },\n  Withdraw: {\n    index: 3,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), BufferLayout__namespace.ns64('lamports')])\n  },\n  UpdateValidatorIdentity: {\n    index: 4,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 10,\n    layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32('instruction'), voteAuthorizeWithSeedArgs()])\n  }\n});\n\n/**\n * VoteAuthorize type\n */\n\n/**\n * An enumeration of valid VoteAuthorization layouts.\n */\nconst VoteAuthorizationLayout = _Object$freeze({\n  Voter: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Vote program\n */\nclass VoteProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Vote program\n   */\n\n  /**\n   * Generate an Initialize instruction.\n   */\n  static initializeAccount(params) {\n    const {\n      votePubkey,\n      nodePubkey,\n      voteInit\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n    const data = encodeData(type, {\n      voteInit: {\n        nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n        authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n        authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n        commission: voteInit.commission\n      }\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: nodePubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction that creates a new Vote account.\n   */\n  static createAccount(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.votePubkey,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    return transaction.add(this.initializeAccount({\n      votePubkey: params.votePubkey,\n      nodePubkey: params.voteInit.nodePubkey,\n      voteInit: params.voteInit\n    }));\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */\n  static authorize(params) {\n    const {\n      votePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      voteAuthorizationType\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      voteAuthorizationType: voteAuthorizationType.index\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */\n  static authorizeWithSeed(params) {\n    const {\n      currentAuthorityDerivedKeyBasePubkey,\n      currentAuthorityDerivedKeyOwnerPubkey,\n      currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey,\n      voteAuthorizationType,\n      votePubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        voteAuthorizationType: voteAuthorizationType.index\n      }\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: currentAuthorityDerivedKeyBasePubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw from a Vote account.\n   */\n  static withdraw(params) {\n    const {\n      votePubkey,\n      authorizedWithdrawerPubkey,\n      lamports,\n      toPubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {\n      lamports\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: toPubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorizedWithdrawerPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */\n  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n      throw new Error('Withdraw will leave vote account with insufficient funds.');\n    }\n    return VoteProgram.withdraw(params);\n  }\n\n  /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */\n  static updateValidatorIdentity(params) {\n    const {\n      votePubkey,\n      authorizedWithdrawerPubkey,\n      nodePubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: nodePubkey,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: authorizedWithdrawerPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n}\nVoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */\nVoteProgram.space = 3762;\nconst VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');\n\n/**\n * @internal\n */\n\n/**\n * Info used to identity validators.\n */\n\nconst InfoString = superstruct.type({\n  name: superstruct.string(),\n  website: superstruct.optional(superstruct.string()),\n  details: superstruct.optional(superstruct.string()),\n  iconUrl: superstruct.optional(superstruct.string()),\n  keybaseUsername: superstruct.optional(superstruct.string())\n});\n\n/**\n * ValidatorInfo class\n */\nclass ValidatorInfo {\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  constructor(key, info) {\n    /**\n     * validator public key\n     */\n    this.key = void 0;\n    /**\n     * validator information\n     */\n    this.info = void 0;\n    this.key = key;\n    this.info = info;\n  }\n\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n  static fromConfigData(buffer$1) {\n    let byteArray = [...buffer$1];\n    const configKeyCount = decodeLength(byteArray);\n    if (configKeyCount !== 2) return null;\n    const configKeys = [];\n    for (let i = 0; i < 2; i++) {\n      const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n      const isSigner = guardedShift(byteArray) === 1;\n      configKeys.push({\n        publicKey,\n        isSigner\n      });\n    }\n    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n      if (configKeys[1].isSigner) {\n        const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));\n        const info = JSON.parse(rawInfo);\n        superstruct.assert(info, InfoString);\n        return new ValidatorInfo(configKeys[1].publicKey, info);\n      }\n    }\n    return null;\n  }\n}\nconst VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');\n\n/**\n * History of how many credits earned by the end of each epoch\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */\nconst VoteAccountLayout = BufferLayout__namespace.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), BufferLayout__namespace.u8('commission'), BufferLayout__namespace.nu64(),\n// votes.length\nBufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.u32('confirmationCount')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'votes'), BufferLayout__namespace.u8('rootSlotValid'), BufferLayout__namespace.nu64('rootSlot'), BufferLayout__namespace.nu64(),\n// authorizedVoters.length\nBufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), publicKey('authorizedVoter')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'authorizedVoters'), BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey('authorizedPubkey'), BufferLayout__namespace.nu64('epochOfLastAuthorizedSwitch'), BufferLayout__namespace.nu64('targetEpoch')]), 32, 'buf'), BufferLayout__namespace.nu64('idx'), BufferLayout__namespace.u8('isEmpty')], 'priorVoters'), BufferLayout__namespace.nu64(),\n// epochCredits.length\nBufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64('epoch'), BufferLayout__namespace.nu64('credits'), BufferLayout__namespace.nu64('prevCredits')]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), 'epochCredits'), BufferLayout__namespace.struct([BufferLayout__namespace.nu64('slot'), BufferLayout__namespace.nu64('timestamp')], 'lastTimestamp')]);\n/**\n * VoteAccount class\n */\nclass VoteAccount {\n  /**\n   * @internal\n   */\n  constructor(args) {\n    this.nodePubkey = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.rootSlot = void 0;\n    this.votes = void 0;\n    this.authorizedVoters = void 0;\n    this.priorVoters = void 0;\n    this.epochCredits = void 0;\n    this.lastTimestamp = void 0;\n    this.nodePubkey = args.nodePubkey;\n    this.authorizedWithdrawer = args.authorizedWithdrawer;\n    this.commission = args.commission;\n    this.rootSlot = args.rootSlot;\n    this.votes = args.votes;\n    this.authorizedVoters = args.authorizedVoters;\n    this.priorVoters = args.priorVoters;\n    this.epochCredits = args.epochCredits;\n    this.lastTimestamp = args.lastTimestamp;\n  }\n\n  /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */\n  static fromAccountData(buffer) {\n    var _context80;\n    const versionOffset = 4;\n    const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n    let rootSlot = va.rootSlot;\n    if (!va.rootSlotValid) {\n      rootSlot = null;\n    }\n    return new VoteAccount({\n      nodePubkey: new PublicKey(va.nodePubkey),\n      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n      commission: va.commission,\n      votes: va.votes,\n      rootSlot,\n      authorizedVoters: _mapInstanceProperty(_context80 = va.authorizedVoters).call(_context80, parseAuthorizedVoter),\n      priorVoters: getPriorVoters(va.priorVoters),\n      epochCredits: va.epochCredits,\n      lastTimestamp: va.lastTimestamp\n    });\n  }\n}\nfunction parseAuthorizedVoter({\n  authorizedVoter,\n  epoch\n}) {\n  return {\n    epoch,\n    authorizedVoter: new PublicKey(authorizedVoter)\n  };\n}\nfunction parsePriorVoters({\n  authorizedPubkey,\n  epochOfLastAuthorizedSwitch,\n  targetEpoch\n}) {\n  return {\n    authorizedPubkey: new PublicKey(authorizedPubkey),\n    epochOfLastAuthorizedSwitch,\n    targetEpoch\n  };\n}\nfunction getPriorVoters({\n  buf,\n  idx,\n  isEmpty\n}) {\n  var _context81, _context82;\n  if (isEmpty) {\n    return [];\n  }\n  return [..._mapInstanceProperty(_context81 = _sliceInstanceProperty(buf).call(buf, idx + 1)).call(_context81, parsePriorVoters), ..._mapInstanceProperty(_context82 = _sliceInstanceProperty(buf).call(buf, 0, idx)).call(_context82, parsePriorVoters)];\n}\nconst endpoint = {\n  http: {\n    devnet: 'http://api.devnet.solana.com',\n    testnet: 'http://api.testnet.solana.com',\n    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'\n  },\n  https: {\n    devnet: 'https://api.devnet.solana.com',\n    testnet: 'https://api.testnet.solana.com',\n    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'\n  }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */\nfunction clusterApiUrl(cluster, tls) {\n  const key = tls === false ? 'http' : 'https';\n  if (!cluster) {\n    return endpoint[key]['devnet'];\n  }\n  const url = endpoint[key][cluster];\n  if (!url) {\n    throw new Error(`Unknown ${key} cluster: ${cluster}`);\n  }\n  return url;\n}\n\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\n\n/**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */\n// eslint-disable-next-line no-redeclare\n\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n  let confirmationStrategy;\n  let options;\n  if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {\n    confirmationStrategy = confirmationStrategyOrConfirmOptions;\n    options = maybeConfirmOptions;\n  } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {\n    confirmationStrategy = confirmationStrategyOrConfirmOptions;\n    options = maybeConfirmOptions;\n  } else {\n    options = confirmationStrategyOrConfirmOptions;\n  }\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    minContextSlot: options.minContextSlot\n  };\n  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n  const commitment = options && options.commitment;\n  const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n  const status = (await confirmationPromise).value;\n  if (status.err) {\n    if (signature != null) {\n      throw new SendTransactionError({\n        action: sendOptions?.skipPreflight ? 'send' : 'simulate',\n        signature: signature,\n        transactionMessage: `Status: (${_JSON$stringify(status)})`\n      });\n    }\n    throw new Error(`Raw transaction ${signature} failed (${_JSON$stringify(status)})`);\n  }\n  return signature;\n}\n\n/**\n * There are 1-billion lamports in one SOL\n */\nconst LAMPORTS_PER_SOL = 1000000000;\nexports.Account = Account;\nexports.AddressLookupTableAccount = AddressLookupTableAccount;\nexports.AddressLookupTableInstruction = AddressLookupTableInstruction;\nexports.AddressLookupTableProgram = AddressLookupTableProgram;\nexports.Authorized = Authorized;\nexports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS;\nexports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;\nexports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;\nexports.BpfLoader = BpfLoader;\nexports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS;\nexports.ComputeBudgetInstruction = ComputeBudgetInstruction;\nexports.ComputeBudgetProgram = ComputeBudgetProgram;\nexports.Connection = Connection;\nexports.Ed25519Program = Ed25519Program;\nexports.Enum = Enum;\nexports.EpochSchedule = EpochSchedule;\nexports.FeeCalculatorLayout = FeeCalculatorLayout;\nexports.Keypair = Keypair;\nexports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;\nexports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS;\nexports.Loader = Loader;\nexports.Lockup = Lockup;\nexports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;\nexports.Message = Message;\nexports.MessageAccountKeys = MessageAccountKeys;\nexports.MessageV0 = MessageV0;\nexports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH;\nexports.NonceAccount = NonceAccount;\nexports.PACKET_DATA_SIZE = PACKET_DATA_SIZE;\nexports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH;\nexports.PublicKey = PublicKey;\nexports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES;\nexports.SOLANA_SCHEMA = SOLANA_SCHEMA;\nexports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;\nexports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;\nexports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;\nexports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY;\nexports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY;\nexports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;\nexports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY;\nexports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY;\nexports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;\nexports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY;\nexports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY;\nexports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;\nexports.Secp256k1Program = Secp256k1Program;\nexports.SendTransactionError = SendTransactionError;\nexports.SolanaJSONRPCError = SolanaJSONRPCError;\nexports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;\nexports.StakeAuthorizationLayout = StakeAuthorizationLayout;\nexports.StakeInstruction = StakeInstruction;\nexports.StakeProgram = StakeProgram;\nexports.Struct = Struct;\nexports.SystemInstruction = SystemInstruction;\nexports.SystemProgram = SystemProgram;\nexports.Transaction = Transaction;\nexports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError;\nexports.TransactionExpiredNonceInvalidError = TransactionExpiredNonceInvalidError;\nexports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError;\nexports.TransactionInstruction = TransactionInstruction;\nexports.TransactionMessage = TransactionMessage;\nexports.TransactionStatus = TransactionStatus;\nexports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;\nexports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK;\nexports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;\nexports.ValidatorInfo = ValidatorInfo;\nexports.VersionedMessage = VersionedMessage;\nexports.VersionedTransaction = VersionedTransaction;\nexports.VoteAccount = VoteAccount;\nexports.VoteAuthorizationLayout = VoteAuthorizationLayout;\nexports.VoteInit = VoteInit;\nexports.VoteInstruction = VoteInstruction;\nexports.VoteProgram = VoteProgram;\nexports.clusterApiUrl = clusterApiUrl;\nexports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction;\nexports.sendAndConfirmTransaction = sendAndConfirmTransaction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bzb2xhbmErd2ViMy5qc0AxLjk4LjBfYnVmZmVydXRpbEA0LjAuOV9lbmNvZGluZ0AwLjEuMTNfdXRmLTgtdmFsaWRhdGVANS4wLjEwL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbGliL2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFBQSxJQUFBQSw2QkFBQSxHQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlDQUFBLEdBQUFELG1CQUFBO0FBQUEsSUFBQUUsd0JBQUEsR0FBQUYsbUJBQUE7QUFBQSxJQUFBRyx3QkFBQSxHQUFBSCxtQkFBQTtBQUFBLElBQUFJLGVBQUEsR0FBQUosbUJBQUE7QUFBQSxJQUFBSyxjQUFBLEdBQUFMLG1CQUFBO0FBQUEsSUFBQU0sd0JBQUEsR0FBQU4sbUJBQUE7QUFBQSxJQUFBTyxZQUFBLEdBQUFQLG1CQUFBO0FBQUEsSUFBQVEsZ0NBQUEsR0FBQVIsbUJBQUE7QUFBQSxJQUFBUyxzQkFBQSxHQUFBVCxtQkFBQTtBQUFBLElBQUFVLGNBQUEsR0FBQVYsbUJBQUE7QUFBQSxJQUFBVyxzQkFBQSxHQUFBWCxtQkFBQTtBQUFBLElBQUFZLGNBQUEsR0FBQVosbUJBQUE7QUFBQSxJQUFBYSxvQkFBQSxHQUFBYixtQkFBQTtBQUFBLElBQUFjLElBQUEsR0FBQWQsbUJBQUE7QUFBQSxJQUFBZSxtQkFBQSxHQUFBZixtQkFBQTtBQUFBLElBQUFnQix1QkFBQSxHQUFBaEIsbUJBQUE7QUFBQSxJQUFBaUIscUJBQUEsR0FBQWpCLG1CQUFBO0FBQUEsSUFBQWtCLHFCQUFBLEdBQUFsQixtQkFBQTtBQUFBLElBQUFtQixxQkFBQSxHQUFBbkIsbUJBQUE7QUFBQSxJQUFBb0IsY0FBQSxHQUFBcEIsbUJBQUE7QUFBQSxJQUFBcUIsd0JBQUEsR0FBQXJCLG1CQUFBO0FBQUEsSUFBQXNCLHVCQUFBLEdBQUF0QixtQkFBQTtBQUFBLElBQUF1QiwwQkFBQSxHQUFBdkIsbUJBQUE7QUFBQSxJQUFB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Q3JDdUQsbUJBQW1CLEdBQUdsUyxXQUFXO0FBQ2pDa1Msa0RBQWtELEdBQUczZiwwQ0FBMEM7QUFDL0YyZiwyQ0FBMkMsR0FBR3JmLG1DQUFtQztBQUNqRnFmLHNDQUFzQyxHQUFHeGYsOEJBQThCO0FBQ3ZFd2YsOEJBQThCLEdBQUdyUyxzQkFBc0I7QUFDdkRxUywwQkFBMEIsR0FBRzFNLGtCQUFrQjtBQUMvQzBNLHlCQUF5QixHQUFHdlMsaUJBQWlCO0FBQzdDdVMsMEJBQTBCLEdBQUdxNEIsa0JBQWtCO0FBQy9DcjRCLDJCQUEyQixHQUFHN2YsbUJBQW1CO0FBQ2pENmYsdUJBQXVCLEdBQUdpNUIsZUFBZTtBQUN6Q2o1QixxQkFBcUIsR0FBRzI0QixhQUFhO0FBQ3JDMzRCLHdCQUF3QixHQUFHelMsZ0JBQWdCO0FBQzNDeVMsNEJBQTRCLEdBQUdyTSxvQkFBb0I7QUFDbkRxTSxtQkFBbUIsR0FBR201QixXQUFXO0FBQ2pDbjVCLCtCQUErQixHQUFHODNCLHVCQUF1QjtBQUN6RDkzQixnQkFBZ0IsR0FBR2czQixRQUFRO0FBQzNCaDNCLHVCQUF1QixHQUFHbTNCLGVBQWU7QUFDekNuM0IsbUJBQW1CLEdBQUc0M0IsV0FBVztBQUNqQzUzQixxQkFBcUIsR0FBR3k2QixhQUFhO0FBQ3JDejZCLG9DQUFvQyxHQUFHNDZCLDRCQUE0QjtBQUNuRTU2QixpQ0FBaUMsR0FBR3JJLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmFwcC8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYSt3ZWIzLmpzQDEuOTguMF9idWZmZXJ1dGlsQDQuMC45X2VuY29kaW5nQDAuMS4xM191dGYtOC12YWxpZGF0ZUA1LjAuMTAvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguY2pzLmpzPzk4MmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgZWQyNTUxOSA9IHJlcXVpcmUoJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOScpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBiczU4ID0gcmVxdWlyZSgnYnM1OCcpO1xudmFyIHNoYTI1NiA9IHJlcXVpcmUoJ0Bub2JsZS9oYXNoZXMvc2hhMjU2Jyk7XG52YXIgYm9yc2ggPSByZXF1aXJlKCdib3JzaCcpO1xudmFyIEJ1ZmZlckxheW91dCA9IHJlcXVpcmUoJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCcpO1xudmFyIGJpZ2ludEJ1ZmZlciA9IHJlcXVpcmUoJ2JpZ2ludC1idWZmZXInKTtcbnZhciByZXF1aXJlJCQwID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHJlcXVpcmUkJDAkMSA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciByZXF1aXJlJCQwJDIgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHN1cGVyc3RydWN0ID0gcmVxdWlyZSgnc3VwZXJzdHJ1Y3QnKTtcbnZhciBScGNDbGllbnQgPSByZXF1aXJlKCdqYXlzb24vbGliL2NsaWVudC9icm93c2VyJyk7XG52YXIgbm9kZUZldGNoID0gcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xudmFyIHJwY1dlYnNvY2tldHMgPSByZXF1aXJlKCdycGMtd2Vic29ja2V0cycpO1xudmFyIHNoYTMgPSByZXF1aXJlKCdAbm9ibGUvaGFzaGVzL3NoYTMnKTtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRDb21wYXQgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlQ29tcGF0KGUpIHtcbiAgaWYgKGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG4uZGVmYXVsdCA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgQk5fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KEJOKTtcbnZhciBiczU4X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChiczU4KTtcbnZhciBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZUNvbXBhdChCdWZmZXJMYXlvdXQpO1xudmFyIHJlcXVpcmUkJDBfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHJlcXVpcmUkJDApO1xudmFyIHJlcXVpcmUkJDBfX2RlZmF1bHQkMSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQocmVxdWlyZSQkMCQxKTtcbnZhciByZXF1aXJlJCQwX19kZWZhdWx0JDIgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHJlcXVpcmUkJDAkMik7XG52YXIgUnBjQ2xpZW50X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChScGNDbGllbnQpO1xudmFyIG5vZGVGZXRjaF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlQ29tcGF0KG5vZGVGZXRjaCk7XG5cbi8qKlxuICogQSA2NCBieXRlIHNlY3JldCBrZXksIHRoZSBmaXJzdCAzMiBieXRlcyBvZiB3aGljaCBpcyB0aGVcbiAqIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAqIFJlYWQgbW9yZTogaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dhcm5lci8yMDExLzExLzI5L2VkMjU1MTkta2V5cy9cbiAqL1xuXG4vKipcbiAqIEVkMjU1MTkgS2V5cGFpclxuICovXG5cbmNvbnN0IGdlbmVyYXRlUHJpdmF0ZUtleSA9IGVkMjU1MTkuZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xuY29uc3QgZ2VuZXJhdGVLZXlwYWlyID0gKCkgPT4ge1xuICBjb25zdCBwcml2YXRlU2NhbGFyID0gZWQyNTUxOS5lZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByaXZhdGVTY2FsYXIpO1xuICBjb25zdCBzZWNyZXRLZXkgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHNlY3JldEtleS5zZXQocHJpdmF0ZVNjYWxhcik7XG4gIHNlY3JldEtleS5zZXQocHVibGljS2V5LCAzMik7XG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5LFxuICAgIHNlY3JldEtleVxuICB9O1xufTtcbmNvbnN0IGdldFB1YmxpY0tleSA9IGVkMjU1MTkuZWQyNTUxOS5nZXRQdWJsaWNLZXk7XG5mdW5jdGlvbiBpc09uQ3VydmUocHVibGljS2V5KSB7XG4gIHRyeSB7XG4gICAgZWQyNTUxOS5lZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IHNpZ24gPSAobWVzc2FnZSwgc2VjcmV0S2V5KSA9PiBlZDI1NTE5LmVkMjU1MTkuc2lnbihtZXNzYWdlLCBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpKTtcbmNvbnN0IHZlcmlmeSA9IGVkMjU1MTkuZWQyNTUxOS52ZXJpZnk7XG5cbmNvbnN0IHRvQnVmZmVyID0gYXJyID0+IHtcbiAgaWYgKGJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAoYXJyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBidWZmZXIuQnVmZmVyLmZyb20oYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVmZmVyLkJ1ZmZlci5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8vIENsYXNzIHdyYXBwaW5nIGEgcGxhaW4gb2JqZWN0XG5jbGFzcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgfVxuICBlbmNvZGUoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5CdWZmZXIuZnJvbShib3JzaC5zZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcykpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGUoZGF0YSkge1xuICAgIHJldHVybiBib3JzaC5kZXNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlVW5jaGVja2VkKGRhdGEpIHtcbiAgICByZXR1cm4gYm9yc2guZGVzZXJpYWxpemVVbmNoZWNrZWQoU09MQU5BX1NDSEVNQSwgdGhpcywgZGF0YSk7XG4gIH1cbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIGEgUnVzdC1jb21wYXRpYmxlIGVudW0sIHNpbmNlIGVudW1zIGFyZSBvbmx5IHN0cmluZ3Mgb3Jcbi8vIG51bWJlcnMgaW4gcHVyZSBKU1xuY2xhc3MgRW51bSBleHRlbmRzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBzdXBlcihwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmVudW0gPSAnJztcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0gY2FuIG9ubHkgdGFrZSBzaW5nbGUgdmFsdWUnKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykubWFwKGtleSA9PiB7XG4gICAgICB0aGlzLmVudW0gPSBrZXk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFNPTEFOQV9TQ0hFTUEgPSBuZXcgTWFwKCk7XG5cbnZhciBfUHVibGljS2V5O1xuXG4vKipcbiAqIE1heGltdW0gbGVuZ3RoIG9mIGRlcml2ZWQgcHVia2V5IHNlZWRcbiAqL1xuY29uc3QgTUFYX1NFRURfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogU2l6ZSBvZiBwdWJsaWMga2V5IGluIGJ5dGVzXG4gKi9cbmNvbnN0IFBVQkxJQ19LRVlfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogVmFsdWUgdG8gYmUgY29udmVydGVkIGludG8gcHVibGljIGtleVxuICovXG5cbi8qKlxuICogSlNPTiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgUHVibGljS2V5IGNsYXNzXG4gKi9cblxuZnVuY3Rpb24gaXNQdWJsaWNLZXlEYXRhKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5fYm4gIT09IHVuZGVmaW5lZDtcbn1cblxuLy8gbG9jYWwgY291bnRlciB1c2VkIGJ5IFB1YmxpY0tleS51bmlxdWUoKVxubGV0IHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgPSAxO1xuXG4vKipcbiAqIEEgcHVibGljIGtleVxuICovXG5jbGFzcyBQdWJsaWNLZXkgZXh0ZW5kcyBTdHJ1Y3Qge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFB1YmxpY0tleSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIGVkMjU1MTkgcHVibGljIGtleSBhcyBidWZmZXIgb3IgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2JuID0gdm9pZCAwO1xuICAgIGlmIChpc1B1YmxpY0tleURhdGEodmFsdWUpKSB7XG4gICAgICB0aGlzLl9ibiA9IHZhbHVlLl9ibjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gYXNzdW1lIGJhc2UgNTggZW5jb2RpbmcgYnkgZGVmYXVsdFxuICAgICAgICBjb25zdCBkZWNvZGVkID0gYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmRlY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkZWNvZGVkLmxlbmd0aCAhPSBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm4gPSBuZXcgQk5fX2RlZmF1bHQuZGVmYXVsdChkZWNvZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JuID0gbmV3IEJOX19kZWZhdWx0LmRlZmF1bHQodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2JuLmJ5dGVMZW5ndGgoKSA+IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB1bmlxdWUgUHVibGljS2V5IGZvciB0ZXN0cyBhbmQgYmVuY2htYXJrcyB1c2luZyBhIGNvdW50ZXJcbiAgICovXG4gIHN0YXRpYyB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5ID0gbmV3IFB1YmxpY0tleSh1bmlxdWVQdWJsaWNLZXlDb3VudGVyKTtcbiAgICB1bmlxdWVQdWJsaWNLZXlDb3VudGVyICs9IDE7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoa2V5LnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcHVibGljIGtleSB2YWx1ZS4gVGhlIGJhc2U1OC1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyBhbGwgb25lcyAoYXMgc2VlbiBiZWxvdylcbiAgICogVGhlIHVuZGVybHlpbmcgQk4gbnVtYmVyIGlzIDMyIGJ5dGVzIHRoYXQgYXJlIGFsbCB6ZXJvc1xuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHR3byBwdWJsaWNLZXlzIGFyZSBlcXVhbFxuICAgKi9cbiAgZXF1YWxzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiB0aGlzLl9ibi5lcShwdWJsaWNLZXkuX2JuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvQmFzZTU4KCkge1xuICAgIHJldHVybiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKHRoaXMudG9CeXRlcygpKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CeXRlcygpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CdWZmZXIoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMuX2JuLnRvQXJyYXlMaWtlKGJ1ZmZlci5CdWZmZXIpO1xuICAgIGlmIChiLmxlbmd0aCA9PT0gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBjb25zdCB6ZXJvUGFkID0gYnVmZmVyLkJ1ZmZlci5hbGxvYygzMik7XG4gICAgYi5jb3B5KHplcm9QYWQsIDMyIC0gYi5sZW5ndGgpO1xuICAgIHJldHVybiB6ZXJvUGFkO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gYFB1YmxpY0tleSgke3RoaXMudG9TdHJpbmcoKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqIFRoZSBwcm9ncmFtIElEIHdpbGwgYWxzbyBzZXJ2ZSBhcyB0aGUgb3duZXIgb2YgdGhlIHB1YmxpYyBrZXksIGdpdmluZ1xuICAgKiBpdCBwZXJtaXNzaW9uIHRvIHdyaXRlIGRhdGEgdG8gdGhlIGFjY291bnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVXaXRoU2VlZChmcm9tUHVibGljS2V5LCBzZWVkLCBwcm9ncmFtSWQpIHtcbiAgICBjb25zdCBidWZmZXIkMSA9IGJ1ZmZlci5CdWZmZXIuY29uY2F0KFtmcm9tUHVibGljS2V5LnRvQnVmZmVyKCksIGJ1ZmZlci5CdWZmZXIuZnJvbShzZWVkKSwgcHJvZ3JhbUlkLnRvQnVmZmVyKCldKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHNoYTI1Ni5zaGEyNTYoYnVmZmVyJDEpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwcm9ncmFtIGFkZHJlc3MgZnJvbSBzZWVkcyBhbmQgYSBwcm9ncmFtIElELlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICBsZXQgYnVmZmVyJDEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKDApO1xuICAgIHNlZWRzLmZvckVhY2goZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgIGlmIChzZWVkLmxlbmd0aCA+IE1BWF9TRUVEX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNYXggc2VlZCBsZW5ndGggZXhjZWVkZWRgKTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlciQxID0gYnVmZmVyLkJ1ZmZlci5jb25jYXQoW2J1ZmZlciQxLCB0b0J1ZmZlcihzZWVkKV0pO1xuICAgIH0pO1xuICAgIGJ1ZmZlciQxID0gYnVmZmVyLkJ1ZmZlci5jb25jYXQoW2J1ZmZlciQxLCBwcm9ncmFtSWQudG9CdWZmZXIoKSwgYnVmZmVyLkJ1ZmZlci5mcm9tKCdQcm9ncmFtRGVyaXZlZEFkZHJlc3MnKV0pO1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVzID0gc2hhMjU2LnNoYTI1NihidWZmZXIkMSk7XG4gICAgaWYgKGlzT25DdXJ2ZShwdWJsaWNLZXlCeXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZWVkcywgYWRkcmVzcyBtdXN0IGZhbGwgb2ZmIHRoZSBjdXJ2ZWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVQcm9ncmFtQWRkcmVzcyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3NcbiAgICpcbiAgICogVmFsaWQgcHJvZ3JhbSBhZGRyZXNzZXMgbXVzdCBmYWxsIG9mZiB0aGUgZWQyNTUxOSBjdXJ2ZS4gIFRoaXMgZnVuY3Rpb25cbiAgICogaXRlcmF0ZXMgYSBub25jZSB1bnRpbCBpdCBmaW5kcyBvbmUgdGhhdCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIHNlZWRzXG4gICAqIHJlc3VsdHMgaW4gYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3MuXG4gICAqL1xuICBzdGF0aWMgZmluZFByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgbGV0IG5vbmNlID0gMjU1O1xuICAgIGxldCBhZGRyZXNzO1xuICAgIHdoaWxlIChub25jZSAhPSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZWVkc1dpdGhOb25jZSA9IHNlZWRzLmNvbmNhdChidWZmZXIuQnVmZmVyLmZyb20oW25vbmNlXSkpO1xuICAgICAgICBhZGRyZXNzID0gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHNXaXRoTm9uY2UsIHByb2dyYW1JZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBub25jZS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYWRkcmVzcywgbm9uY2VdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGEgdmlhYmxlIHByb2dyYW0gYWRkcmVzcyBub25jZWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgZmluZFByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZFByb2dyYW1BZGRyZXNzKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgYSBwdWJrZXkgaXMgb24gdGhlIGVkMjU1MTkgY3VydmUuXG4gICAqL1xuICBzdGF0aWMgaXNPbkN1cnZlKHB1YmtleURhdGEpIHtcbiAgICBjb25zdCBwdWJrZXkgPSBuZXcgUHVibGljS2V5KHB1YmtleURhdGEpO1xuICAgIHJldHVybiBpc09uQ3VydmUocHVia2V5LnRvQnl0ZXMoKSk7XG4gIH1cbn1cbl9QdWJsaWNLZXkgPSBQdWJsaWNLZXk7XG5QdWJsaWNLZXkuZGVmYXVsdCA9IG5ldyBfUHVibGljS2V5KCcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuU09MQU5BX1NDSEVNQS5zZXQoUHVibGljS2V5LCB7XG4gIGtpbmQ6ICdzdHJ1Y3QnLFxuICBmaWVsZHM6IFtbJ19ibicsICd1MjU2J11dXG59KTtcblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleSBwYWlyIChwdWJsaWMgYW5kIHNlY3JldCBrZXlzKS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2MS4xMC4wLCBwbGVhc2UgdXNlIHtAbGluayBLZXlwYWlyfSBpbnN0ZWFkLlxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBY2NvdW50IG9iamVjdFxuICAgKlxuICAgKiBJZiB0aGUgc2VjcmV0S2V5IHBhcmFtZXRlciBpcyBub3QgcHJvdmlkZWQgYSBuZXcga2V5IHBhaXIgaXMgcmFuZG9tbHlcbiAgICogY3JlYXRlZCBmb3IgdGhlIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBTZWNyZXQga2V5IGZvciB0aGUgYWNjb3VudFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2VjcmV0S2V5KSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc2VjcmV0S2V5ID0gdm9pZCAwO1xuICAgIGlmIChzZWNyZXRLZXkpIHtcbiAgICAgIGNvbnN0IHNlY3JldEtleUJ1ZmZlciA9IHRvQnVmZmVyKHNlY3JldEtleSk7XG4gICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMzIsIDY0KTtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgwLCAzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHRvQnVmZmVyKGdlbmVyYXRlUHJpdmF0ZUtleSgpKTtcbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHRvQnVmZmVyKGdldFB1YmxpY0tleSh0aGlzLl9zZWNyZXRLZXkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMgYWNjb3VudFxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSAqKnVuZW5jcnlwdGVkKiogc2VjcmV0IGtleSBmb3IgdGhpcyBhY2NvdW50LiBUaGUgZmlyc3QgMzIgYnl0ZXNcbiAgICogaXMgdGhlIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAgICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICAgKi9cbiAgZ2V0IHNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gYnVmZmVyLkJ1ZmZlci5jb25jYXQoW3RoaXMuX3NlY3JldEtleSwgdGhpcy5fcHVibGljS2V5XSwgNjQpO1xuICB9XG59XG5cbmNvbnN0IEJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIE1heGltdW0gb3Zlci10aGUtd2lyZSBzaXplIG9mIGEgVHJhbnNhY3Rpb25cbiAqXG4gKiAxMjgwIGlzIElQdjYgbWluaW11bSBNVFVcbiAqIDQwIGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBJUHY2IGhlYWRlclxuICogOCBieXRlcyBpcyB0aGUgc2l6ZSBvZiB0aGUgZnJhZ21lbnQgaGVhZGVyXG4gKi9cbmNvbnN0IFBBQ0tFVF9EQVRBX1NJWkUgPSAxMjgwIC0gNDAgLSA4O1xuY29uc3QgVkVSU0lPTl9QUkVGSVhfTUFTSyA9IDB4N2Y7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5cbmNsYXNzIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgc3VwZXIoYFNpZ25hdHVyZSAke3NpZ25hdHVyZX0gaGFzIGV4cGlyZWQ6IGJsb2NrIGhlaWdodCBleGNlZWRlZC5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUsIHRpbWVvdXRTZWNvbmRzKSB7XG4gICAgc3VwZXIoYFRyYW5zYWN0aW9uIHdhcyBub3QgY29uZmlybWVkIGluICR7dGltZW91dFNlY29uZHMudG9GaXhlZCgyKX0gc2Vjb25kcy4gSXQgaXMgYCArICd1bmtub3duIGlmIGl0IHN1Y2NlZWRlZCBvciBmYWlsZWQuIENoZWNrIHNpZ25hdHVyZSAnICsgYCR7c2lnbmF0dXJlfSB1c2luZyB0aGUgU29sYW5hIEV4cGxvcmVyIG9yIENMSSB0b29scy5gKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcidcbn0pO1xuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSkge1xuICAgIHN1cGVyKGBTaWduYXR1cmUgJHtzaWduYXR1cmV9IGhhcyBleHBpcmVkOiB0aGUgbm9uY2UgaXMgbm8gbG9uZ2VyIHZhbGlkLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcidcbn0pO1xuXG5jbGFzcyBNZXNzYWdlQWNjb3VudEtleXMge1xuICBjb25zdHJ1Y3RvcihzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBzdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIGtleVNlZ21lbnRzKCkge1xuICAgIGNvbnN0IGtleVNlZ21lbnRzID0gW3RoaXMuc3RhdGljQWNjb3VudEtleXNdO1xuICAgIGlmICh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlKTtcbiAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVNlZ21lbnRzO1xuICB9XG4gIGdldChpbmRleCkge1xuICAgIGZvciAoY29uc3Qga2V5U2VnbWVudCBvZiB0aGlzLmtleVNlZ21lbnRzKCkpIHtcbiAgICAgIGlmIChpbmRleCA8IGtleVNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBrZXlTZWdtZW50W2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4IC09IGtleVNlZ21lbnQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5sZW5ndGg7XG4gIH1cbiAgY29tcGlsZUluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpIHtcbiAgICAvLyBCYWlsIGVhcmx5IGlmIGFueSBhY2NvdW50IGluZGV4ZXMgd291bGQgb3ZlcmZsb3cgYSB1OFxuICAgIGNvbnN0IFU4X01BWCA9IDI1NTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBVOF9NQVggKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgaW5kZXggb3ZlcmZsb3cgZW5jb3VudGVyZWQgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGtleUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAga2V5SW5kZXhNYXAuc2V0KGtleS50b0Jhc2U1OCgpLCBpbmRleCk7XG4gICAgfSk7XG4gICAgY29uc3QgZmluZEtleUluZGV4ID0ga2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleUluZGV4ID0ga2V5SW5kZXhNYXAuZ2V0KGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGlmIChrZXlJbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY291bnRlcmVkIGFuIHVua25vd24gaW5zdHJ1Y3Rpb24gYWNjb3VudCBrZXkgZHVyaW5nIGNvbXBpbGF0aW9uJyk7XG4gICAgICByZXR1cm4ga2V5SW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZmluZEtleUluZGV4KGluc3RydWN0aW9uLnByb2dyYW1JZCksXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChtZXRhID0+IGZpbmRLZXlJbmRleChtZXRhLnB1YmtleSkpLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbi5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHB1YmxpYyBrZXlcbiAqL1xuY29uc3QgcHVibGljS2V5ID0gKHByb3BlcnR5ID0gJ3B1YmxpY0tleScpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoMzIsIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHNpZ25hdHVyZVxuICovXG5jb25zdCBzaWduYXR1cmUgPSAocHJvcGVydHkgPSAnc2lnbmF0dXJlJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYig2NCwgcHJvcGVydHkpO1xufTtcbi8qKlxuICogTGF5b3V0IGZvciBhIFJ1c3QgU3RyaW5nIHR5cGVcbiAqL1xuY29uc3QgcnVzdFN0cmluZyA9IChwcm9wZXJ0eSA9ICdzdHJpbmcnKSA9PiB7XG4gIGNvbnN0IHJzbCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdsZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdsZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uub2Zmc2V0KEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigpLCAtOCksICdjaGFycycpXSwgcHJvcGVydHkpO1xuICBjb25zdCBfZGVjb2RlID0gcnNsLmRlY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IF9lbmNvZGUgPSByc2wuZW5jb2RlLmJpbmQocnNsKTtcbiAgY29uc3QgcnNsU2hpbSA9IHJzbDtcbiAgcnNsU2hpbS5kZWNvZGUgPSAoYiwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IF9kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICByZXR1cm4gZGF0YVsnY2hhcnMnXS50b1N0cmluZygpO1xuICB9O1xuICByc2xTaGltLmVuY29kZSA9IChzdHIsIGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBjaGFyczogYnVmZmVyLkJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKVxuICAgIH07XG4gICAgcmV0dXJuIF9lbmNvZGUoZGF0YSwgYiwgb2Zmc2V0KTtcbiAgfTtcbiAgcnNsU2hpbS5hbGxvYyA9IHN0ciA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigpLnNwYW4gKyBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoKS5zcGFuICsgYnVmZmVyLkJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKS5sZW5ndGg7XG4gIH07XG4gIHJldHVybiByc2xTaGltO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGFuIEF1dGhvcml6ZWQgb2JqZWN0XG4gKi9cbmNvbnN0IGF1dGhvcml6ZWQgPSAocHJvcGVydHkgPSAnYXV0aG9yaXplZCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbcHVibGljS2V5KCdzdGFrZXInKSwgcHVibGljS2V5KCd3aXRoZHJhd2VyJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBMb2NrdXAgb2JqZWN0XG4gKi9cbmNvbnN0IGxvY2t1cCA9IChwcm9wZXJ0eSA9ICdsb2NrdXAnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ3VuaXhUaW1lc3RhbXAnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnZXBvY2gnKSwgcHVibGljS2V5KCdjdXN0b2RpYW4nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlSW5pdCBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUluaXQgPSAocHJvcGVydHkgPSAndm90ZUluaXQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW3B1YmxpY0tleSgnbm9kZVB1YmtleScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRWb3RlcicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRXaXRoZHJhd2VyJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdjb21taXNzaW9uJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyBvYmplY3RcbiAqL1xuY29uc3Qgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IChwcm9wZXJ0eSA9ICd2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ3ZvdGVBdXRob3JpemF0aW9uVHlwZScpLCBwdWJsaWNLZXkoJ2N1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXknKSwgcnVzdFN0cmluZygnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpXSwgcHJvcGVydHkpO1xufTtcbmZ1bmN0aW9uIGdldEFsbG9jKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBnZXRJdGVtQWxsb2MgPSBpdGVtID0+IHtcbiAgICBpZiAoaXRlbS5zcGFuID49IDApIHtcbiAgICAgIHJldHVybiBpdGVtLnNwYW47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZW0uYWxsb2MoZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9IGVsc2UgaWYgKCdjb3VudCcgaW4gaXRlbSAmJiAnZWxlbWVudExheW91dCcgaW4gaXRlbSkge1xuICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaXRlbS5wcm9wZXJ0eV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLmxlbmd0aCAqIGdldEl0ZW1BbGxvYyhpdGVtLmVsZW1lbnRMYXlvdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ2ZpZWxkcycgaW4gaXRlbSkge1xuICAgICAgLy8gVGhpcyBpcyBhIGBTdHJ1Y3R1cmVgIHdob3NlIHNpemUgbmVlZHMgdG8gYmUgcmVjdXJzaXZlbHkgbWVhc3VyZWQuXG4gICAgICByZXR1cm4gZ2V0QWxsb2Moe1xuICAgICAgICBsYXlvdXQ6IGl0ZW1cbiAgICAgIH0sIGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfVxuICAgIC8vIENvdWxkbid0IGRldGVybWluZSBhbGxvY2F0ZWQgc2l6ZSBvZiBsYXlvdXRcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgbGV0IGFsbG9jID0gMDtcbiAgdHlwZS5sYXlvdXQuZmllbGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgYWxsb2MgKz0gZ2V0SXRlbUFsbG9jKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbG9jO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgoYnl0ZXMpIHtcbiAgbGV0IGxlbiA9IDA7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gYnl0ZXMuc2hpZnQoKTtcbiAgICBsZW4gfD0gKGVsZW0gJiAweDdmKSA8PCBzaXplICogNztcbiAgICBzaXplICs9IDE7XG4gICAgaWYgKChlbGVtICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKGJ5dGVzLCBsZW4pIHtcbiAgbGV0IHJlbV9sZW4gPSBsZW47XG4gIGZvciAoOzspIHtcbiAgICBsZXQgZWxlbSA9IHJlbV9sZW4gJiAweDdmO1xuICAgIHJlbV9sZW4gPj49IDc7XG4gICAgaWYgKHJlbV9sZW4gPT0gMCkge1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtIHw9IDB4ODA7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cblxuY2xhc3MgQ29tcGlsZWRLZXlzIHtcbiAgY29uc3RydWN0b3IocGF5ZXIsIGtleU1ldGFNYXApIHtcbiAgICB0aGlzLnBheWVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyID0gcGF5ZXI7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0ga2V5TWV0YU1hcDtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShpbnN0cnVjdGlvbnMsIHBheWVyKSB7XG4gICAgY29uc3Qga2V5TWV0YU1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBnZXRPckluc2VydERlZmF1bHQgPSBwdWJrZXkgPT4ge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHB1YmtleS50b0Jhc2U1OCgpO1xuICAgICAgbGV0IGtleU1ldGEgPSBrZXlNZXRhTWFwLmdldChhZGRyZXNzKTtcbiAgICAgIGlmIChrZXlNZXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5TWV0YSA9IHtcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgaXNJbnZva2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBrZXlNZXRhTWFwLnNldChhZGRyZXNzLCBrZXlNZXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlNZXRhO1xuICAgIH07XG4gICAgY29uc3QgcGF5ZXJLZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KHBheWVyKTtcbiAgICBwYXllcktleU1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgIHBheWVyS2V5TWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGl4IG9mIGluc3RydWN0aW9ucykge1xuICAgICAgZ2V0T3JJbnNlcnREZWZhdWx0KGl4LnByb2dyYW1JZCkuaXNJbnZva2VkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudE1ldGEgb2YgaXgua2V5cykge1xuICAgICAgICBjb25zdCBrZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KGFjY291bnRNZXRhLnB1YmtleSk7XG4gICAgICAgIGtleU1ldGEuaXNTaWduZXIgfHw9IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgICBrZXlNZXRhLmlzV3JpdGFibGUgfHw9IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcGlsZWRLZXlzKHBheWVyLCBrZXlNZXRhTWFwKTtcbiAgfVxuICBnZXRNZXNzYWdlQ29tcG9uZW50cygpIHtcbiAgICBjb25zdCBtYXBFbnRyaWVzID0gWy4uLnRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCldO1xuICAgIGFzc2VydChtYXBFbnRyaWVzLmxlbmd0aCA8PSAyNTYsICdNYXggc3RhdGljIGFjY291bnQga2V5cyBsZW5ndGggZXhjZWVkZWQnKTtcbiAgICBjb25zdCB3cml0YWJsZVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCByZWFkb25seVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3Qgd3JpdGFibGVOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5Tm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiB3cml0YWJsZVNpZ25lcnMubGVuZ3RoICsgcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5Tm9uU2lnbmVycy5sZW5ndGhcbiAgICB9O1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrc1xuICAgIHtcbiAgICAgIGFzc2VydCh3cml0YWJsZVNpZ25lcnMubGVuZ3RoID4gMCwgJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSB3cml0YWJsZSBzaWduZXIga2V5Jyk7XG4gICAgICBjb25zdCBbcGF5ZXJBZGRyZXNzXSA9IHdyaXRhYmxlU2lnbmVyc1swXTtcbiAgICAgIGFzc2VydChwYXllckFkZHJlc3MgPT09IHRoaXMucGF5ZXIudG9CYXNlNTgoKSwgJ0V4cGVjdGVkIGZpcnN0IHdyaXRhYmxlIHNpZ25lciBrZXkgdG8gYmUgdGhlIGZlZSBwYXllcicpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFsuLi53cml0YWJsZVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi53cml0YWJsZU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpXTtcbiAgICByZXR1cm4gW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdO1xuICB9XG4gIGV4dHJhY3RUYWJsZUxvb2t1cChsb29rdXBUYWJsZSkge1xuICAgIGNvbnN0IFt3cml0YWJsZUluZGV4ZXMsIGRyYWluZWRXcml0YWJsZUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiBrZXlNZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IFtyZWFkb25seUluZGV4ZXMsIGRyYWluZWRSZWFkb25seUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiAha2V5TWV0YS5pc1dyaXRhYmxlKTtcblxuICAgIC8vIERvbid0IGV4dHJhY3QgbG9va3VwIGlmIG5vIGtleXMgd2VyZSBmb3VuZFxuICAgIGlmICh3cml0YWJsZUluZGV4ZXMubGVuZ3RoID09PSAwICYmIHJlYWRvbmx5SW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICBhY2NvdW50S2V5OiBsb29rdXBUYWJsZS5rZXksXG4gICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICByZWFkb25seUluZGV4ZXNcbiAgICB9LCB7XG4gICAgICB3cml0YWJsZTogZHJhaW5lZFdyaXRhYmxlS2V5cyxcbiAgICAgIHJlYWRvbmx5OiBkcmFpbmVkUmVhZG9ubHlLZXlzXG4gICAgfV07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZUVudHJpZXMsIGtleU1ldGFGaWx0ZXIpIHtcbiAgICBjb25zdCBsb29rdXBUYWJsZUluZGV4ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBkcmFpbmVkS2V5cyA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIGtleU1ldGFdIG9mIHRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChrZXlNZXRhRmlsdGVyKGtleU1ldGEpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXggPSBsb29rdXBUYWJsZUVudHJpZXMuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5LmVxdWFscyhrZXkpKTtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlSW5kZXggPj0gMCkge1xuICAgICAgICAgIGFzc2VydChsb29rdXBUYWJsZUluZGV4IDwgMjU2LCAnTWF4IGxvb2t1cCB0YWJsZSBpbmRleCBleGNlZWRlZCcpO1xuICAgICAgICAgIGxvb2t1cFRhYmxlSW5kZXhlcy5wdXNoKGxvb2t1cFRhYmxlSW5kZXgpO1xuICAgICAgICAgIGRyYWluZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB0aGlzLmtleU1ldGFNYXAuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbG9va3VwVGFibGVJbmRleGVzLCBkcmFpbmVkS2V5c107XG4gIH1cbn1cblxuY29uc3QgRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFID0gJ1JlYWNoZWQgZW5kIG9mIGJ1ZmZlciB1bmV4cGVjdGVkbHknO1xuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc2hpZnRgLCBidXQgdGhyb3dzIGlmIHRoZSBhcnJheSBpcyB6ZXJvLWxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSkge1xuICBpZiAoYnl0ZUFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc2hpZnQoKTtcbn1cblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NwbGljZWAsIGJ1dCB0aHJvd3MgaWYgdGhlIHNlY3Rpb24gYmVpbmcgc3BsaWNlZCBvdXQgZXh0ZW5kcyBwYXN0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIC4uLmFyZ3MpIHtcbiAgY29uc3QgW3N0YXJ0XSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAvLyBJbXBsaWVzIHRoYXQgYGRlbGV0ZUNvdW50YCB3YXMgc3VwcGxpZWRcbiAgPyBzdGFydCArIChhcmdzWzFdID8/IDApID4gYnl0ZUFycmF5Lmxlbmd0aCA6IHN0YXJ0ID49IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNwbGljZSguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBBbiBpbnN0cnVjdGlvbiB0byBleGVjdXRlIGJ5IGEgcHJvZ3JhbVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9ncmFtSWRJbmRleFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gYWNjb3VudHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhXG4gKi9cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBpbnN0cnVjdGlvbnMgdG8gYmUgcHJvY2Vzc2VkIGF0b21pY2FsbHlcbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oZWFkZXIgPSBhcmdzLmhlYWRlcjtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gYXJncy5hY2NvdW50S2V5cy5tYXAoYWNjb3VudCA9PiBuZXcgUHVibGljS2V5KGFjY291bnQpKTtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMuZm9yRWFjaChpeCA9PiB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnNldChpeC5wcm9ncmFtSWRJbmRleCwgdGhpcy5hY2NvdW50S2V5c1tpeC5wcm9ncmFtSWRJbmRleF0pKTtcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gJ2xlZ2FjeSc7XG4gIH1cbiAgZ2V0IHN0YXRpY0FjY291bnRLZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzO1xuICB9XG4gIGdldCBjb21waWxlZEluc3RydWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnMubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICBkYXRhOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZGVjb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICB9XG4gIGdldCBhZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXRBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzKTtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucykubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50czogaXguYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICBkYXRhOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGl4LmRhdGEpXG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBoZWFkZXIsXG4gICAgICBhY2NvdW50S2V5czogc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IDwgdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICB9XG4gIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgY29uc3QgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgaXNQcm9ncmFtSWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoaW5kZXgpO1xuICB9XG4gIHByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnZhbHVlcygpXTtcbiAgfVxuICBub25Qcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcigoXywgaW5kZXgpID0+ICF0aGlzLmlzUHJvZ3JhbUlkKGluZGV4KSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IG51bUtleXMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5Q291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoa2V5Q291bnQsIG51bUtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzLFxuICAgICAgICBwcm9ncmFtSWRJbmRleFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgY29uc3QgZGF0YSA9IEFycmF5LmZyb20oYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKSk7XG4gICAgICBsZXQga2V5SW5kaWNlc0NvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoa2V5SW5kaWNlc0NvdW50LCBhY2NvdW50cy5sZW5ndGgpO1xuICAgICAgbGV0IGRhdGFDb3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGRhdGFDb3VudCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGtleUluZGljZXNDb3VudDogYnVmZmVyLkJ1ZmZlci5mcm9tKGtleUluZGljZXNDb3VudCksXG4gICAgICAgIGtleUluZGljZXM6IGFjY291bnRzLFxuICAgICAgICBkYXRhTGVuZ3RoOiBidWZmZXIuQnVmZmVyLmZyb20oZGF0YUNvdW50KSxcbiAgICAgICAgZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25Db3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChpbnN0cnVjdGlvbkNvdW50LCBpbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXIgPSBidWZmZXIuQnVmZmVyLmFsbG9jKFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGJ1ZmZlci5CdWZmZXIuZnJvbShpbnN0cnVjdGlvbkNvdW50KS5jb3B5KGluc3RydWN0aW9uQnVmZmVyKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggPSBpbnN0cnVjdGlvbkNvdW50Lmxlbmd0aDtcbiAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoaW5zdHJ1Y3Rpb24ua2V5SW5kaWNlc0NvdW50Lmxlbmd0aCwgJ2tleUluZGljZXNDb3VudCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2tleUluZGV4JyksIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLCAna2V5SW5kaWNlcycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKGluc3RydWN0aW9uLmRhdGFMZW5ndGgubGVuZ3RoLCAnZGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3VzZXJkYXR1bScpLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgY29uc3QgbGVuZ3RoID0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbkJ1ZmZlciwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggKz0gbGVuZ3RoO1xuICAgIH0pO1xuICAgIGluc3RydWN0aW9uQnVmZmVyID0gaW5zdHJ1Y3Rpb25CdWZmZXIuc2xpY2UoMCwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgIGNvbnN0IHNpZ25EYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKDEsICdudW1SZXF1aXJlZFNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYigxLCAnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKDEsICdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihrZXlDb3VudC5sZW5ndGgsICdrZXlDb3VudCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEocHVibGljS2V5KCdrZXknKSwgbnVtS2V5cywgJ2tleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKV0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBidWZmZXIuQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlc10pLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogYnVmZmVyLkJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzXSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGJ1ZmZlci5CdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICBrZXlDb3VudDogYnVmZmVyLkJ1ZmZlci5mcm9tKGtleUNvdW50KSxcbiAgICAgIGtleXM6IHRoaXMuYWNjb3VudEtleXMubWFwKGtleSA9PiB0b0J1ZmZlcihrZXkudG9CeXRlcygpKSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpXG4gICAgfTtcbiAgICBsZXQgc2lnbkRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKDIwNDgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25EYXRhTGF5b3V0LmVuY29kZSh0cmFuc2FjdGlvbiwgc2lnbkRhdGEpO1xuICAgIGluc3RydWN0aW9uQnVmZmVyLmNvcHkoc2lnbkRhdGEsIGxlbmd0aCk7XG4gICAgcmV0dXJuIHNpZ25EYXRhLnNsaWNlKDAsIGxlbmd0aCArIGluc3RydWN0aW9uQnVmZmVyLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcGlsZWQgbWVzc2FnZSBpbnRvIGEgTWVzc2FnZSBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIkMSkge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyJDFdO1xuICAgIGNvbnN0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGlmIChudW1SZXF1aXJlZFNpZ25hdHVyZXMgIT09IChudW1SZXF1aXJlZFNpZ25hdHVyZXMgJiBWRVJTSU9OX1BSRUZJWF9NQVNLKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uZWQgbWVzc2FnZXMgbXVzdCBiZSBkZXNlcmlhbGl6ZWQgd2l0aCBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKCknKTtcbiAgICB9XG4gICAgY29uc3QgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGxldCBhY2NvdW50S2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjb3VudENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnQgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgYWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KGJ1ZmZlci5CdWZmZXIuZnJvbShhY2NvdW50KSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRDb3VudCk7XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBkYXRhU2xpY2UgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgICBjb25zdCBkYXRhID0gYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmVuY29kZShidWZmZXIuQnVmZmVyLmZyb20oZGF0YVNsaWNlKSk7XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VBcmdzID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGJ1ZmZlci5CdWZmZXIuZnJvbShyZWNlbnRCbG9ja2hhc2gpKSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG5jbGFzcyBNZXNzYWdlVjAge1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlYWRlciA9IGFyZ3MuaGVhZGVyO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBhcmdzLnN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IGFyZ3MuY29tcGlsZWRJbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gYXJncy5hZGRyZXNzVGFibGVMb29rdXBzO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBudW1BY2NvdW50S2V5c0Zyb21Mb29rdXBzKCkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBsb29rdXAgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb3VudCArPSBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoYXJncykge1xuICAgIGxldCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIGlmIChhcmdzICYmICdhY2NvdW50S2V5c0Zyb21Mb29rdXBzJyBpbiBhcmdzICYmIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2Ugb2YgYSBtaXNtYXRjaCBpbiB0aGUgbnVtYmVyIG9mIGFjY291bnQga2V5cyBmcm9tIGxvb2t1cHMnKTtcbiAgICAgIH1cbiAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfSBlbHNlIGlmIChhcmdzICYmICdhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cycgaW4gYXJncyAmJiBhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhhcmdzLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2UgYWRkcmVzcyB0YWJsZSBsb29rdXBzIHdlcmUgbm90IHJlc29sdmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICB9XG4gIGlzQWNjb3VudFNpZ25lcihpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShpbmRleCkge1xuICAgIGNvbnN0IG51bVNpZ25lZEFjY291bnRzID0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzO1xuICAgIGNvbnN0IG51bVN0YXRpY0FjY291bnRLZXlzID0gdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgaWYgKGluZGV4ID49IG51bVN0YXRpY0FjY291bnRLZXlzKSB7XG4gICAgICBjb25zdCBsb29rdXBBY2NvdW50S2V5c0luZGV4ID0gaW5kZXggLSBudW1TdGF0aWNBY2NvdW50S2V5cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXMgPSB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMucmVkdWNlKChjb3VudCwgbG9va3VwKSA9PiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiBsb29rdXBBY2NvdW50S2V5c0luZGV4IDwgbnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cztcbiAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcykge1xuICAgICAgY29uc3QgdW5zaWduZWRBY2NvdW50SW5kZXggPSBpbmRleCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtVW5zaWduZWRBY2NvdW50cyA9IG51bVN0YXRpY0FjY291bnRLZXlzIC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBudW1VbnNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID0gbnVtU2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGluZGV4IDwgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cztcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgdGFibGVBY2NvdW50ID0gYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQua2V5LmVxdWFscyh0YWJsZUxvb2t1cC5hY2NvdW50S2V5KSk7XG4gICAgICBpZiAoIXRhYmxlQWNjb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgbG9va3VwIHRhYmxlIGFjY291bnQgZm9yIHRhYmxlIGtleSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGFibGVMb29rdXAud3JpdGFibGVJbmRleGVzKSB7XG4gICAgICAgIGlmIChpbmRleCA8IHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5wdXNoKHRhYmxlQWNjb3VudC5zdGF0ZS5hZGRyZXNzZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aW5kZXh9IGluIGFkZHJlc3MgbG9va3VwIHRhYmxlICR7dGFibGVMb29rdXAuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLnJlYWRvbmx5SW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgfVxuICBzdGF0aWMgY29tcGlsZShhcmdzKSB7XG4gICAgY29uc3QgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgd3JpdGFibGU6IG5ldyBBcnJheSgpLFxuICAgICAgcmVhZG9ubHk6IG5ldyBBcnJheSgpXG4gICAgfTtcbiAgICBjb25zdCBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IGxvb2t1cFRhYmxlIG9mIGxvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgIGNvbnN0IGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgIGlmIChleHRyYWN0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgW2FkZHJlc3NUYWJsZUxvb2t1cCwge1xuICAgICAgICAgIHdyaXRhYmxlLFxuICAgICAgICAgIHJlYWRvbmx5XG4gICAgICAgIH1dID0gZXh0cmFjdFJlc3VsdDtcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCguLi53cml0YWJsZSk7XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkucHVzaCguLi5yZWFkb25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtoZWFkZXIsIHN0YXRpY0FjY291bnRLZXlzXSA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcyk7XG4gICAgY29uc3QgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhY2NvdW50S2V5cy5jb21waWxlSW5zdHJ1Y3Rpb25zKGFyZ3MuaW5zdHJ1Y3Rpb25zKTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IHRoaXMuc2VyaWFsaXplSW5zdHJ1Y3Rpb25zKCk7XG4gICAgY29uc3QgZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgsIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMubGVuZ3RoKTtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IHRoaXMuc2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3VwcygpO1xuICAgIGNvbnN0IGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgpO1xuICAgIGNvbnN0IG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdwcmVmaXgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnbnVtUmVxdWlyZWRTaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdudW1SZWFkb25seVNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKV0sICdoZWFkZXInKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKHB1YmxpY0tleSgpLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzJyksIHB1YmxpY0tleSgncmVjZW50QmxvY2toYXNoJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCwgJ3NlcmlhbGl6ZWRJbnN0cnVjdGlvbnMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aC5sZW5ndGgsICdhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2Ioc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLCAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnKV0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgY29uc3QgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoe1xuICAgICAgcHJlZml4OiBNRVNTQUdFX1ZFUlNJT05fMF9QUkVGSVgsXG4gICAgICBoZWFkZXI6IHRoaXMuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCksXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5tYXAoa2V5ID0+IGtleS50b0J5dGVzKCkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKSxcbiAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aCksXG4gICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgpLFxuICAgICAgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICB9LCBzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRNZXNzYWdlLnNsaWNlKDAsIHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVJbnN0cnVjdGlvbnMoKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMgPSBuZXcgVWludDhBcnJheShQQUNLRVRfREFUQV9TSVpFKTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZERhdGFMZW5ndGggPSBBcnJheSgpO1xuICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWREYXRhTGVuZ3RoLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoKSwgaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMubGVuZ3RoLCAnYWNjb3VudEtleUluZGV4ZXMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkRGF0YUxlbmd0aC5sZW5ndGgsICdlbmNvZGVkRGF0YUxlbmd0aCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWREYXRhTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YUxlbmd0aCksXG4gICAgICAgIGRhdGE6IGluc3RydWN0aW9uLmRhdGFcbiAgICAgIH0sIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZEluc3RydWN0aW9ucy5zbGljZSgwLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGZvciAoY29uc3QgbG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCwgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtwdWJsaWNLZXkoJ2FjY291bnRLZXknKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UuYmxvYihlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCksIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAnd3JpdGFibGVJbmRleGVzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnNlcShCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgpLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgJ3JlYWRvbmx5SW5kZXhlcycpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGFkZHJlc3NUYWJsZUxvb2t1cExheW91dC5lbmNvZGUoe1xuICAgICAgICBhY2NvdW50S2V5OiBsb29rdXAuYWNjb3VudEtleS50b0J5dGVzKCksXG4gICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IGxvb2t1cC53cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXNcbiAgICAgIH0sIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZE1lc3NhZ2VdO1xuICAgIGNvbnN0IHByZWZpeCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG4gICAgYXNzZXJ0KHByZWZpeCAhPT0gbWFza2VkUHJlZml4LCBgRXhwZWN0ZWQgdmVyc2lvbmVkIG1lc3NhZ2UgYnV0IHJlY2VpdmVkIGxlZ2FjeSBtZXNzYWdlYCk7XG4gICAgY29uc3QgdmVyc2lvbiA9IG1hc2tlZFByZWZpeDtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gMCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uICR7dmVyc2lvbn1gKTtcbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpXG4gICAgfTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICBzdGF0aWNBY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSkpO1xuICAgIH1cbiAgICBjb25zdCByZWNlbnRCbG9ja2hhc2ggPSBiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBjb21waWxlZEluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmFtSWRJbmRleCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGFjY291bnRLZXlJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGFjY291bnRLZXlJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgZGF0YUxlbmd0aCkpO1xuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhY2NvdW50S2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIHdyaXRhYmxlSW5kZXhlc0xlbmd0aCk7XG4gICAgICBjb25zdCByZWFkb25seUluZGV4ZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGNvbnN0IHJlYWRvbmx5SW5kZXhlcyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCByZWFkb25seUluZGV4ZXNMZW5ndGgpO1xuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKHtcbiAgICAgICAgYWNjb3VudEtleSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzLFxuICAgICAgICByZWFkb25seUluZGV4ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmNvbnN0IFZlcnNpb25lZE1lc3NhZ2UgPSB7XG4gIGRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICBjb25zdCBwcmVmaXggPSBzZXJpYWxpemVkTWVzc2FnZVswXTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuXG4gICAgLy8gaWYgdGhlIGhpZ2hlc3QgYml0IG9mIHRoZSBwcmVmaXggaXMgbm90IHNldCwgdGhlIG1lc3NhZ2UgaXMgbm90IHZlcnNpb25lZFxuICAgIGlmIChtYXNrZWRQcmVmaXggPT09IHByZWZpeCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cblxuICAgIC8vIHRoZSBsb3dlciA3IGJpdHMgb2YgdGhlIHByZWZpeCBpbmRpY2F0ZSB0aGUgbWVzc2FnZSB2ZXJzaW9uXG4gICAgcmV0dXJuIG1hc2tlZFByZWZpeDtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IHNlcmlhbGl6ZWRNZXNzYWdlID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uID0gVmVyc2lvbmVkTWVzc2FnZS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgIHJldHVybiBNZXNzYWdlLmZyb20oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1lc3NhZ2VWMC5kZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gbWVzc2FnZSB2ZXJzaW9uICR7dmVyc2lvbn0gZGVzZXJpYWxpemF0aW9uIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBzaWduYXR1cmUgYXMgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICovXG5cbmxldCBUcmFuc2FjdGlvblN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoVHJhbnNhY3Rpb25TdGF0dXMpIHtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiXSA9IDBdID0gXCJCTE9DS0hFSUdIVF9FWENFRURFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlBST0NFU1NFRFwiXSA9IDFdID0gXCJQUk9DRVNTRURcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJUSU1FRF9PVVRcIl0gPSAyXSA9IFwiVElNRURfT1VUXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiTk9OQ0VfSU5WQUxJRFwiXSA9IDNdID0gXCJOT05DRV9JTlZBTElEXCI7XG4gIHJldHVybiBUcmFuc2FjdGlvblN0YXR1cztcbn0oe30pO1xuXG4vKipcbiAqIERlZmF1bHQgKGVtcHR5KSBzaWduYXR1cmVcbiAqL1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkUgPSBidWZmZXIuQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5cbi8qKlxuICogQWNjb3VudCBtZXRhZGF0YSB1c2VkIHRvIGRlZmluZSBpbnN0cnVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIExpc3Qgb2YgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiBvYmplY3QgZmllbGRzIHRoYXQgbWF5IGJlIGluaXRpYWxpemVkIGF0IGNvbnN0cnVjdGlvblxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogQm9vbGVhbiByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwdWJrZXkgbmVlZHMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBJZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoMCk7XG4gICAgdGhpcy5wcm9ncmFtSWQgPSBvcHRzLnByb2dyYW1JZDtcbiAgICB0aGlzLmtleXMgPSBvcHRzLmtleXM7XG4gICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gb3B0cy5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLm1hcCgoe1xuICAgICAgICBwdWJrZXksXG4gICAgICAgIGlzU2lnbmVyLFxuICAgICAgICBpc1dyaXRhYmxlXG4gICAgICB9KSA9PiAoe1xuICAgICAgICBwdWJrZXk6IHB1YmtleS50b0pTT04oKSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pKSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQudG9KU09OKCksXG4gICAgICBkYXRhOiBbLi4udGhpcy5kYXRhXVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQYWlyIG9mIHNpZ25hdHVyZSBhbmQgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk7IGFuIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nXG4vLyBmb3JjZWQgdG8gb3Zlci1leHBvcnQgdHlwZXMgYnkgdGhlIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yNTgyMFxuXG4vKipcbiAqIEJsb2NraGFzaC1iYXNlZCB0cmFuc2FjdGlvbnMgaGF2ZSBhIGxpZmV0aW1lIHRoYXQgYXJlIGRlZmluZWQgYnlcbiAqIHRoZSBibG9ja2hhc2ggdGhleSBpbmNsdWRlLiBBbnkgdHJhbnNhY3Rpb24gd2hvc2UgYmxvY2toYXNoIGlzXG4gKiB0b28gb2xkIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKi9cblxuLyoqXG4gKiBVc2UgdGhlc2Ugb3B0aW9ucyB0byBjb25zdHJ1Y3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogTm9uY2UgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCB0byBidWlsZCBhbiBvZmZsaW5lIFRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgZmlyc3QgKHBheWVyKSBUcmFuc2FjdGlvbiBzaWduYXR1cmVcbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlciB8IG51bGx9IEJ1ZmZlciBvZiBwYXllcidzIHNpZ25hdHVyZVxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpIHtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZXNbMF0uc2lnbmF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyXG4gICAqL1xuXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHdpdGggYSBibG9ja2hhc2ggYW5kIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gdXNpbmcgYSBkdXJhYmxlIG5vbmNlXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGBUcmFuc2FjdGlvbkN0b3JGaWVsZHNgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKiBQbGVhc2Ugc3VwcGx5IGEgYFRyYW5zYWN0aW9uQmxvY2toYXNoQ3RvcmAgaW5zdGVhZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBlbXB0eSBUcmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFR5cGljYWxseSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZVxuICAgICAqIGBzaWduKClgIG1ldGhvZFxuICAgICAqL1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZmVlUGF5ZXIgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGluc3RydWN0aW9ucyB0byBhdG9taWNhbGx5IGV4ZWN1dGVcbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEEgcmVjZW50IHRyYW5zYWN0aW9uIGlkLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogdGhlIGxhc3QgYmxvY2sgY2hhaW4gY2FuIGFkdmFuY2UgdG8gYmVmb3JlIHR4IGlzIGRlY2xhcmVkIGV4cGlyZWRcbiAgICAgKiAqL1xuICAgIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgTm9uY2UgaW5mb3JtYXRpb24uIElmIHBvcHVsYXRlZCwgdHJhbnNhY3Rpb24gd2lsbCB1c2UgYSBkdXJhYmxlXG4gICAgICogTm9uY2UgaGFzaCBpbnN0ZWFkIG9mIGEgcmVjZW50QmxvY2toYXNoLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5ub25jZUluZm8gPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpcyBhIG5vbmNlIHRyYW5zYWN0aW9uIHRoaXMgcmVwcmVzZW50cyB0aGUgbWluaW11bSBzbG90IGZyb20gd2hpY2hcbiAgICAgKiB0byBldmFsdWF0ZSBpZiB0aGUgbm9uY2UgaGFzIGFkdmFuY2VkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25maXJtIHRoZVxuICAgICAqIHRyYW5zYWN0aW9uLiBUaGlzIHByb3RlY3RzIGFnYWluc3QgYSBjYXNlIHdoZXJlIHRoZSB0cmFuc2FjdGlvbiBjb25maXJtYXRpb25cbiAgICAgKiBsb2dpYyBsb2FkcyB0aGUgbm9uY2UgYWNjb3VudCBmcm9tIGFuIG9sZCBzbG90IGFuZCBhc3N1bWVzIHRoZSBtaXNtYXRjaCBpblxuICAgICAqIG5vbmNlIHZhbHVlIGltcGxpZXMgdGhhdCB0aGUgbm9uY2UgaGFzIGJlZW4gYWR2YW5jZWQuXG4gICAgICovXG4gICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX21lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fanNvbiA9IHZvaWQgMDtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdHMuZmVlUGF5ZXIpIHtcbiAgICAgIHRoaXMuZmVlUGF5ZXIgPSBvcHRzLmZlZVBheWVyO1xuICAgIH1cbiAgICBpZiAob3B0cy5zaWduYXR1cmVzKSB7XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBvcHRzLnNpZ25hdHVyZXM7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ25vbmNlSW5mbycpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gbWluQ29udGV4dFNsb3Q7XG4gICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgICB9ID0gb3B0cztcbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgICAgbm9uY2VJbmZvXG4gICAgICB9ID0gb3B0cztcbiAgICAgIGlmIChub25jZUluZm8pIHtcbiAgICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgICB9XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHJlY2VudEJsb2NraGFzaDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2ggfHwgbnVsbCxcbiAgICAgIGZlZVBheWVyOiB0aGlzLmZlZVBheWVyID8gdGhpcy5mZWVQYXllci50b0pTT04oKSA6IG51bGwsXG4gICAgICBub25jZUluZm86IHRoaXMubm9uY2VJbmZvID8ge1xuICAgICAgICBub25jZTogdGhpcy5ub25jZUluZm8ubm9uY2UsXG4gICAgICAgIG5vbmNlSW5zdHJ1Y3Rpb246IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24udG9KU09OKClcbiAgICAgIH0gOiBudWxsLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udG9KU09OKCkpLFxuICAgICAgc2lnbmVyczogdGhpcy5zaWduYXR1cmVzLm1hcCgoe1xuICAgICAgICBwdWJsaWNLZXlcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b0pTT04oKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgaW5zdHJ1Y3Rpb25zIHRvIHRoaXMgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTwgVHJhbnNhY3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkN0b3JGaWVsZHMgPn0gaXRlbXMgLSBJbnN0cnVjdGlvbnMgdG8gYWRkIHRvIHRoZSBUcmFuc2FjdGlvblxuICAgKi9cbiAgYWRkKC4uLml0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnN0cnVjdGlvbnMnKTtcbiAgICB9XG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICgnaW5zdHJ1Y3Rpb25zJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMuY29uY2F0KGl0ZW0uaW5zdHJ1Y3Rpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoJ2RhdGEnIGluIGl0ZW0gJiYgJ3Byb2dyYW1JZCcgaW4gaXRlbSAmJiAna2V5cycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpdGVtKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBjb21waWxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5fbWVzc2FnZSAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKSA9PT0gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgIH1cbiAgICBsZXQgcmVjZW50QmxvY2toYXNoO1xuICAgIGxldCBpbnN0cnVjdGlvbnM7XG4gICAgaWYgKHRoaXMubm9uY2VJbmZvKSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLm5vbmNlSW5mby5ub25jZTtcbiAgICAgIGlmICh0aGlzLmluc3RydWN0aW9uc1swXSAhPSB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uKSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IFt0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLCAuLi50aGlzLmluc3RydWN0aW9uc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZW50QmxvY2toYXNoID0gdGhpcy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICB9XG4gICAgaWYgKCFyZWNlbnRCbG9ja2hhc2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gcmVjZW50QmxvY2toYXNoIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgY29uc29sZS53YXJuKCdObyBpbnN0cnVjdGlvbnMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgbGV0IGZlZVBheWVyO1xuICAgIGlmICh0aGlzLmZlZVBheWVyKSB7XG4gICAgICBmZWVQYXllciA9IHRoaXMuZmVlUGF5ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCAmJiB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5KSB7XG4gICAgICAvLyBVc2UgaW1wbGljaXQgZmVlIHBheWVyXG4gICAgICBmZWVQYXllciA9IHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmVlIHBheWVyIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2ldLnByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gaW5kZXggJHtpfSBoYXMgdW5kZWZpbmVkIHByb2dyYW0gaWRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbUlkcyA9IFtdO1xuICAgIGNvbnN0IGFjY291bnRNZXRhcyA9IFtdO1xuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGluc3RydWN0aW9uLmtleXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgICAuLi5hY2NvdW50TWV0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvZ3JhbUlkID0gaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIXByb2dyYW1JZHMuaW5jbHVkZXMocHJvZ3JhbUlkKSkge1xuICAgICAgICBwcm9ncmFtSWRzLnB1c2gocHJvZ3JhbUlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFwcGVuZCBwcm9ncmFtSUQgYWNjb3VudCBtZXRhc1xuICAgIHByb2dyYW1JZHMuZm9yRWFjaChwcm9ncmFtSWQgPT4ge1xuICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDdWxsIGR1cGxpY2F0ZSBhY2NvdW50IG1ldGFzXG4gICAgY29uc3QgdW5pcXVlTWV0YXMgPSBbXTtcbiAgICBhY2NvdW50TWV0YXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICBjb25zdCBwdWJrZXlTdHJpbmcgPSBhY2NvdW50TWV0YS5wdWJrZXkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5U3RyaW5nO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlIHx8IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciB8fCBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzLnB1c2goYWNjb3VudE1ldGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydC4gUHJpb3JpdGl6aW5nIGZpcnN0IGJ5IHNpZ25lciwgdGhlbiBieSB3cml0YWJsZVxuICAgIHVuaXF1ZU1ldGFzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh4LmlzU2lnbmVyICE9PSB5LmlzU2lnbmVyKSB7XG4gICAgICAgIC8vIFNpZ25lcnMgYWx3YXlzIGNvbWUgYmVmb3JlIG5vbi1zaWduZXJzXG4gICAgICAgIHJldHVybiB4LmlzU2lnbmVyID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgaWYgKHguaXNXcml0YWJsZSAhPT0geS5pc1dyaXRhYmxlKSB7XG4gICAgICAgIC8vIFdyaXRhYmxlIGFjY291bnRzIGFsd2F5cyBjb21lIGJlZm9yZSByZWFkLW9ubHkgYWNjb3VudHNcbiAgICAgICAgcmV0dXJuIHguaXNXcml0YWJsZSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwgc29ydCBieSBwdWJrZXksIHN0cmluZ3dpc2UuXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiAnYmVzdCBmaXQnLFxuICAgICAgICB1c2FnZTogJ3NvcnQnLFxuICAgICAgICBzZW5zaXRpdml0eTogJ3ZhcmlhbnQnLFxuICAgICAgICBpZ25vcmVQdW5jdHVhdGlvbjogZmFsc2UsXG4gICAgICAgIG51bWVyaWM6IGZhbHNlLFxuICAgICAgICBjYXNlRmlyc3Q6ICdsb3dlcidcbiAgICAgIH07XG4gICAgICByZXR1cm4geC5wdWJrZXkudG9CYXNlNTgoKS5sb2NhbGVDb21wYXJlKHkucHVia2V5LnRvQmFzZTU4KCksICdlbicsIG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gTW92ZSBmZWUgcGF5ZXIgdG8gdGhlIGZyb250XG4gICAgY29uc3QgZmVlUGF5ZXJJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoZmVlUGF5ZXIpO1xuICAgIH0pO1xuICAgIGlmIChmZWVQYXllckluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IFtwYXllck1ldGFdID0gdW5pcXVlTWV0YXMuc3BsaWNlKGZlZVBheWVySW5kZXgsIDEpO1xuICAgICAgcGF5ZXJNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgIHBheWVyTWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQocGF5ZXJNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdCh7XG4gICAgICAgIHB1YmtleTogZmVlUGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyB1bmtub3duIHNpZ25lcnNcbiAgICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKHNpZ25hdHVyZS5wdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICBpZiAoIXVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lcikge1xuICAgICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUcmFuc2FjdGlvbiByZWZlcmVuY2VzIGEgc2lnbmF0dXJlIHRoYXQgaXMgdW5uZWNlc3NhcnksICcgKyAnb25seSB0aGUgZmVlIHBheWVyIGFuZCBpbnN0cnVjdGlvbiBzaWduZXIgYWNjb3VudHMgc2hvdWxkIHNpZ24gYSB0cmFuc2FjdGlvbi4gJyArICdUaGlzIGJlaGF2aW9yIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiByZWxlYXNlLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSAwO1xuXG4gICAgLy8gU3BsaXQgb3V0IHNpZ25pbmcgZnJvbSBub24tc2lnbmluZyBrZXlzIGFuZCBjb3VudCBoZWFkZXIgdmFsdWVzXG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IFtdO1xuICAgIGNvbnN0IHVuc2lnbmVkS2V5cyA9IFtdO1xuICAgIHVuaXF1ZU1ldGFzLmZvckVhY2goKHtcbiAgICAgIHB1YmtleSxcbiAgICAgIGlzU2lnbmVyLFxuICAgICAgaXNXcml0YWJsZVxuICAgIH0pID0+IHtcbiAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICBzaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMgKz0gMTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBzaWduZWRLZXlzLmNvbmNhdCh1bnNpZ25lZEtleXMpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb2dyYW1JZFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGFjY291bnRLZXlzLmluZGV4T2YocHJvZ3JhbUlkLnRvU3RyaW5nKCkpLFxuICAgICAgICBhY2NvdW50czogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBhY2NvdW50S2V5cy5pbmRleE9mKG1ldGEucHVia2V5LnRvU3RyaW5nKCkpKSxcbiAgICAgICAgZGF0YTogYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmVuY29kZShkYXRhKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb21waWxlZEluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGFzc2VydChpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCA+PSAwKTtcbiAgICAgIGluc3RydWN0aW9uLmFjY291bnRzLmZvckVhY2goa2V5SW5kZXggPT4gYXNzZXJ0KGtleUluZGV4ID49IDApKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2Uoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICB9LFxuICAgICAgYWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpO1xuICAgIGNvbnN0IHNpZ25lZEtleXMgPSBtZXNzYWdlLmFjY291bnRLZXlzLnNsaWNlKDAsIG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPT09IHNpZ25lZEtleXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHRoaXMuc2lnbmF0dXJlcy5ldmVyeSgocGFpciwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIHNpZ25lZEtleXNbaW5kZXhdLmVxdWFscyhwYWlyLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh2YWxpZCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21waWxlKCkuc2VyaWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlc3RpbWF0ZWQgZmVlIGFzc29jaWF0ZWQgd2l0aCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvbiBDb25uZWN0aW9uIHRvIFJQQyBFbmRwb2ludC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldEVzdGltYXRlZEZlZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIChhd2FpdCBjb25uZWN0aW9uLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKSkudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmeSB0aGUgcHVibGljIGtleXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHNpZ24gdGhlIFRyYW5zYWN0aW9uLlxuICAgKiBUaGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZCBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAqXG4gICAqIFNpZ25hdHVyZXMgY2FuIGJlIGFkZGVkIHdpdGggZWl0aGVyIGBwYXJ0aWFsU2lnbmAgb3IgYGFkZFNpZ25hdHVyZWBcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MC44NC4wLiBPbmx5IHRoZSBmZWUgcGF5ZXIgbmVlZHMgdG8gYmVcbiAgICogc3BlY2lmaWVkIGFuZCBpdCBjYW4gYmUgc2V0IGluIHRoZSBUcmFuc2FjdGlvbiBjb25zdHJ1Y3RvciBvciB3aXRoIHRoZVxuICAgKiBgZmVlUGF5ZXJgIHByb3BlcnR5LlxuICAgKi9cbiAgc2V0U2lnbmVycyguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZXJzLmZpbHRlcihwdWJsaWNLZXkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gcHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS5tYXAocHVibGljS2V5ID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXlcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAqIGJlIGFwcGxpZWQgdG8gYSBUcmFuc2FjdGlvbi4gVGhlIGZpcnN0IHNpZ25hdHVyZSBpcyBjb25zaWRlcmVkIFwicHJpbWFyeVwiXG4gICAqIGFuZCBpcyB1c2VkIGlkZW50aWZ5IGFuZCBjb25maXJtIHRyYW5zYWN0aW9ucy5cbiAgICpcbiAgICogSWYgdGhlIFRyYW5zYWN0aW9uIGBmZWVQYXllcmAgaXMgbm90IHNldCwgdGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBUcmFuc2FjdGlvbiBmaWVsZHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBhZnRlciB0aGUgZmlyc3QgY2FsbCB0byBgc2lnbmAsXG4gICAqIGFzIGRvaW5nIHNvIG1heSBpbnZhbGlkYXRlIHRoZSBzaWduYXR1cmUgYW5kIGNhdXNlIHRoZSBUcmFuc2FjdGlvbiB0byBiZVxuICAgKiByZWplY3RlZC5cbiAgICpcbiAgICogVGhlIFRyYW5zYWN0aW9uIG11c3QgYmUgYXNzaWduZWQgYSB2YWxpZCBgcmVjZW50QmxvY2toYXNoYCBiZWZvcmUgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzaWduKC4uLnNpZ25lcnMpIHtcbiAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgIH1cblxuICAgIC8vIERlZHVwZSBzaWduZXJzXG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1bmlxdWVTaWduZXJzID0gW107XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdW5pcXVlU2lnbmVycy5tYXAoc2lnbmVyID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IHNpZ25lci5wdWJsaWNLZXlcbiAgICB9KSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9wYXJ0aWFsU2lnbihtZXNzYWdlLCAuLi51bmlxdWVTaWduZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY2NvdW50cy4gQWxsIGFjY291bnRzIG11c3RcbiAgICogY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEFsbCB0aGUgY2F2ZWF0cyBmcm9tIHRoZSBgc2lnbmAgbWV0aG9kIGFwcGx5IHRvIGBwYXJ0aWFsU2lnbmBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwYXJ0aWFsU2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfcGFydGlhbFNpZ24obWVzc2FnZSwgLi4uc2lnbmVycykge1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ24oc2lnbkRhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgICAgdGhpcy5fYWRkU2lnbmF0dXJlKHNpZ25lci5wdWJsaWNLZXksIHRvQnVmZmVyKHNpZ25hdHVyZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgUHVibGljIGtleSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlIEFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGFkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIHRoaXMuX2NvbXBpbGUoKTsgLy8gRW5zdXJlIHNpZ25hdHVyZXMgYXJyYXkgaXMgcG9wdWxhdGVkXG4gICAgdGhpcy5fYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9hZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleChzaWdwYWlyID0+IHB1YmtleS5lcXVhbHMoc2lncGFpci5wdWJsaWNLZXkpKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3B1YmtleS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXNbaW5kZXhdLnNpZ25hdHVyZSA9IGJ1ZmZlci5CdWZmZXIuZnJvbShzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmVzIG9mIGEgVHJhbnNhY3Rpb25cbiAgICogT3B0aW9uYWwgcGFyYW1ldGVyIHNwZWNpZmllcyBpZiB3ZSdyZSBleHBlY3RpbmcgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gb3IgYSBwYXJ0aWFsbHkgc2lnbmVkIG9uZS5cbiAgICogSWYgbm8gYm9vbGVhbiBpcyBwcm92aWRlZCwgd2UgZXhwZWN0IGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVpcmVBbGxTaWduYXR1cmVzPXRydWVdIFJlcXVpcmUgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZXMocmVxdWlyZUFsbFNpZ25hdHVyZXMgPSB0cnVlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnModGhpcy5zZXJpYWxpemVNZXNzYWdlKCksIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICByZXR1cm4gIXNpZ25hdHVyZUVycm9ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhtZXNzYWdlLCByZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgIGNvbnN0IGVycm9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcHVibGljS2V5XG4gICAgfSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGlmIChzaWduYXR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgICAgICAgKGVycm9ycy5taXNzaW5nIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleS50b0J5dGVzKCkpKSB7XG4gICAgICAgICAgKGVycm9ycy5pbnZhbGlkIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMuaW52YWxpZCB8fCBlcnJvcnMubWlzc2luZyA/IGVycm9ycyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIFRyYW5zYWN0aW9uIGluIHRoZSB3aXJlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtjb25maWddIENvbmZpZyBvZiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn0gU2lnbmF0dXJlIG9mIHRyYW5zYWN0aW9uIGluIHdpcmUgZm9ybWF0LlxuICAgKi9cbiAgc2VyaWFsaXplKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiB0cnVlLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlczogdHJ1ZVxuICAgIH0sIGNvbmZpZyk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKTtcbiAgICBpZiAodmVyaWZ5U2lnbmF0dXJlcykge1xuICAgICAgY29uc3Qgc2lnRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMoc2lnbkRhdGEsIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICAgIGlmIChzaWdFcnJvcnMpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZC4nO1xuICAgICAgICBpZiAoc2lnRXJyb3JzLmludmFsaWQpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbkludmFsaWQgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMuaW52YWxpZC5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMuaW52YWxpZC5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ0Vycm9ycy5taXNzaW5nKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5NaXNzaW5nIHNpZ25hdHVyZSBmb3IgcHVibGljIGtleSR7c2lnRXJyb3JzLm1pc3NpbmcubGVuZ3RoID09PSAxID8gJycgOiAnKHMpJ30gW1xcYCR7c2lnRXJyb3JzLm1pc3NpbmcubWFwKHAgPT4gcC50b0Jhc2U1OCgpKS5qb2luKCdgLCBgJyl9XFxgXS5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoc2lnbkRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYXR1cmVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoc2lnbmF0dXJlQ291bnQsIHNpZ25hdHVyZXMubGVuZ3RoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkxlbmd0aCA9IHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQgKyBzaWduRGF0YS5sZW5ndGg7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gYnVmZmVyLkJ1ZmZlci5hbGxvYyh0cmFuc2FjdGlvbkxlbmd0aCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoIDwgMjU2KTtcbiAgICBidWZmZXIuQnVmZmVyLmZyb20oc2lnbmF0dXJlQ291bnQpLmNvcHkod2lyZVRyYW5zYWN0aW9uLCAwKTtcbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUubGVuZ3RoID09PSA2NCwgYHNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhgKTtcbiAgICAgICAgYnVmZmVyLkJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIGluZGV4ICogNjQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNpZ25EYXRhLmNvcHkod2lyZVRyYW5zYWN0aW9uLCBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0KTtcbiAgICBhc3NlcnQod2lyZVRyYW5zYWN0aW9uLmxlbmd0aCA8PSBQQUNLRVRfREFUQV9TSVpFLCBgVHJhbnNhY3Rpb24gdG9vIGxhcmdlOiAke3dpcmVUcmFuc2FjdGlvbi5sZW5ndGh9ID4gJHtQQUNLRVRfREFUQV9TSVpFfWApO1xuICAgIHJldHVybiB3aXJlVHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQga2V5cygpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ua2V5cy5tYXAoa2V5T2JqID0+IGtleU9iai5wdWJrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IHByb2dyYW1JZCgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ucHJvZ3JhbUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSB3aXJlIHRyYW5zYWN0aW9uIGludG8gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj59IGJ1ZmZlciBTaWduYXR1cmUgb2Ygd2lyZSBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIkMSkge1xuICAgIC8vIFNsaWNlIHVwIHdpcmUgZGF0YVxuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uYnVmZmVyJDFdO1xuICAgIGNvbnN0IHNpZ25hdHVyZUNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IHNpZ25hdHVyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgIHNpZ25hdHVyZXMucHVzaChiczU4X19kZWZhdWx0LmRlZmF1bHQuZW5jb2RlKGJ1ZmZlci5CdWZmZXIuZnJvbShzaWduYXR1cmUpKSk7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShNZXNzYWdlLmZyb20oYnl0ZUFycmF5KSwgc2lnbmF0dXJlcyk7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gbWVzc2FnZSBhbmQgc2lnbmF0dXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSBvZiB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNpZ25hdHVyZXMgTGlzdCBvZiBzaWduYXR1cmVzIHRvIGFzc2lnbiB0byB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUaGUgcG9wdWxhdGVkIFRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgcG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcyA9IFtdKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICBpZiAobWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBtZXNzYWdlLmFjY291bnRLZXlzWzBdO1xuICAgIH1cbiAgICBzaWduYXR1cmVzLmZvckVhY2goKHNpZ25hdHVyZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ1B1YmtleVBhaXIgPSB7XG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID09IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5lbmNvZGUoREVGQVVMVF9TSUdOQVRVUkUpID8gbnVsbCA6IGJzNThfX2RlZmF1bHQuZGVmYXVsdC5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgcHVibGljS2V5OiBtZXNzYWdlLmFjY291bnRLZXlzW2luZGV4XVxuICAgICAgfTtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlLmluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoYWNjb3VudCA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG1lc3NhZ2UuYWNjb3VudEtleXNbYWNjb3VudF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnNvbWUoa2V5T2JqID0+IGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCkpIHx8IG1lc3NhZ2UuaXNBY2NvdW50U2lnbmVyKGFjY291bnQpLFxuICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXhdLFxuICAgICAgICBkYXRhOiBiczU4X19kZWZhdWx0LmRlZmF1bHQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRyYW5zYWN0aW9uLl9qc29uID0gdHJhbnNhY3Rpb24udG9KU09OKCk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLnBheWVyS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXJLZXkgPSBhcmdzLnBheWVyS2V5O1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgfVxuICBzdGF0aWMgZGVjb21waWxlKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBoZWFkZXIsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgIHJlY2VudEJsb2NraGFzaFxuICAgIH0gPSBtZXNzYWdlO1xuICAgIGNvbnN0IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcbiAgICB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgIGFzc2VydChudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzID4gMCwgJ01lc3NhZ2UgaGVhZGVyIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPSBtZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCAtIG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICBhc3NlcnQobnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID49IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBtZXNzYWdlLmdldEFjY291bnRLZXlzKGFyZ3MpO1xuICAgIGNvbnN0IHBheWVyS2V5ID0gYWNjb3VudEtleXMuZ2V0KDApO1xuICAgIGlmIChwYXllcktleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkZWNvbXBpbGUgbWVzc2FnZSBiZWNhdXNlIG5vIGFjY291bnQga2V5cyB3ZXJlIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29tcGlsZWRJeCBvZiBjb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBrZXlJbmRleCBvZiBjb21waWxlZEl4LmFjY291bnRLZXlJbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGFjY291bnRLZXlzLmdldChrZXlJbmRleCk7XG4gICAgICAgIGlmIChwdWJrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQga2V5IGZvciBhY2NvdW50IGtleSBpbmRleCAke2tleUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU2lnbmVyID0ga2V5SW5kZXggPCBudW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgICAgIGxldCBpc1dyaXRhYmxlO1xuICAgICAgICBpZiAoaXNTaWduZXIpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUluZGV4IDwgYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCAtIGFjY291bnRLZXlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCA8XG4gICAgICAgICAgLy8gYWNjb3VudEtleXNGcm9tTG9va3VwcyBjYW5ub3QgYmUgdW5kZWZpbmVkIGJlY2F1c2Ugd2UgYWxyZWFkeSBmb3VuZCBhIHB1YmtleSBmb3IgdGhpcyBpbmRleCBhYm92ZVxuICAgICAgICAgIGFjY291bnRLZXlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBrZXlJbmRleCA8IGhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgICAgaXNXcml0YWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2dyYW1JZCA9IGFjY291bnRLZXlzLmdldChjb21waWxlZEl4LnByb2dyYW1JZEluZGV4KTtcbiAgICAgIGlmIChwcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIHByb2dyYW0gaWQgZm9yIHByb2dyYW0gaWQgaW5kZXggJHtjb21waWxlZEl4LnByb2dyYW1JZEluZGV4fWApO1xuICAgICAgfVxuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IHRvQnVmZmVyKGNvbXBpbGVkSXguZGF0YSksXG4gICAgICAgIGtleXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbk1lc3NhZ2Uoe1xuICAgICAgcGF5ZXJLZXksXG4gICAgICBpbnN0cnVjdGlvbnMsXG4gICAgICByZWNlbnRCbG9ja2hhc2hcbiAgICB9KTtcbiAgfVxuICBjb21waWxlVG9MZWdhY3lNZXNzYWdlKCkge1xuICAgIHJldHVybiBNZXNzYWdlLmNvbXBpbGUoe1xuICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IHRoaXMucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNvbXBpbGVUb1YwTWVzc2FnZShhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgIHJldHVybiBNZXNzYWdlVjAuY29tcGlsZSh7XG4gICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLFxuICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHNcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcnNpb25lZCB0cmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBWZXJzaW9uZWRUcmFuc2FjdGlvbiB7XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UudmVyc2lvbjtcbiAgfVxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzaWduYXR1cmVzKSB7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gdm9pZCAwO1xuICAgIHRoaXMubWVzc2FnZSA9IHZvaWQgMDtcbiAgICBpZiAoc2lnbmF0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlcy5sZW5ndGggPT09IG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcywgJ0V4cGVjdGVkIHNpZ25hdHVyZXMgbGVuZ3RoIHRvIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgcmVxdWlyZWQgc2lnbmF0dXJlcycpO1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdFNpZ25hdHVyZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzOyBpKyspIHtcbiAgICAgICAgZGVmYXVsdFNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBkZWZhdWx0U2lnbmF0dXJlcztcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3QgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKHNpZ25hdHVyZSgpLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLCAnc2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5ibG9iKHNlcmlhbGl6ZWRNZXNzYWdlLmxlbmd0aCwgJ3NlcmlhbGl6ZWRNZXNzYWdlJyldKTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBuZXcgVWludDhBcnJheSgyMDQ4KTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGggPSB0cmFuc2FjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoKSxcbiAgICAgIHNpZ25hdHVyZXM6IHRoaXMuc2lnbmF0dXJlcyxcbiAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlXG4gICAgfSwgc2VyaWFsaXplZFRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZFRyYW5zYWN0aW9uLnNsaWNlKDAsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uXTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gW107XG4gICAgY29uc3Qgc2lnbmF0dXJlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBzaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSkpO1xuICAgIHJldHVybiBuZXcgVmVyc2lvbmVkVHJhbnNhY3Rpb24obWVzc2FnZSwgc2lnbmF0dXJlcyk7XG4gIH1cbiAgc2lnbihzaWduZXJzKSB7XG4gICAgY29uc3QgbWVzc2FnZURhdGEgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhzaWduZXIucHVibGljS2V5KSk7XG4gICAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbm5vdCBzaWduIHdpdGggbm9uIHNpZ25lciBrZXkgJHtzaWduZXIucHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbihtZXNzYWdlRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgfVxuICB9XG4gIGFkZFNpZ25hdHVyZShwdWJsaWNLZXksIHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUuYnl0ZUxlbmd0aCA9PT0gNjQsICdTaWduYXR1cmUgbXVzdCBiZSA2NCBieXRlcyBsb25nJyk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhwdWJsaWNLZXkpKTtcbiAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbiBub3QgYWRkIHNpZ25hdHVyZTsgXFxgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1cXGAgaXMgbm90IHJlcXVpcmVkIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvbmApO1xuICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduYXR1cmU7XG4gIH1cbn1cblxuLy8gVE9ETzogVGhlc2UgY29uc3RhbnRzIHNob3VsZCBiZSByZW1vdmVkIGluIGZhdm9yIG9mIHJlYWRpbmcgdGhlbSBvdXQgb2YgYVxuLy8gU3lzY2FsbCBhY2NvdW50XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9USUNLU19QRVJfU0VDT05EID0gMTYwO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UID0gNjQ7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9TTE9UU19QRVJfU0VDT05EID0gTlVNX1RJQ0tTX1BFUl9TRUNPTkQgLyBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBNU19QRVJfU0xPVCA9IDEwMDAgLyBOVU1fU0xPVFNfUEVSX1NFQ09ORDtcblxuY29uc3QgU1lTVkFSX0NMT0NLX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckMxb2NrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJFcG9jaFNjaGVkdTFlMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhcjFuc3RydWN0aW9uczExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVjZW50QjFvY2tIYXNoZXMxMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFTlRfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVudDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFV0FSRFNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmV3YXJkczExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIYXNoZXMxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyU3Rha2VIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG5jbGFzcyBTZW5kVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGFjdGlvbixcbiAgICBzaWduYXR1cmUsXG4gICAgdHJhbnNhY3Rpb25NZXNzYWdlLFxuICAgIGxvZ3NcbiAgfSkge1xuICAgIGNvbnN0IG1heWJlTG9nc091dHB1dCA9IGxvZ3MgPyBgTG9nczogXFxuJHtKU09OLnN0cmluZ2lmeShsb2dzLnNsaWNlKC0xMCksIG51bGwsIDIpfS4gYCA6ICcnO1xuICAgIGNvbnN0IGd1aWRlVGV4dCA9ICdcXG5DYXRjaCB0aGUgYFNlbmRUcmFuc2FjdGlvbkVycm9yYCBhbmQgY2FsbCBgZ2V0TG9ncygpYCBvbiBpdCBmb3IgZnVsbCBkZXRhaWxzLic7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3NlbmQnOlxuICAgICAgICBtZXNzYWdlID0gYFRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSByZXN1bHRlZCBpbiBhbiBlcnJvci4gXFxuYCArIGAke3RyYW5zYWN0aW9uTWVzc2FnZX0uIGAgKyBtYXliZUxvZ3NPdXRwdXQgKyBndWlkZVRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2ltdWxhdGUnOlxuICAgICAgICBtZXNzYWdlID0gYFNpbXVsYXRpb24gZmFpbGVkLiBcXG5NZXNzYWdlOiAke3RyYW5zYWN0aW9uTWVzc2FnZX0uIFxcbmAgKyBtYXliZUxvZ3NPdXRwdXQgKyBndWlkZVRleHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgVW5rbm93biBhY3Rpb24gJyR7KGEgPT4gYSkoYWN0aW9uKX0nYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTWVzc2FnZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IHZvaWQgMDtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTWVzc2FnZSA9IHRyYW5zYWN0aW9uTWVzc2FnZTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IGxvZ3MgPyBsb2dzIDogdW5kZWZpbmVkO1xuICB9XG4gIGdldCB0cmFuc2FjdGlvbkVycm9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiB0aGlzLnRyYW5zYWN0aW9uTWVzc2FnZSxcbiAgICAgIGxvZ3M6IEFycmF5LmlzQXJyYXkodGhpcy50cmFuc2FjdGlvbkxvZ3MpID8gdGhpcy50cmFuc2FjdGlvbkxvZ3MgOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyogQGRlcHJlY2F0ZWQgVXNlIGBhd2FpdCBnZXRMb2dzKClgIGluc3RlYWQgKi9cbiAgZ2V0IGxvZ3MoKSB7XG4gICAgY29uc3QgY2FjaGVkTG9ncyA9IHRoaXMudHJhbnNhY3Rpb25Mb2dzO1xuICAgIGlmIChjYWNoZWRMb2dzICE9IG51bGwgJiYgdHlwZW9mIGNhY2hlZExvZ3MgPT09ICdvYmplY3QnICYmICd0aGVuJyBpbiBjYWNoZWRMb2dzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkTG9ncztcbiAgfVxuICBhc3luYyBnZXRMb2dzKGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50cmFuc2FjdGlvbkxvZ3MpKSB7XG4gICAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdGlvbi5nZXRUcmFuc2FjdGlvbih0aGlzLnNpZ25hdHVyZSkudGhlbih0eCA9PiB7XG4gICAgICAgICAgaWYgKHR4ICYmIHR4Lm1ldGEgJiYgdHgubWV0YS5sb2dNZXNzYWdlcykge1xuICAgICAgICAgICAgY29uc3QgbG9ncyA9IHR4Lm1ldGEubG9nTWVzc2FnZXM7XG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uTG9ncyA9IGxvZ3M7XG4gICAgICAgICAgICByZXNvbHZlKGxvZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdMb2cgbWVzc2FnZXMgbm90IGZvdW5kJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2FjdGlvbkxvZ3M7XG4gIH1cbn1cblxuLy8gS2VlcCBpbiBzeW5jIHdpdGggY2xpZW50L3NyYy9ycGNfY3VzdG9tX2Vycm9ycy5yc1xuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSA9IHtcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6IC0zMjAwMSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkU6IC0zMjAwMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDAzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRTogLTMyMDA0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFk6IC0zMjAwNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwNixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDogLTMyMDA3LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1Q6IC0zMjAwOCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRDogLTMyMDA5LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOiAtMzIwMTAsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEU6IC0zMjAxMSxcbiAgSlNPTl9SUENfU0NBTl9FUlJPUjogLTMyMDEyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSDogLTMyMDEzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUOiAtMzIwMTQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OOiAtMzIwMTUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEOiAtMzIwMTZcbn07XG5jbGFzcyBTb2xhbmFKU09OUlBDRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2UsXG4gICAgZGF0YVxuICB9LCBjdXN0b21NZXNzYWdlKSB7XG4gICAgc3VwZXIoY3VzdG9tTWVzc2FnZSAhPSBudWxsID8gYCR7Y3VzdG9tTWVzc2FnZX06ICR7bWVzc2FnZX1gIDogbWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5uYW1lID0gJ1NvbGFuYUpTT05SUENFcnJvcic7XG4gIH1cbn1cblxuLyoqXG4gKiBTaWduLCBzZW5kIGFuZCBjb25maXJtIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogSWYgYGNvbW1pdG1lbnRgIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byAnbWF4JyBjb21taXRtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVyc1xuICogQHBhcmFtIHtDb25maXJtT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvblNpZ25hdHVyZT59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIHNpZ25lcnMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3RcbiAgfTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHNpZ25lcnMsIHNlbmRPcHRpb25zKTtcbiAgbGV0IHN0YXR1cztcbiAgaWYgKHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ICE9IG51bGwpIHtcbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnM/LmFib3J0U2lnbmFsLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICBibG9ja2hhc2g6IHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodFxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSBpZiAodHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAhPSBudWxsKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9uY2VJbnN0cnVjdGlvblxuICAgIH0gPSB0cmFuc2FjdGlvbi5ub25jZUluZm87XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50UHVia2V5ID0gbm9uY2VJbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleTtcbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnM/LmFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3Q6IHRyYW5zYWN0aW9uLm1pbk5vbmNlQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlOiB0cmFuc2FjdGlvbi5ub25jZUluZm8ubm9uY2UsXG4gICAgICBzaWduYXR1cmVcbiAgICB9LCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRpb25zPy5hYm9ydFNpZ25hbCAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ3NlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oKTogQSB0cmFuc2FjdGlvbiB3aXRoIGEgZGVwcmVjYXRlZCBjb25maXJtYXRpb24gc3RyYXRlZ3kgd2FzICcgKyAnc3VwcGxpZWQgYWxvbmcgd2l0aCBhbiBgYWJvcnRTaWduYWxgLiBPbmx5IHRyYW5zYWN0aW9ucyBoYXZpbmcgYGxhc3RWYWxpZEJsb2NrSGVpZ2h0YCAnICsgJ29yIGEgY29tYmluYXRpb24gb2YgYG5vbmNlSW5mb2AgYW5kIGBtaW5Ob25jZUNvbnRleHRTbG90YCBhcmUgYWJvcnRhYmxlLicpO1xuICAgIH1cbiAgICBzdGF0dXMgPSAoYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCkpLnZhbHVlO1xuICB9XG4gIGlmIChzdGF0dXMuZXJyKSB7XG4gICAgaWYgKHNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246ICdzZW5kJyxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogYFN0YXR1czogKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vLyB6enpcbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFBvcHVsYXRlIGEgYnVmZmVyIG9mIGluc3RydWN0aW9uIGRhdGEgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZW5jb2RlRGF0YSh0eXBlLCBmaWVsZHMpIHtcbiAgY29uc3QgYWxsb2NMZW5ndGggPSB0eXBlLmxheW91dC5zcGFuID49IDAgPyB0eXBlLmxheW91dC5zcGFuIDogZ2V0QWxsb2ModHlwZSwgZmllbGRzKTtcbiAgY29uc3QgZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoYWxsb2NMZW5ndGgpO1xuICBjb25zdCBsYXlvdXRGaWVsZHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBpbnN0cnVjdGlvbjogdHlwZS5pbmRleFxuICB9LCBmaWVsZHMpO1xuICB0eXBlLmxheW91dC5lbmNvZGUobGF5b3V0RmllbGRzLCBkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIGluc3RydWN0aW9uIGRhdGEgYnVmZmVyIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEkMSh0eXBlLCBidWZmZXIpIHtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IHR5cGUubGF5b3V0LmRlY29kZShidWZmZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkYXRhLmluc3RydWN0aW9uICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBpbnN0cnVjdGlvbiBpbmRleCBtaXNtYXRjaCAke2RhdGEuaW5zdHJ1Y3Rpb259ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOTBiZWRkN2UwNjdiNWI4ZjNkZGJiNDVkYTAwYTRlOWNhYmIyMmM2Mi9zZGsvc3JjL2ZlZV9jYWxjdWxhdG9yLnJzI0w3LUwxMVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBGZWVDYWxjdWxhdG9yTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnU2NCgnbGFtcG9ydHNQZXJTaWduYXR1cmUnKTtcblxuLyoqXG4gKiBDYWxjdWxhdG9yIGZvciB0cmFuc2FjdGlvbiBmZWVzLlxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvMGVhMjg0M2VjOWNkYzUxNzU3MmI4ZTYyYzk1OWY0MWI1NWNmNDQ1My9zZGsvc3JjL25vbmNlX3N0YXRlLnJzI0wyOS1MMzJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTm9uY2VBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ3ZlcnNpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdzdGF0ZScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSwgcHVibGljS2V5KCdub25jZScpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0ZlZUNhbGN1bGF0b3JMYXlvdXRdLCAnZmVlQ2FsY3VsYXRvcicpXSk7XG5jb25zdCBOT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5vbmNlQWNjb3VudExheW91dC5zcGFuO1xuXG4vKipcbiAqIEEgZHVyYWJsZSBub25jZSBpcyBhIDMyIGJ5dGUgdmFsdWUgZW5jb2RlZCBhcyBhIGJhc2U1OCBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBOb25jZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgTm9uY2VBY2NvdW50IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLm5vbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuZmVlQ2FsY3VsYXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRQdWJrZXkgPSBhcmdzLmF1dGhvcml6ZWRQdWJrZXk7XG4gICAgdGhpcy5ub25jZSA9IGFyZ3Mubm9uY2U7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gYXJncy5mZWVDYWxjdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIE5vbmNlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gTm9uY2VBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IG5vbmNlQWNjb3VudCA9IE5vbmNlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgMCk7XG4gICAgcmV0dXJuIG5ldyBOb25jZUFjY291bnQoe1xuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQuYXV0aG9yaXplZFB1YmtleSksXG4gICAgICBub25jZTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQubm9uY2UpLnRvU3RyaW5nKCksXG4gICAgICBmZWVDYWxjdWxhdG9yOiBub25jZUFjY291bnQuZmVlQ2FsY3VsYXRvclxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IGVuY29kZURlY29kZSA9IGxheW91dCA9PiB7XG4gIGNvbnN0IGRlY29kZSA9IGxheW91dC5kZWNvZGUuYmluZChsYXlvdXQpO1xuICBjb25zdCBlbmNvZGUgPSBsYXlvdXQuZW5jb2RlLmJpbmQobGF5b3V0KTtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlXG4gIH07XG59O1xuY29uc3QgYmlnSW50ID0gbGVuZ3RoID0+IHByb3BlcnR5ID0+IHtcbiAgY29uc3QgbGF5b3V0ID0gQnVmZmVyTGF5b3V0LmJsb2IobGVuZ3RoLCBwcm9wZXJ0eSk7XG4gIGNvbnN0IHtcbiAgICBlbmNvZGUsXG4gICAgZGVjb2RlXG4gIH0gPSBlbmNvZGVEZWNvZGUobGF5b3V0KTtcbiAgY29uc3QgYmlnSW50TGF5b3V0ID0gbGF5b3V0O1xuICBiaWdJbnRMYXlvdXQuZGVjb2RlID0gKGJ1ZmZlciQxLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBzcmMgPSBkZWNvZGUoYnVmZmVyJDEsIG9mZnNldCk7XG4gICAgcmV0dXJuIGJpZ2ludEJ1ZmZlci50b0JpZ0ludExFKGJ1ZmZlci5CdWZmZXIuZnJvbShzcmMpKTtcbiAgfTtcbiAgYmlnSW50TGF5b3V0LmVuY29kZSA9IChiaWdJbnQsIGJ1ZmZlciwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3Qgc3JjID0gYmlnaW50QnVmZmVyLnRvQnVmZmVyTEUoYmlnSW50LCBsZW5ndGgpO1xuICAgIHJldHVybiBlbmNvZGUoc3JjLCBidWZmZXIsIG9mZnNldCk7XG4gIH07XG4gIHJldHVybiBiaWdJbnRMYXlvdXQ7XG59O1xuY29uc3QgdTY0ID0gYmlnSW50KDgpO1xuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBZHZhbmNlIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlcldpdGhTZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKipcbiAqIFN5c3RlbSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBTeXN0ZW1JbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3lzdGVtSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY3JlYXRlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUNyZWF0ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB0cmFuc2ZlciBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlVHJhbnNmZXIoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXIsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB0cmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhbGxvY2F0ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBzcGFjZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHNwYWNlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBbGxvY2F0ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgYmFzZSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBc3NpZ24oaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbiwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhc3NpZ24gd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBc3NpZ25XaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY3JlYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGluaXRpYWxpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlSW5pdGlhbGl6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhZHZhbmNlIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUFkdmFuY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWR2YW5jZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSB3aXRoZHJhdyBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhd05vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG5vbmNlIGF1dGhvcml6ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBTeXN0ZW1Qcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTeXN0ZW1JbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3lzdGVtIEluc3RydWN0aW9uVHlwZSdzXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbjoge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2Zlcjoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIENyZWF0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFkdmFuY2VOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgV2l0aGRyYXdOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA2LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQXV0aG9yaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBbGxvY2F0ZToge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ3NwYWNlJyldKVxuICB9LFxuICBBbGxvY2F0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDksXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2ZlcldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDExLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVXBncmFkZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiAxMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFN5c3RlbSBwcm9ncmFtXG4gKi9cbmNsYXNzIFN5c3RlbVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICAgKi9cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCB0cmFuc2ZlcnMgbGFtcG9ydHMgZnJvbSBvbmUgYWNjb3VudCB0byBhbm90aGVyXG4gICAqL1xuICBzdGF0aWMgdHJhbnNmZXIocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cyksXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcjtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhc3NpZ25zIGFuIGFjY291bnQgdG8gYSBwcm9ncmFtXG4gICAqL1xuICBzdGF0aWMgYXNzaWduKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbjtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHByb2dyYW1JZFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgbGV0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG4gICAgaWYgKCFwYXJhbXMuYmFzZVB1YmtleS5lcXVhbHMocGFyYW1zLmZyb21QdWJrZXkpKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZU5vbmNlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zICYmICdzZWVkJyBpbiBwYXJhbXMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnRXaXRoU2VlZCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGJhc2VQdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdFBhcmFtcyA9IHtcbiAgICAgIG5vbmNlUHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleVxuICAgIH07XG4gICAgdHJhbnNhY3Rpb24uYWRkKHRoaXMubm9uY2VJbml0aWFsaXplKGluaXRQYXJhbXMpKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gdG8gaW5pdGlhbGl6ZSBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLmF1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpbnN0cnVjdGlvbkRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGFkdmFuY2UgdGhlIG5vbmNlIGluIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlQWR2YW5jZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWR2YW5jZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgd2l0aGRyYXdzIGxhbXBvcnRzIGZyb20gYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VXaXRoZHJhdyhwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBQdWJsaWNLZXkgYXMgdGhlIGF1dGhvcml0eVxuICAgKiBvbiBhIE5vbmNlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgbm9uY2VBdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMubmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhbGxvY2F0ZXMgc3BhY2UgaW4gYW4gYWNjb3VudCB3aXRob3V0IGZ1bmRpbmdcbiAgICovXG4gIHN0YXRpYyBhbGxvY2F0ZShwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQ7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBzcGFjZTogcGFyYW1zLnNwYWNlXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vLyBLZWVwIHByb2dyYW0gY2h1bmtzIHVuZGVyIFBBQ0tFVF9EQVRBX1NJWkUsIGxlYXZpbmcgZW5vdWdoIHJvb20gZm9yIHRoZVxuLy8gcmVzdCBvZiB0aGUgVHJhbnNhY3Rpb24gZmllbGRzXG4vL1xuLy8gVE9ETzogcmVwbGFjZSAzMDAgd2l0aCBhIHByb3BlciBjb25zdGFudCBmb3IgdGhlIHNpemUgb2YgdGhlIG90aGVyXG4vLyBUcmFuc2FjdGlvbiBmaWVsZHNcbmNvbnN0IENIVU5LX1NJWkUgPSBQQUNLRVRfREFUQV9TSVpFIC0gMzAwO1xuXG4vKipcbiAqIFByb2dyYW0gbG9hZGVyIGludGVyZmFjZVxuICovXG5jbGFzcyBMb2FkZXIge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBwcm9ncmFtIGRhdGEgcGxhY2VkIGluIGVhY2ggbG9hZCBUcmFuc2FjdGlvblxuICAgKi9cblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBsb2FkIGEgcHJvZ3JhbSBub3QgaW5jbHVkaW5nXG4gICAqIHJldHJpZXNcbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRyYW5zYWN0aW9uIGZlZXNcbiAgICovXG4gIHN0YXRpYyBnZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpIHtcbiAgICByZXR1cm4gMiAqIChcbiAgICAvLyBFdmVyeSB0cmFuc2FjdGlvbiByZXF1aXJlcyB0d28gc2lnbmF0dXJlcyAocGF5ZXIgKyBwcm9ncmFtKVxuICAgIE1hdGguY2VpbChkYXRhTGVuZ3RoIC8gTG9hZGVyLmNodW5rU2l6ZSkgKyAxICtcbiAgICAvLyBBZGQgb25lIGZvciBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAxKSAvLyBBZGQgb25lIGZvciBGaW5hbGl6ZSB0cmFuc2FjdGlvblxuICAgIDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhIGdlbmVyaWMgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIFN5c3RlbSBhY2NvdW50IHRoYXQgcGF5cyB0byBsb2FkIHRoZSBwcm9ncmFtXG4gICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIGxvYWRlclxuICAgKiBAcGFyYW0gZGF0YSBQcm9ncmFtIG9jdGV0c1xuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBwcm9ncmFtSWQsIGRhdGEpIHtcbiAgICB7XG4gICAgICBjb25zdCBiYWxhbmNlTmVlZGVkID0gYXdhaXQgY29ubmVjdGlvbi5nZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oZGF0YS5sZW5ndGgpO1xuXG4gICAgICAvLyBGZXRjaCBwcm9ncmFtIGFjY291bnQgaW5mbyB0byBjaGVjayBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gYXdhaXQgY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyhwcm9ncmFtLnB1YmxpY0tleSwgJ2NvbmZpcm1lZCcpO1xuICAgICAgbGV0IHRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgIGlmIChwcm9ncmFtSW5mbyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZXhlY3V0YWJsZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2dyYW0gbG9hZCBmYWlsZWQsIGFjY291bnQgaXMgYWxyZWFkeSBleGVjdXRhYmxlJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtSW5mby5kYXRhLmxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFsbG9jYXRlKHtcbiAgICAgICAgICAgIGFjY291bnRQdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvZ3JhbUluZm8ub3duZXIuZXF1YWxzKHByb2dyYW1JZCkpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uIHx8IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmFzc2lnbih7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8ubGFtcG9ydHMgPCBiYWxhbmNlTmVlZGVkKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgICB0b1B1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCAtIHByb2dyYW1JbmZvLmxhbXBvcnRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCA+IDAgPyBiYWxhbmNlTmVlZGVkIDogMSxcbiAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgcHJvZ3JhbUlkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGFjY291bnQgaXMgYWxyZWFkeSBjcmVhdGVkIGNvcnJlY3RseSwgc2tpcCB0aGlzIHN0ZXBcbiAgICAgIC8vIGFuZCBwcm9jZWVkIGRpcmVjdGx5IHRvIGxvYWRpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgICBpZiAodHJhbnNhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignb2Zmc2V0JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignYnl0ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdieXRlc0xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdieXRlJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm9mZnNldChCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoKSwgLTgpLCAnYnl0ZXMnKV0pO1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IExvYWRlci5jaHVua1NpemU7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IGFycmF5ID0gZGF0YTtcbiAgICBsZXQgdHJhbnNhY3Rpb25zID0gW107XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXkuc2xpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKGNodW5rU2l6ZSArIDE2KTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDAsXG4gICAgICAgIC8vIExvYWQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBieXRlczogYnl0ZXMsXG4gICAgICAgIGJ5dGVzTGVuZ3RoOiAwLFxuICAgICAgICBieXRlc0xlbmd0aFBhZGRpbmc6IDBcbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRGVsYXkgYmV0d2VlbiBzZW5kcyBpbiBhbiBhdHRlbXB0IHRvIHJlZHVjZSByYXRlIGxpbWl0IGVycm9yc1xuICAgICAgaWYgKGNvbm5lY3Rpb24uX3JwY0VuZHBvaW50LmluY2x1ZGVzKCdzb2xhbmEuY29tJykpIHtcbiAgICAgICAgY29uc3QgUkVRVUVTVFNfUEVSX1NFQ09ORCA9IDQ7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDAgLyBSRVFVRVNUU19QRVJfU0VDT05EKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICBhcnJheSA9IGFycmF5LnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucyk7XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgYWNjb3VudCBsb2FkZWQgd2l0aCBwcm9ncmFtIGRhdGEgZm9yIGV4ZWN1dGlvblxuICAgIHtcbiAgICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pO1xuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5CdWZmZXIuYWxsb2MoZGF0YUxheW91dC5zcGFuKTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDEgLy8gRmluYWxpemUgaW5zdHJ1Y3Rpb25cbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGVwbG95Q29tbWl0bWVudCA9ICdwcm9jZXNzZWQnO1xuICAgICAgY29uc3QgZmluYWxpemVTaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZTogZmluYWxpemVTaWduYXR1cmUsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgICAgYmxvY2toYXNoOiB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2hcbiAgICAgIH0sIGRlcGxveUNvbW1pdG1lbnQpO1xuICAgICAgaWYgKHZhbHVlLmVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uICR7ZmluYWxpemVTaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9KWApO1xuICAgICAgfVxuICAgICAgLy8gV2UgcHJldmVudCBwcm9ncmFtcyBmcm9tIGJlaW5nIHVzYWJsZSB1bnRpbCB0aGUgc2xvdCBhZnRlciB0aGVpciBkZXBsb3ltZW50LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yOTY1NFxuICAgICAgd2hpbGUgKHRydWUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbG90ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRTbG90KHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGRlcGxveUNvbW1pdG1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY3VycmVudFNsb3QgPiBjb250ZXh0LnNsb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLyogZW1wdHkgKi9cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yb3VuZChNU19QRVJfU0xPVCAvIDIpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3VjY2Vzc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5Mb2FkZXIuY2h1bmtTaXplID0gQ0hVTktfU0laRTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS4xNy4yMC5cbiAqL1xuY29uc3QgQlBGX0xPQURFUl9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnQlBGTG9hZGVyMjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIGEgcHJvZ3JhbSBsb2FkZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS4xNy4yMC5cbiAqL1xuY2xhc3MgQnBmTG9hZGVyIHtcbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIExvYWRlci5nZXRNaW5OdW1TaWduYXR1cmVzKGRhdGFMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYSBTQkYgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICogQHBhcmFtIHBheWVyIEFjY291bnQgdGhhdCB3aWxsIHBheSBwcm9ncmFtIGxvYWRpbmcgZmVlc1xuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gZWxmIFRoZSBlbnRpcmUgRUxGIGNvbnRhaW5pbmcgdGhlIFNCRiBwcm9ncmFtXG4gICAqIEBwYXJhbSBsb2FkZXJQcm9ncmFtSWQgVGhlIHByb2dyYW0gaWQgb2YgdGhlIEJQRiBsb2FkZXIgdG8gdXNlXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBwcm9ncmFtIHdhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBwcm9ncmFtIHdhcyBhbHJlYWR5IGxvYWRlZFxuICAgKi9cbiAgc3RhdGljIGxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGVsZiwgbG9hZGVyUHJvZ3JhbUlkKSB7XG4gICAgcmV0dXJuIExvYWRlci5sb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBsb2FkZXJQcm9ncmFtSWQsIGVsZik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGFnZW50a2VlcGFsaXZlID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBtcztcbnZhciBoYXNSZXF1aXJlZE1zO1xuXG5mdW5jdGlvbiByZXF1aXJlTXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRNcykgcmV0dXJuIG1zO1xuXHRoYXNSZXF1aXJlZE1zID0gMTtcblx0dmFyIHMgPSAxMDAwO1xuXHR2YXIgbSA9IHMgKiA2MDtcblx0dmFyIGggPSBtICogNjA7XG5cdHZhciBkID0gaCAqIDI0O1xuXHR2YXIgdyA9IGQgKiA3O1xuXHR2YXIgeSA9IGQgKiAzNjUuMjU7XG5cblx0LyoqXG5cdCAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG5cdCAqXG5cdCAqIE9wdGlvbnM6XG5cdCAqXG5cdCAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG5cdCAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRtcyA9IGZ1bmN0aW9uICh2YWwsIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cdCAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG5cdCAgICByZXR1cm4gcGFyc2UodmFsKTtcblx0ICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcblx0ICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuXHQgIH1cblx0ICB0aHJvdyBuZXcgRXJyb3IoXG5cdCAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcblx0ICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuXHQgICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBwYXJzZShzdHIpIHtcblx0ICBzdHIgPSBTdHJpbmcoc3RyKTtcblx0ICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG5cdCAgICBzdHJcblx0ICApO1xuXHQgIGlmICghbWF0Y2gpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcblx0ICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuXHQgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSAneWVhcnMnOlxuXHQgICAgY2FzZSAneWVhcic6XG5cdCAgICBjYXNlICd5cnMnOlxuXHQgICAgY2FzZSAneXInOlxuXHQgICAgY2FzZSAneSc6XG5cdCAgICAgIHJldHVybiBuICogeTtcblx0ICAgIGNhc2UgJ3dlZWtzJzpcblx0ICAgIGNhc2UgJ3dlZWsnOlxuXHQgICAgY2FzZSAndyc6XG5cdCAgICAgIHJldHVybiBuICogdztcblx0ICAgIGNhc2UgJ2RheXMnOlxuXHQgICAgY2FzZSAnZGF5Jzpcblx0ICAgIGNhc2UgJ2QnOlxuXHQgICAgICByZXR1cm4gbiAqIGQ7XG5cdCAgICBjYXNlICdob3Vycyc6XG5cdCAgICBjYXNlICdob3VyJzpcblx0ICAgIGNhc2UgJ2hycyc6XG5cdCAgICBjYXNlICdocic6XG5cdCAgICBjYXNlICdoJzpcblx0ICAgICAgcmV0dXJuIG4gKiBoO1xuXHQgICAgY2FzZSAnbWludXRlcyc6XG5cdCAgICBjYXNlICdtaW51dGUnOlxuXHQgICAgY2FzZSAnbWlucyc6XG5cdCAgICBjYXNlICdtaW4nOlxuXHQgICAgY2FzZSAnbSc6XG5cdCAgICAgIHJldHVybiBuICogbTtcblx0ICAgIGNhc2UgJ3NlY29uZHMnOlxuXHQgICAgY2FzZSAnc2Vjb25kJzpcblx0ICAgIGNhc2UgJ3NlY3MnOlxuXHQgICAgY2FzZSAnc2VjJzpcblx0ICAgIGNhc2UgJ3MnOlxuXHQgICAgICByZXR1cm4gbiAqIHM7XG5cdCAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuXHQgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuXHQgICAgY2FzZSAnbXNlY3MnOlxuXHQgICAgY2FzZSAnbXNlYyc6XG5cdCAgICBjYXNlICdtcyc6XG5cdCAgICAgIHJldHVybiBuO1xuXHQgICAgZGVmYXVsdDpcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbXNcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcblx0ICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG5cdCAgaWYgKG1zQWJzID49IGQpIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBoKSB7XG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gbSkge1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcblx0ICB9XG5cdCAgaWYgKG1zQWJzID49IHMpIHtcblx0ICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG5cdCAgfVxuXHQgIHJldHVybiBtcyArICdtcyc7XG5cdH1cblxuXHQvKipcblx0ICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBmbXRMb25nKG1zKSB7XG5cdCAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuXHQgIGlmIChtc0FicyA+PSBkKSB7XG5cdCAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gaCkge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG5cdCAgfVxuXHQgIGlmIChtc0FicyA+PSBtKSB7XG5cdCAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuXHQgIH1cblx0ICBpZiAobXNBYnMgPj0gcykge1xuXHQgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcblx0ICB9XG5cdCAgcmV0dXJuIG1zICsgJyBtcyc7XG5cdH1cblxuXHQvKipcblx0ICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcblx0ICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuXHQgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xuXHR9XG5cdHJldHVybiBtcztcbn1cblxuLyohXG4gKiBodW1hbml6ZS1tcyAtIGluZGV4LmpzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBkZWFkX2hvcnNlIDxkZWFkX2hvcnNlQHFxLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBodW1hbml6ZU1zO1xudmFyIGhhc1JlcXVpcmVkSHVtYW5pemVNcztcblxuZnVuY3Rpb24gcmVxdWlyZUh1bWFuaXplTXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIdW1hbml6ZU1zKSByZXR1cm4gaHVtYW5pemVNcztcblx0aGFzUmVxdWlyZWRIdW1hbml6ZU1zID0gMTtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHV0aWwgPSByZXF1aXJlJCQwX19kZWZhdWx0LmRlZmF1bHQ7XG5cdHZhciBtcyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZU1zKCk7XG5cblx0aHVtYW5pemVNcyA9IGZ1bmN0aW9uICh0KSB7XG5cdCAgaWYgKHR5cGVvZiB0ID09PSAnbnVtYmVyJykgcmV0dXJuIHQ7XG5cdCAgdmFyIHIgPSBtcyh0KTtcblx0ICBpZiAociA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICB2YXIgZXJyID0gbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdodW1hbml6ZS1tcyglaikgcmVzdWx0IHVuZGVmaW5lZCcsIHQpKTtcblx0ICAgIGNvbnNvbGUud2FybihlcnIuc3RhY2spO1xuXHQgIH1cblx0ICByZXR1cm4gcjtcblx0fTtcblx0cmV0dXJuIGh1bWFuaXplTXM7XG59XG5cbnZhciBjb25zdGFudHM7XG52YXIgaGFzUmVxdWlyZWRDb25zdGFudHM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDb25zdGFudHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDb25zdGFudHMpIHJldHVybiBjb25zdGFudHM7XG5cdGhhc1JlcXVpcmVkQ29uc3RhbnRzID0gMTtcblxuXHRjb25zdGFudHMgPSB7XG5cdCAgLy8gYWdlbnRcblx0ICBDVVJSRU5UX0lEOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2N1cnJlbnRJZCcpLFxuXHQgIENSRUFURV9JRDogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVJZCcpLFxuXHQgIElOSVRfU09DS0VUOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI2luaXRTb2NrZXQnKSxcblx0ICBDUkVBVEVfSFRUUFNfQ09OTkVDVElPTjogU3ltYm9sKCdhZ2VudGtlZXBhbGl2ZSNjcmVhdGVIdHRwc0Nvbm5lY3Rpb24nKSxcblx0ICAvLyBzb2NrZXRcblx0ICBTT0NLRVRfQ1JFQVRFRF9USU1FOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldENyZWF0ZWRUaW1lJyksXG5cdCAgU09DS0VUX05BTUU6IFN5bWJvbCgnYWdlbnRrZWVwYWxpdmUjc29ja2V0TmFtZScpLFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0NPVU5UOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldFJlcXVlc3RDb3VudCcpLFxuXHQgIFNPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UOiBTeW1ib2woJ2FnZW50a2VlcGFsaXZlI3NvY2tldFJlcXVlc3RGaW5pc2hlZENvdW50JyksXG5cdH07XG5cdHJldHVybiBjb25zdGFudHM7XG59XG5cbnZhciBhZ2VudDtcbnZhciBoYXNSZXF1aXJlZEFnZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlQWdlbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRBZ2VudCkgcmV0dXJuIGFnZW50O1xuXHRoYXNSZXF1aXJlZEFnZW50ID0gMTtcblxuXHRjb25zdCBPcmlnaW5hbEFnZW50ID0gcmVxdWlyZSQkMF9fZGVmYXVsdCQxLmRlZmF1bHQuQWdlbnQ7XG5cdGNvbnN0IG1zID0gLypAX19QVVJFX18qLyByZXF1aXJlSHVtYW5pemVNcygpO1xuXHRjb25zdCBkZWJ1ZyA9IHJlcXVpcmUkJDBfX2RlZmF1bHQuZGVmYXVsdC5kZWJ1Z2xvZygnYWdlbnRrZWVwYWxpdmUnKTtcblx0Y29uc3Qge1xuXHQgIElOSVRfU09DS0VULFxuXHQgIENVUlJFTlRfSUQsXG5cdCAgQ1JFQVRFX0lELFxuXHQgIFNPQ0tFVF9DUkVBVEVEX1RJTUUsXG5cdCAgU09DS0VUX05BTUUsXG5cdCAgU09DS0VUX1JFUVVFU1RfQ09VTlQsXG5cdCAgU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQsXG5cdH0gPSAvKkBfX1BVUkVfXyovIHJlcXVpcmVDb25zdGFudHMoKTtcblxuXHQvLyBPcmlnaW5hbEFnZW50IGNvbWUgZnJvbVxuXHQvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjEyLjAvbGliL19odHRwX2FnZW50LmpzXG5cdC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjEyLjAvbGliL19odHRwX2FnZW50LmpzXG5cblx0Ly8gbm9kZSA8PSAxMFxuXHRsZXQgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ID0gMTtcblx0Y29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnNwbGl0KCcuJywgMSlbMF0uc3Vic3RyaW5nKDEpKTtcblx0aWYgKG1ham9yVmVyc2lvbiA+PSAxMSAmJiBtYWpvclZlcnNpb24gPD0gMTIpIHtcblx0ICBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQgPSAyO1xuXHR9IGVsc2UgaWYgKG1ham9yVmVyc2lvbiA+PSAxMykge1xuXHQgIGRlZmF1bHRUaW1lb3V0TGlzdGVuZXJDb3VudCA9IDM7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXByZWNhdGUobWVzc2FnZSkge1xuXHQgIGNvbnNvbGUubG9nKCdbYWdlbnRrZWVwYWxpdmU6ZGVwcmVjYXRlZF0gJXMnLCBtZXNzYWdlKTtcblx0fVxuXG5cdGNsYXNzIEFnZW50IGV4dGVuZHMgT3JpZ2luYWxBZ2VudCB7XG5cdCAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXHQgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgICBvcHRpb25zLmtlZXBBbGl2ZSA9IG9wdGlvbnMua2VlcEFsaXZlICE9PSBmYWxzZTtcblx0ICAgIC8vIGRlZmF1bHQgaXMga2VlcC1hbGl2ZSBhbmQgNHMgZnJlZSBzb2NrZXQgdGltZW91dFxuXHQgICAgLy8gc2VlIGh0dHBzOi8vbWVkaXVtLmNvbS9zc2Vuc2UtdGVjaC9yZWR1Y2UtbmV0d29ya2luZy1lcnJvcnMtaW4tbm9kZWpzLTIzYjRlYjlmMmQ4M1xuXHQgICAgaWYgKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gNDAwMDtcblx0ICAgIH1cblx0ICAgIC8vIExlZ2FjeSBBUEk6IGtlZXBBbGl2ZVRpbWVvdXQgc2hvdWxkIGJlIHJlbmFtZSB0byBgZnJlZVNvY2tldFRpbWVvdXRgXG5cdCAgICBpZiAob3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0KSB7XG5cdCAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5rZWVwQWxpdmVUaW1lb3V0IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2Ugb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCBpbnN0ZWFkJyk7XG5cdCAgICAgIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgPSBvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICAgIGRlbGV0ZSBvcHRpb25zLmtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICB9XG5cdCAgICAvLyBMZWdhY3kgQVBJOiBmcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBzaG91bGQgYmUgcmVuYW1lIHRvIGBmcmVlU29ja2V0VGltZW91dGBcblx0ICAgIGlmIChvcHRpb25zLmZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0KSB7XG5cdCAgICAgIGRlcHJlY2F0ZSgnb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgICBvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ID0gb3B0aW9ucy5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dDtcblx0ICAgICAgZGVsZXRlIG9wdGlvbnMuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICB9XG5cblx0ICAgIC8vIFNldHMgdGhlIHNvY2tldCB0byB0aW1lb3V0IGFmdGVyIHRpbWVvdXQgbWlsbGlzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gdGhlIHNvY2tldC5cblx0ICAgIC8vIEJ5IGRlZmF1bHQgaXMgZG91YmxlIGZyZWUgc29ja2V0IHRpbWVvdXQuXG5cdCAgICBpZiAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgLy8gbWFrZSBzdXJlIHNvY2tldCBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dCA+PSA4c1xuXHQgICAgICBvcHRpb25zLnRpbWVvdXQgPSBNYXRoLm1heChvcHRpb25zLmZyZWVTb2NrZXRUaW1lb3V0ICogMiwgODAwMCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIHN1cHBvcnQgaHVtYW5pemUgZm9ybWF0XG5cdCAgICBvcHRpb25zLnRpbWVvdXQgPSBtcyhvcHRpb25zLnRpbWVvdXQpO1xuXHQgICAgb3B0aW9ucy5mcmVlU29ja2V0VGltZW91dCA9IG1zKG9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQpO1xuXHQgICAgb3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgPSBvcHRpb25zLnNvY2tldEFjdGl2ZVRUTCA/IG1zKG9wdGlvbnMuc29ja2V0QWN0aXZlVFRMKSA6IDA7XG5cblx0ICAgIHN1cGVyKG9wdGlvbnMpO1xuXG5cdCAgICB0aGlzW0NVUlJFTlRfSURdID0gMDtcblxuXHQgICAgLy8gY3JlYXRlIHNvY2tldCBzdWNjZXNzIGNvdW50ZXJcblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCA9IDA7XG5cdCAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnRMYXN0Q2hlY2sgPSAwO1xuXG5cdCAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgLy8gc29ja2V0IGVycm9yIGV2ZW50IGNvdW50XG5cdCAgICB0aGlzLmVycm9yU29ja2V0Q291bnQgPSAwO1xuXHQgICAgdGhpcy5lcnJvclNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgLy8gcmVxdWVzdCBmaW5pc2hlZCBjb3VudGVyXG5cdCAgICB0aGlzLnJlcXVlc3RDb3VudCA9IDA7XG5cdCAgICB0aGlzLnJlcXVlc3RDb3VudExhc3RDaGVjayA9IDA7XG5cblx0ICAgIC8vIGluY2x1ZGluZyBmcmVlIHNvY2tldCB0aW1lb3V0IGNvdW50ZXJcblx0ICAgIHRoaXMudGltZW91dFNvY2tldENvdW50ID0gMDtcblx0ICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gMDtcblxuXHQgICAgdGhpcy5vbignZnJlZScsIHNvY2tldCA9PiB7XG5cdCAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMyMDAwXG5cdCAgICAgIC8vIE5vZGUuanMgbmF0aXZlIGFnZW50IHdpbGwgY2hlY2sgc29ja2V0IHRpbWVvdXQgZXFzIGFnZW50Lm9wdGlvbnMudGltZW91dC5cblx0ICAgICAgLy8gVXNlIHRoZSB0dGwgb3IgZnJlZVNvY2tldFRpbWVvdXQgdG8gb3ZlcndyaXRlLlxuXHQgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5jYWxjU29ja2V0VGltZW91dChzb2NrZXQpO1xuXHQgICAgICBpZiAodGltZW91dCA+IDAgJiYgc29ja2V0LnRpbWVvdXQgIT09IHRpbWVvdXQpIHtcblx0ICAgICAgICBzb2NrZXQuc2V0VGltZW91dCh0aW1lb3V0KTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgZ2V0IGZyZWVTb2NrZXRLZWVwQWxpdmVUaW1lb3V0KCkge1xuXHQgICAgZGVwcmVjYXRlKCdhZ2VudC5mcmVlU29ja2V0S2VlcEFsaXZlVGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMuZnJlZVNvY2tldFRpbWVvdXQgaW5zdGVhZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dDtcblx0ICB9XG5cblx0ICBnZXQgdGltZW91dCgpIHtcblx0ICAgIGRlcHJlY2F0ZSgnYWdlbnQudGltZW91dCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGFnZW50Lm9wdGlvbnMudGltZW91dCBpbnN0ZWFkJyk7XG5cdCAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG5cdCAgfVxuXG5cdCAgZ2V0IHNvY2tldEFjdGl2ZVRUTCgpIHtcblx0ICAgIGRlcHJlY2F0ZSgnYWdlbnQuc29ja2V0QWN0aXZlVFRMIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgYWdlbnQub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwgaW5zdGVhZCcpO1xuXHQgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG5cdCAgfVxuXG5cdCAgY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KSB7XG5cdCAgICAvKipcblx0ICAgICAqIHJldHVybiA8PSAwOiBzaG91bGQgZnJlZSBzb2NrZXRcblx0ICAgICAqIHJldHVybiA+IDA6IHNob3VsZCB1cGRhdGUgc29ja2V0IHRpbWVvdXRcblx0ICAgICAqIHJldHVybiB1bmRlZmluZWQ6IG5vdCBmaW5kIGN1c3RvbSB0aW1lb3V0XG5cdCAgICAgKi9cblx0ICAgIGxldCBmcmVlU29ja2V0VGltZW91dCA9IHRoaXMub3B0aW9ucy5mcmVlU29ja2V0VGltZW91dDtcblx0ICAgIGNvbnN0IHNvY2tldEFjdGl2ZVRUTCA9IHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEw7XG5cdCAgICBpZiAoc29ja2V0QWN0aXZlVFRMKSB7XG5cdCAgICAgIC8vIGNoZWNrIHNvY2tldEFjdGl2ZVRUTFxuXHQgICAgICBjb25zdCBhbGl2ZVRpbWUgPSBEYXRlLm5vdygpIC0gc29ja2V0W1NPQ0tFVF9DUkVBVEVEX1RJTUVdO1xuXHQgICAgICBjb25zdCBkaWZmID0gc29ja2V0QWN0aXZlVFRMIC0gYWxpdmVUaW1lO1xuXHQgICAgICBpZiAoZGlmZiA8PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIGRpZmY7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGZyZWVTb2NrZXRUaW1lb3V0ICYmIGRpZmYgPCBmcmVlU29ja2V0VGltZW91dCkge1xuXHQgICAgICAgIGZyZWVTb2NrZXRUaW1lb3V0ID0gZGlmZjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gc2V0IGZyZWVTb2NrZXRUaW1lb3V0XG5cdCAgICBpZiAoZnJlZVNvY2tldFRpbWVvdXQpIHtcblx0ICAgICAgLy8gc2V0IGZyZWUga2VlcGFsaXZlIHRpbWVyXG5cdCAgICAgIC8vIHRyeSB0byB1c2Ugc29ja2V0IGN1c3RvbSBmcmVlU29ja2V0VGltZW91dCBmaXJzdCwgc3VwcG9ydCBoZWFkZXJzWydrZWVwLWFsaXZlJ11cblx0ICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtbW9kdWxlcy91cmxsaWIvYmxvYi9iNzYwNTMwMjA5MjNmNGQ5OWExYzkzY2YyZTE2ZTBjNWJhMTBiYWNmL2xpYi91cmxsaWIuanMjTDQ5OFxuXHQgICAgICBjb25zdCBjdXN0b21GcmVlU29ja2V0VGltZW91dCA9IHNvY2tldC5mcmVlU29ja2V0VGltZW91dCB8fCBzb2NrZXQuZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQ7XG5cdCAgICAgIHJldHVybiBjdXN0b21GcmVlU29ja2V0VGltZW91dCB8fCBmcmVlU29ja2V0VGltZW91dDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBrZWVwU29ja2V0QWxpdmUoc29ja2V0KSB7XG5cdCAgICBjb25zdCByZXN1bHQgPSBzdXBlci5rZWVwU29ja2V0QWxpdmUoc29ja2V0KTtcblx0ICAgIC8vIHNob3VsZCBub3Qga2VlcEFsaXZlLCBkbyBub3RoaW5nXG5cdCAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblxuXHQgICAgY29uc3QgY3VzdG9tVGltZW91dCA9IHRoaXMuY2FsY1NvY2tldFRpbWVvdXQoc29ja2V0KTtcblx0ICAgIGlmICh0eXBlb2YgY3VzdG9tVGltZW91dCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoY3VzdG9tVGltZW91dCA8PSAwKSB7XG5cdCAgICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZnJlZSBidXQgbmVlZCB0byBkZXN0cm95IGJ5IFRUTCwgcmVxdWVzdCBjb3VudCAlcywgZGlmZiBpcyAlcycsXG5cdCAgICAgICAgc29ja2V0W1NPQ0tFVF9OQU1FXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSwgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0ZJTklTSEVEX0NPVU5UXSwgY3VzdG9tVGltZW91dCk7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmIChzb2NrZXQudGltZW91dCAhPT0gY3VzdG9tVGltZW91dCkge1xuXHQgICAgICBzb2NrZXQuc2V0VGltZW91dChjdXN0b21UaW1lb3V0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIC8vIG9ubHkgY2FsbCBvbiBhZGRSZXF1ZXN0XG5cdCAgcmV1c2VTb2NrZXQoLi4uYXJncykge1xuXHQgICAgLy8gcmV1c2VTb2NrZXQoc29ja2V0LCByZXEpXG5cdCAgICBzdXBlci5yZXVzZVNvY2tldCguLi5hcmdzKTtcblx0ICAgIGNvbnN0IHNvY2tldCA9IGFyZ3NbMF07XG5cdCAgICBjb25zdCByZXEgPSBhcmdzWzFdO1xuXHQgICAgcmVxLnJldXNlZFNvY2tldCA9IHRydWU7XG5cdCAgICBjb25zdCBhZ2VudFRpbWVvdXQgPSB0aGlzLm9wdGlvbnMudGltZW91dDtcblx0ICAgIGlmIChnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkgIT09IGFnZW50VGltZW91dCkge1xuXHQgICAgICAvLyByZXNldCB0aW1lb3V0IGJlZm9yZSB1c2Vcblx0ICAgICAgc29ja2V0LnNldFRpbWVvdXQoYWdlbnRUaW1lb3V0KTtcblx0ICAgICAgZGVidWcoJyVzIHJlc2V0IHRpbWVvdXQgdG8gJXNtcycsIHNvY2tldFtTT0NLRVRfTkFNRV0sIGFnZW50VGltZW91dCk7XG5cdCAgICB9XG5cdCAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdKys7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIHJldXNlIG9uIGFkZFJlcXVlc3QsIHRpbWVvdXQgJXNtcycsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sXG5cdCAgICAgIGdldFNvY2tldFRpbWVvdXQoc29ja2V0KSk7XG5cdCAgfVxuXG5cdCAgW0NSRUFURV9JRF0oKSB7XG5cdCAgICBjb25zdCBpZCA9IHRoaXNbQ1VSUkVOVF9JRF0rKztcblx0ICAgIGlmICh0aGlzW0NVUlJFTlRfSURdID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgdGhpc1tDVVJSRU5UX0lEXSA9IDA7XG5cdCAgICByZXR1cm4gaWQ7XG5cdCAgfVxuXG5cdCAgW0lOSVRfU09DS0VUXShzb2NrZXQsIG9wdGlvbnMpIHtcblx0ICAgIC8vIGJ1Z2ZpeCBoZXJlLlxuXHQgICAgLy8gaHR0cHMgb24gbm9kZSA4LCAxMCB3b24ndCBzZXQgYWdlbnQub3B0aW9ucy50aW1lb3V0IGJ5IGRlZmF1bHRcblx0ICAgIC8vIFRPRE86IG5lZWQgdG8gZml4IG9uIG5vZGUgaXRzZWxmXG5cdCAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG5cdCAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICAgIGlmICghdGltZW91dCkge1xuXHQgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KG9wdGlvbnMudGltZW91dCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQWxpdmUpIHtcblx0ICAgICAgLy8gRGlzYWJsZSBOYWdsZSdzIGFsZ29yaXRobTogaHR0cDovL2Jsb2cuY2F1c3Rpay5jb20vMjAxMi8wNC8wOC9zY2FsaW5nLW5vZGUtanMtdG8tMTAway1jb25jdXJyZW50LWNvbm5lY3Rpb25zL1xuXHQgICAgICAvLyBodHRwczovL2ZlbmdtazIuY29tL2JlbmNobWFyay9uYWdsZS1hbGdvcml0aG0tZGVsYXllZC1hY2stbW9jay5odG1sXG5cdCAgICAgIHNvY2tldC5zZXROb0RlbGF5KHRydWUpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudCsrO1xuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXRBY3RpdmVUVEwpIHtcblx0ICAgICAgc29ja2V0W1NPQ0tFVF9DUkVBVEVEX1RJTUVdID0gRGF0ZS5ub3coKTtcblx0ICAgIH1cblx0ICAgIC8vIGRvbid0IHNob3cgdGhlIGhvbGUgJy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tJyBrZXkgc3RyaW5nXG5cdCAgICBzb2NrZXRbU09DS0VUX05BTUVdID0gYHNvY2tbJHt0aGlzW0NSRUFURV9JRF0oKX0jJHtvcHRpb25zLl9hZ2VudEtleX1dYC5zcGxpdCgnLS0tLS1CRUdJTicsIDEpWzBdO1xuXHQgICAgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSA9IDE7XG5cdCAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdID0gMDtcblx0ICAgIGluc3RhbGxMaXN0ZW5lcnModGhpcywgc29ja2V0LCBvcHRpb25zKTtcblx0ICB9XG5cblx0ICBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIG9uY3JlYXRlKSB7XG5cdCAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cdCAgICBjb25zdCBvbk5ld0NyZWF0ZSA9IChlcnIsIHNvY2tldCkgPT4ge1xuXHQgICAgICBpZiAoY2FsbGVkKSByZXR1cm47XG5cdCAgICAgIGNhbGxlZCA9IHRydWU7XG5cblx0ICAgICAgaWYgKGVycikge1xuXHQgICAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCsrO1xuXHQgICAgICAgIHJldHVybiBvbmNyZWF0ZShlcnIpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXNbSU5JVF9TT0NLRVRdKHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgICAgIG9uY3JlYXRlKGVyciwgc29ja2V0KTtcblx0ICAgIH07XG5cblx0ICAgIGNvbnN0IG5ld1NvY2tldCA9IHN1cGVyLmNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgb25OZXdDcmVhdGUpO1xuXHQgICAgaWYgKG5ld1NvY2tldCkgb25OZXdDcmVhdGUobnVsbCwgbmV3U29ja2V0KTtcblx0ICAgIHJldHVybiBuZXdTb2NrZXQ7XG5cdCAgfVxuXG5cdCAgZ2V0IHN0YXR1c0NoYW5nZWQoKSB7XG5cdCAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudCAhPT0gdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLmNyZWF0ZVNvY2tldEVycm9yQ291bnQgIT09IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLmNsb3NlU29ja2V0Q291bnQgIT09IHRoaXMuY2xvc2VTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLmVycm9yU29ja2V0Q291bnQgIT09IHRoaXMuZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayB8fFxuXHQgICAgICB0aGlzLnRpbWVvdXRTb2NrZXRDb3VudCAhPT0gdGhpcy50aW1lb3V0U29ja2V0Q291bnRMYXN0Q2hlY2sgfHxcblx0ICAgICAgdGhpcy5yZXF1ZXN0Q291bnQgIT09IHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrO1xuXHQgICAgaWYgKGNoYW5nZWQpIHtcblx0ICAgICAgdGhpcy5jcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0Q291bnQ7XG5cdCAgICAgIHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudExhc3RDaGVjayA9IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudDtcblx0ICAgICAgdGhpcy5jbG9zZVNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy5jbG9zZVNvY2tldENvdW50O1xuXHQgICAgICB0aGlzLmVycm9yU29ja2V0Q291bnRMYXN0Q2hlY2sgPSB0aGlzLmVycm9yU29ja2V0Q291bnQ7XG5cdCAgICAgIHRoaXMudGltZW91dFNvY2tldENvdW50TGFzdENoZWNrID0gdGhpcy50aW1lb3V0U29ja2V0Q291bnQ7XG5cdCAgICAgIHRoaXMucmVxdWVzdENvdW50TGFzdENoZWNrID0gdGhpcy5yZXF1ZXN0Q291bnQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY2hhbmdlZDtcblx0ICB9XG5cblx0ICBnZXRDdXJyZW50U3RhdHVzKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgY3JlYXRlU29ja2V0Q291bnQ6IHRoaXMuY3JlYXRlU29ja2V0Q291bnQsXG5cdCAgICAgIGNyZWF0ZVNvY2tldEVycm9yQ291bnQ6IHRoaXMuY3JlYXRlU29ja2V0RXJyb3JDb3VudCxcblx0ICAgICAgY2xvc2VTb2NrZXRDb3VudDogdGhpcy5jbG9zZVNvY2tldENvdW50LFxuXHQgICAgICBlcnJvclNvY2tldENvdW50OiB0aGlzLmVycm9yU29ja2V0Q291bnQsXG5cdCAgICAgIHRpbWVvdXRTb2NrZXRDb3VudDogdGhpcy50aW1lb3V0U29ja2V0Q291bnQsXG5cdCAgICAgIHJlcXVlc3RDb3VudDogdGhpcy5yZXF1ZXN0Q291bnQsXG5cdCAgICAgIGZyZWVTb2NrZXRzOiBpbnNwZWN0KHRoaXMuZnJlZVNvY2tldHMpLFxuXHQgICAgICBzb2NrZXRzOiBpbnNwZWN0KHRoaXMuc29ja2V0cyksXG5cdCAgICAgIHJlcXVlc3RzOiBpbnNwZWN0KHRoaXMucmVxdWVzdHMpLFxuXHQgICAgfTtcblx0ICB9XG5cdH1cblxuXHQvLyBub2RlIDggZG9uJ3QgaGFzIHRpbWVvdXQgYXR0cmlidXRlIG9uIHNvY2tldFxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8yMTIwNC9maWxlcyNkaWZmLWU2ZWYwMjRjMzc3NWQ3ODdjMzg0ODdhNjMwOWU0OTFkUjQwOFxuXHRmdW5jdGlvbiBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCkge1xuXHQgIHJldHVybiBzb2NrZXQudGltZW91dCB8fCBzb2NrZXQuX2lkbGVUaW1lb3V0O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zdGFsbExpc3RlbmVycyhhZ2VudCwgc29ja2V0LCBvcHRpb25zKSB7XG5cdCAgZGVidWcoJyVzIGNyZWF0ZSwgdGltZW91dCAlc21zJywgc29ja2V0W1NPQ0tFVF9OQU1FXSwgZ2V0U29ja2V0VGltZW91dChzb2NrZXQpKTtcblxuXHQgIC8vIGxpc3RlbmVyIHNvY2tldCBldmVudHM6IGNsb3NlLCB0aW1lb3V0LCBlcnJvciwgZnJlZVxuXHQgIGZ1bmN0aW9uIG9uRnJlZSgpIHtcblx0ICAgIC8vIGNyZWF0ZSBhbmQgc29ja2V0LmVtaXQoJ2ZyZWUnKSBsb2dpY1xuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9faHR0cF9hZ2VudC5qcyNMMzExXG5cdCAgICAvLyBubyByZXEgb24gdGhlIHNvY2tldCwgaXQgc2hvdWxkIGJlIHRoZSBuZXcgc29ja2V0XG5cdCAgICBpZiAoIXNvY2tldC5faHR0cE1lc3NhZ2UgJiYgc29ja2V0W1NPQ0tFVF9SRVFVRVNUX0NPVU5UXSA9PT0gMSkgcmV0dXJuO1xuXG5cdCAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKys7XG5cdCAgICBhZ2VudC5yZXF1ZXN0Q291bnQrKztcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgZnJlZScsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuXG5cdCAgICAvLyBzaG91bGQgcmV1c2Ugb24gcGVkZGluZyByZXF1ZXN0cz9cblx0ICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5nZXROYW1lKG9wdGlvbnMpO1xuXHQgICAgaWYgKHNvY2tldC53cml0YWJsZSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXSAmJiBhZ2VudC5yZXF1ZXN0c1tuYW1lXS5sZW5ndGgpIHtcblx0ICAgICAgLy8gd2lsbCBiZSByZXVzZSBvbiBhZ2VudCBmcmVlIGxpc3RlbmVyXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0rKztcblx0ICAgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB3aWxsIGJlIHJldXNlIG9uIGFnZW50IGZyZWUgZXZlbnQnLFxuXHQgICAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0pO1xuXHQgICAgfVxuXHQgIH1cblx0ICBzb2NrZXQub24oJ2ZyZWUnLCBvbkZyZWUpO1xuXG5cdCAgZnVuY3Rpb24gb25DbG9zZShpc0Vycm9yKSB7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGNsb3NlLCBpc0Vycm9yOiAlcycsXG5cdCAgICAgIHNvY2tldFtTT0NLRVRfTkFNRV0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9DT1VOVF0sIHNvY2tldFtTT0NLRVRfUkVRVUVTVF9GSU5JU0hFRF9DT1VOVF0sIGlzRXJyb3IpO1xuXHQgICAgYWdlbnQuY2xvc2VTb2NrZXRDb3VudCsrO1xuXHQgIH1cblx0ICBzb2NrZXQub24oJ2Nsb3NlJywgb25DbG9zZSk7XG5cblx0ICAvLyBzdGFydCBzb2NrZXQgdGltZW91dCBoYW5kbGVyXG5cdCAgZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuXHQgICAgLy8gb25UaW1lb3V0IGFuZCBlbWl0UmVxdWVzdFRpbWVvdXQoX2h0dHBfY2xpZW50LmpzKVxuXHQgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEyLngvbGliL19odHRwX2NsaWVudC5qcyNMNzExXG5cdCAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLmxlbmd0aDtcblx0ICAgIC8vIG5vZGUgPD0gMTAsIGRlZmF1bHQgbGlzdGVuZXJDb3VudCBpcyAxLCBvblRpbWVvdXRcblx0ICAgIC8vIDExIDwgbm9kZSA8PSAxMiwgZGVmYXVsdCBsaXN0ZW5lckNvdW50IGlzIDIsIG9uVGltZW91dCBhbmQgZW1pdFJlcXVlc3RUaW1lb3V0XG5cdCAgICAvLyBub2RlID49IDEzLCBkZWZhdWx0IGxpc3RlbmVyQ291bnQgaXMgMywgb25UaW1lb3V0LFxuXHQgICAgLy8gICBvblRpbWVvdXQoaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzIwMDAvZmlsZXMjZGlmZi01ZjdmYjA4NTA0MTJjNmJlMTg5ZmFlZGRlYTZjNTM1OVIzMzMpXG5cdCAgICAvLyAgIGFuZCBlbWl0UmVxdWVzdFRpbWVvdXRcblx0ICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRTb2NrZXRUaW1lb3V0KHNvY2tldCk7XG5cdCAgICBjb25zdCByZXEgPSBzb2NrZXQuX2h0dHBNZXNzYWdlO1xuXHQgICAgY29uc3QgcmVxVGltZW91dExpc3RlbmVyQ291bnQgPSByZXEgJiYgcmVxLmxpc3RlbmVycygndGltZW91dCcpLmxlbmd0aCB8fCAwO1xuXHQgICAgZGVidWcoJyVzKHJlcXVlc3RzOiAlcywgZmluaXNoZWQ6ICVzKSB0aW1lb3V0IGFmdGVyICVzbXMsIGxpc3RlbmVycyAlcywgZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50ICVzLCBoYXNIdHRwUmVxdWVzdCAlcywgSHR0cFJlcXVlc3QgdGltZW91dExpc3RlbmVyQ291bnQgJXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuXHQgICAgICB0aW1lb3V0LCBsaXN0ZW5lckNvdW50LCBkZWZhdWx0VGltZW91dExpc3RlbmVyQ291bnQsICEhcmVxLCByZXFUaW1lb3V0TGlzdGVuZXJDb3VudCk7XG5cdCAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuXHQgICAgICBkZWJ1ZygndGltZW91dCBsaXN0ZW5lcnM6ICVzJywgc29ja2V0Lmxpc3RlbmVycygndGltZW91dCcpLm1hcChmID0+IGYubmFtZSkuam9pbignLCAnKSk7XG5cdCAgICB9XG5cdCAgICBhZ2VudC50aW1lb3V0U29ja2V0Q291bnQrKztcblx0ICAgIGNvbnN0IG5hbWUgPSBhZ2VudC5nZXROYW1lKG9wdGlvbnMpO1xuXHQgICAgaWYgKGFnZW50LmZyZWVTb2NrZXRzW25hbWVdICYmIGFnZW50LmZyZWVTb2NrZXRzW25hbWVdLmluZGV4T2Yoc29ja2V0KSAhPT0gLTEpIHtcblx0ICAgICAgLy8gZnJlZSBzb2NrZXQgdGltZW91dCwgZGVzdHJveSBxdWlldGx5XG5cdCAgICAgIHNvY2tldC5kZXN0cm95KCk7XG5cdCAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIGZyZWVTb2NrZXRzIGxpc3QgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBuZXcgcmVxdWVzdHNcblx0ICAgICAgLy8gZnJvbSBiZWluZyBzZW50IHRocm91Z2ggdGhpcyBzb2NrZXQuXG5cdCAgICAgIGFnZW50LnJlbW92ZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpO1xuXHQgICAgICBkZWJ1ZygnJXMgaXMgZnJlZSwgZGVzdHJveSBxdWlldGx5Jywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBpZiB0aGVyZSBpcyBubyBhbnkgcmVxdWVzdCBzb2NrZXQgdGltZW91dCBoYW5kbGVyLFxuXHQgICAgICAvLyBhZ2VudCBuZWVkIHRvIGhhbmRsZSBzb2NrZXQgdGltZW91dCBpdHNlbGYuXG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIGN1c3RvbSByZXF1ZXN0IHNvY2tldCB0aW1lb3V0IGhhbmRsZSBsb2dpYyBtdXN0IGZvbGxvdyB0aGVzZSBydWxlczpcblx0ICAgICAgLy8gIDEuIERlc3Ryb3kgc29ja2V0IGZpcnN0XG5cdCAgICAgIC8vICAyLiBNdXN0IGVtaXQgc29ja2V0ICdhZ2VudFJlbW92ZScgZXZlbnQgdGVsbCBhZ2VudCByZW1vdmUgc29ja2V0XG5cdCAgICAgIC8vICAgICBmcm9tIGZyZWVTb2NrZXRzIGxpc3QgaW1tZWRpYXRlbHkuXG5cdCAgICAgIC8vICAgICBPdGhlcmlzZSB5b3UgbWF5IGJlIGdldCAnc29ja2V0IGhhbmcgdXAnIGVycm9yIHdoZW4gcmV1c2Vcblx0ICAgICAgLy8gICAgIGZyZWUgc29ja2V0IGFuZCB0aW1lb3V0IGhhcHBlbiBpbiB0aGUgc2FtZSB0aW1lLlxuXHQgICAgICBpZiAocmVxVGltZW91dExpc3RlbmVyQ291bnQgPT09IDApIHtcblx0ICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignU29ja2V0IHRpbWVvdXQnKTtcblx0ICAgICAgICBlcnJvci5jb2RlID0gJ0VSUl9TT0NLRVRfVElNRU9VVCc7XG5cdCAgICAgICAgZXJyb3IudGltZW91dCA9IHRpbWVvdXQ7XG5cdCAgICAgICAgLy8gbXVzdCBtYW51YWxseSBjYWxsIHNvY2tldC5lbmQoKSBvciBzb2NrZXQuZGVzdHJveSgpIHRvIGVuZCB0aGUgY29ubmVjdGlvbi5cblx0ICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjEwLngvZG9jcy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2tcblx0ICAgICAgICBzb2NrZXQuZGVzdHJveShlcnJvcik7XG5cdCAgICAgICAgYWdlbnQucmVtb3ZlU29ja2V0KHNvY2tldCwgb3B0aW9ucyk7XG5cdCAgICAgICAgZGVidWcoJyVzIGRlc3Ryb3kgd2l0aCB0aW1lb3V0IGVycm9yJywgc29ja2V0W1NPQ0tFVF9OQU1FXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgc29ja2V0Lm9uKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcblxuXHQgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG5cdCAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gc29ja2V0Lmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGg7XG5cdCAgICBkZWJ1ZygnJXMocmVxdWVzdHM6ICVzLCBmaW5pc2hlZDogJXMpIGVycm9yOiAlcywgbGlzdGVuZXJDb3VudDogJXMnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdLFxuXHQgICAgICBlcnIsIGxpc3RlbmVyQ291bnQpO1xuXHQgICAgYWdlbnQuZXJyb3JTb2NrZXRDb3VudCsrO1xuXHQgICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEpIHtcblx0ICAgICAgLy8gaWYgc29ja2V0IGRvbid0IGNvbnRhaW4gZXJyb3IgZXZlbnQgaGFuZGxlciwgZG9uJ3QgY2F0Y2ggaXQsIGVtaXQgaXQgYWdhaW5cblx0ICAgICAgZGVidWcoJyVzIGVtaXQgdW5jYXVnaHQgZXJyb3IgZXZlbnQnLCBzb2NrZXRbU09DS0VUX05BTUVdKTtcblx0ICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuXHQgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgICAgfVxuXHQgIH1cblx0ICBzb2NrZXQub24oJ2Vycm9yJywgb25FcnJvcik7XG5cblx0ICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcblx0ICAgIGRlYnVnKCclcyhyZXF1ZXN0czogJXMsIGZpbmlzaGVkOiAlcykgYWdlbnRSZW1vdmUnLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX05BTUVdLFxuXHQgICAgICBzb2NrZXRbU09DS0VUX1JFUVVFU1RfQ09VTlRdLCBzb2NrZXRbU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlRdKTtcblx0ICAgIC8vIFdlIG5lZWQgdGhpcyBmdW5jdGlvbiBmb3IgY2FzZXMgbGlrZSBIVFRQICd1cGdyYWRlJ1xuXHQgICAgLy8gKGRlZmluZWQgYnkgV2ViU29ja2V0cykgd2hlcmUgd2UgbmVlZCB0byByZW1vdmUgYSBzb2NrZXQgZnJvbSB0aGVcblx0ICAgIC8vIHBvb2wgYmVjYXVzZSBpdCdsbCBiZSBsb2NrZWQgdXAgaW5kZWZpbml0ZWx5XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSk7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG5cdCAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2ZyZWUnLCBvbkZyZWUpO1xuXHQgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcblx0ICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG5cdCAgfVxuXHQgIHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvblJlbW92ZSk7XG5cdH1cblxuXHRhZ2VudCA9IEFnZW50O1xuXG5cdGZ1bmN0aW9uIGluc3BlY3Qob2JqKSB7XG5cdCAgY29uc3QgcmVzID0ge307XG5cdCAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG5cdCAgICByZXNba2V5XSA9IG9ialtrZXldLmxlbmd0aDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fVxuXHRyZXR1cm4gYWdlbnQ7XG59XG5cbnZhciBodHRwc19hZ2VudDtcbnZhciBoYXNSZXF1aXJlZEh0dHBzX2FnZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlSHR0cHNfYWdlbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRIdHRwc19hZ2VudCkgcmV0dXJuIGh0dHBzX2FnZW50O1xuXHRoYXNSZXF1aXJlZEh0dHBzX2FnZW50ID0gMTtcblxuXHRjb25zdCBPcmlnaW5hbEh0dHBzQWdlbnQgPSByZXF1aXJlJCQwX19kZWZhdWx0JDIuZGVmYXVsdC5BZ2VudDtcblx0Y29uc3QgSHR0cEFnZW50ID0gLypAX19QVVJFX18qLyByZXF1aXJlQWdlbnQoKTtcblx0Y29uc3Qge1xuXHQgIElOSVRfU09DS0VULFxuXHQgIENSRUFURV9IVFRQU19DT05ORUNUSU9OLFxuXHR9ID0gLypAX19QVVJFX18qLyByZXF1aXJlQ29uc3RhbnRzKCk7XG5cblx0Y2xhc3MgSHR0cHNBZ2VudCBleHRlbmRzIEh0dHBBZ2VudCB7XG5cdCAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXHQgICAgc3VwZXIob3B0aW9ucyk7XG5cblx0ICAgIHRoaXMuZGVmYXVsdFBvcnQgPSA0NDM7XG5cdCAgICB0aGlzLnByb3RvY29sID0gJ2h0dHBzOic7XG5cdCAgICB0aGlzLm1heENhY2hlZFNlc3Npb25zID0gdGhpcy5vcHRpb25zLm1heENhY2hlZFNlc3Npb25zO1xuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgIGlmICh0aGlzLm1heENhY2hlZFNlc3Npb25zID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgdGhpcy5tYXhDYWNoZWRTZXNzaW9ucyA9IDEwMDtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2Vzc2lvbkNhY2hlID0ge1xuXHQgICAgICBtYXA6IHt9LFxuXHQgICAgICBsaXN0OiBbXSxcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zLCBvbmNyZWF0ZSkge1xuXHQgICAgY29uc3Qgc29ja2V0ID0gdGhpc1tDUkVBVEVfSFRUUFNfQ09OTkVDVElPTl0ob3B0aW9ucywgb25jcmVhdGUpO1xuXHQgICAgdGhpc1tJTklUX1NPQ0tFVF0oc29ja2V0LCBvcHRpb25zKTtcblx0ICAgIHJldHVybiBzb2NrZXQ7XG5cdCAgfVxuXHR9XG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFzdGVyL2xpYi9odHRwcy5qcyNMODlcblx0SHR0cHNBZ2VudC5wcm90b3R5cGVbQ1JFQVRFX0hUVFBTX0NPTk5FQ1RJT05dID0gT3JpZ2luYWxIdHRwc0FnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uO1xuXG5cdFtcblx0ICAnZ2V0TmFtZScsXG5cdCAgJ19nZXRTZXNzaW9uJyxcblx0ICAnX2NhY2hlU2Vzc2lvbicsXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDk4MlxuXHQgICdfZXZpY3RTZXNzaW9uJyxcblx0XS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgaWYgKHR5cGVvZiBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlW21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgIEh0dHBzQWdlbnQucHJvdG90eXBlW21ldGhvZF0gPSBPcmlnaW5hbEh0dHBzQWdlbnQucHJvdG90eXBlW21ldGhvZF07XG5cdCAgfVxuXHR9KTtcblxuXHRodHRwc19hZ2VudCA9IEh0dHBzQWdlbnQ7XG5cdHJldHVybiBodHRwc19hZ2VudDtcbn1cblxudmFyIGhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVBZ2VudGtlZXBhbGl2ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZEFnZW50a2VlcGFsaXZlKSByZXR1cm4gYWdlbnRrZWVwYWxpdmUuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRBZ2VudGtlZXBhbGl2ZSA9IDE7XG5cblx0YWdlbnRrZWVwYWxpdmUuZXhwb3J0cyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUFnZW50KCk7XG5cdGFnZW50a2VlcGFsaXZlLmV4cG9ydHMuSHR0cHNBZ2VudCA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUh0dHBzX2FnZW50KCk7XG5cdGFnZW50a2VlcGFsaXZlLmV4cG9ydHMuY29uc3RhbnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlQ29uc3RhbnRzKCk7XG5cdHJldHVybiBhZ2VudGtlZXBhbGl2ZS5leHBvcnRzO1xufVxuXG52YXIgYWdlbnRrZWVwYWxpdmVFeHBvcnRzID0gLypAX19QVVJFX18qLyByZXF1aXJlQWdlbnRrZWVwYWxpdmUoKTtcbnZhciBIdHRwS2VlcEFsaXZlQWdlbnQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYWdlbnRrZWVwYWxpdmVFeHBvcnRzKTtcblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkkMTtcbnZhciBoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVGYXN0U3RhYmxlU3RyaW5naWZ5ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRmFzdFN0YWJsZVN0cmluZ2lmeSkgcmV0dXJuIGZhc3RTdGFibGVTdHJpbmdpZnkkMTtcblx0aGFzUmVxdWlyZWRGYXN0U3RhYmxlU3RyaW5naWZ5ID0gMTtcblx0dmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHtcblx0XHRcdHZhciBrZXlzID0gW107XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0XHRrZXlzLnB1c2gobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ga2V5cztcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWwsIGlzQXJyYXlQcm9wKSB7XG5cdFx0dmFyIGksIG1heCwgc3RyLCBrZXlzLCBrZXksIHByb3BWYWwsIHRvU3RyO1xuXHRcdGlmICh2YWwgPT09IHRydWUpIHtcblx0XHRcdHJldHVybiBcInRydWVcIjtcblx0XHR9XG5cdFx0aWYgKHZhbCA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybiBcImZhbHNlXCI7XG5cdFx0fVxuXHRcdHN3aXRjaCAodHlwZW9mIHZhbCkge1xuXHRcdFx0Y2FzZSBcIm9iamVjdFwiOlxuXHRcdFx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsLnRvSlNPTiAmJiB0eXBlb2YgdmFsLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSh2YWwudG9KU09OKCksIGlzQXJyYXlQcm9wKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0b1N0ciA9IG9ialRvU3RyaW5nLmNhbGwodmFsKTtcblx0XHRcdFx0XHRpZiAodG9TdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0XHRcdFx0c3RyID0gJ1snO1xuXHRcdFx0XHRcdFx0bWF4ID0gdmFsLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSkgKyAnLCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobWF4ID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0ciArICddJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRvU3RyID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG5cdFx0XHRcdFx0XHQvLyBvbmx5IG9iamVjdCBpcyBsZWZ0XG5cdFx0XHRcdFx0XHRrZXlzID0gb2JqS2V5cyh2YWwpLnNvcnQoKTtcblx0XHRcdFx0XHRcdG1heCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0c3RyID0gXCJcIjtcblx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGkgPCBtYXgpIHtcblx0XHRcdFx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRcdFx0cHJvcFZhbCA9IHN0cmluZ2lmeSh2YWxba2V5XSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0XHRpZiAocHJvcFZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0cikge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RyICs9ICcsJztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IEpTT04uc3RyaW5naWZ5KGtleSkgKyAnOicgKyBwcm9wVmFsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiAneycgKyBzdHIgKyAnfSc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Y2FzZSBcImZ1bmN0aW9uXCI6XG5cdFx0XHRjYXNlIFwidW5kZWZpbmVkXCI6XG5cdFx0XHRcdHJldHVybiBpc0FycmF5UHJvcCA/IG51bGwgOiB1bmRlZmluZWQ7XG5cdFx0XHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGlzRmluaXRlKHZhbCkgPyB2YWwgOiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGZhc3RTdGFibGVTdHJpbmdpZnkkMSA9IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHZhciByZXR1cm5WYWwgPSBzdHJpbmdpZnkodmFsLCBmYWxzZSk7XG5cdFx0aWYgKHJldHVyblZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJycrIHJldHVyblZhbDtcblx0XHR9XG5cdH07XG5cdHJldHVybiBmYXN0U3RhYmxlU3RyaW5naWZ5JDE7XG59XG5cbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5RXhwb3J0cyA9IC8qQF9fUFVSRV9fKi8gcmVxdWlyZUZhc3RTdGFibGVTdHJpbmdpZnkoKTtcbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZhc3RTdGFibGVTdHJpbmdpZnlFeHBvcnRzKTtcblxuY29uc3QgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCA9IDMyO1xuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBzZWxmLlxuZnVuY3Rpb24gdHJhaWxpbmdaZXJvcyhuKSB7XG4gIGxldCB0cmFpbGluZ1plcm9zID0gMDtcbiAgd2hpbGUgKG4gPiAxKSB7XG4gICAgbiAvPSAyO1xuICAgIHRyYWlsaW5nWmVyb3MrKztcbiAgfVxuICByZXR1cm4gdHJhaWxpbmdaZXJvcztcbn1cblxuLy8gUmV0dXJucyB0aGUgc21hbGxlc3QgcG93ZXIgb2YgdHdvIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBuXG5mdW5jdGlvbiBuZXh0UG93ZXJPZlR3byhuKSB7XG4gIGlmIChuID09PSAwKSByZXR1cm4gMTtcbiAgbi0tO1xuICBuIHw9IG4gPj4gMTtcbiAgbiB8PSBuID4+IDI7XG4gIG4gfD0gbiA+PiA0O1xuICBuIHw9IG4gPj4gODtcbiAgbiB8PSBuID4+IDE2O1xuICBuIHw9IG4gPj4gMzI7XG4gIHJldHVybiBuICsgMTtcbn1cblxuLyoqXG4gKiBFcG9jaCBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNlcG9jaClcbiAqIENhbiBiZSByZXRyaWV2ZWQgd2l0aCB0aGUge0BsaW5rIENvbm5lY3Rpb24uZ2V0RXBvY2hTY2hlZHVsZX0gbWV0aG9kXG4gKi9cbmNsYXNzIEVwb2NoU2NoZWR1bGUge1xuICBjb25zdHJ1Y3RvcihzbG90c1BlckVwb2NoLCBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQsIHdhcm11cCwgZmlyc3ROb3JtYWxFcG9jaCwgZmlyc3ROb3JtYWxTbG90KSB7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzbG90cyBpbiBlYWNoIGVwb2NoICovXG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNsb3RzIGJlZm9yZSBiZWdpbm5pbmcgb2YgYW4gZXBvY2ggdG8gY2FsY3VsYXRlIGEgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGF0IGVwb2NoICovXG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSB2b2lkIDA7XG4gICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIGVwb2NocyBzdGFydCBzaG9ydCBhbmQgZ3JvdyAqL1xuICAgIHRoaXMud2FybXVwID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3QgZXBvY2ggd2l0aCBgc2xvdHNQZXJFcG9jaGAgc2xvdHMgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBzbG90IG9mIGBmaXJzdE5vcm1hbEVwb2NoYCAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHNsb3RzUGVyRXBvY2g7XG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ7XG4gICAgdGhpcy53YXJtdXAgPSB3YXJtdXA7XG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gZmlyc3ROb3JtYWxFcG9jaDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IGZpcnN0Tm9ybWFsU2xvdDtcbiAgfVxuICBnZXRFcG9jaChzbG90KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdClbMF07XG4gIH1cbiAgZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdCkge1xuICAgIGlmIChzbG90IDwgdGhpcy5maXJzdE5vcm1hbFNsb3QpIHtcbiAgICAgIGNvbnN0IGVwb2NoID0gdHJhaWxpbmdaZXJvcyhuZXh0UG93ZXJPZlR3byhzbG90ICsgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCArIDEpKSAtIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkgLSAxO1xuICAgICAgY29uc3QgZXBvY2hMZW4gPSB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCk7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBzbG90IC0gKGVwb2NoTGVuIC0gTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCk7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub3JtYWxTbG90SW5kZXggPSBzbG90IC0gdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgICBjb25zdCBub3JtYWxFcG9jaEluZGV4ID0gTWF0aC5mbG9vcihub3JtYWxTbG90SW5kZXggLyB0aGlzLnNsb3RzUGVyRXBvY2gpO1xuICAgICAgY29uc3QgZXBvY2ggPSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggKyBub3JtYWxFcG9jaEluZGV4O1xuICAgICAgY29uc3Qgc2xvdEluZGV4ID0gbm9ybWFsU2xvdEluZGV4ICUgdGhpcy5zbG90c1BlckVwb2NoO1xuICAgICAgcmV0dXJuIFtlcG9jaCwgc2xvdEluZGV4XTtcbiAgICB9XG4gIH1cbiAgZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIGlmIChlcG9jaCA8PSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiAoTWF0aC5wb3coMiwgZXBvY2gpIC0gMSkgKiBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGVwb2NoIC0gdGhpcy5maXJzdE5vcm1hbEVwb2NoKSAqIHRoaXMuc2xvdHNQZXJFcG9jaCArIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgIH1cbiAgfVxuICBnZXRMYXN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSArIHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSAtIDE7XG4gIH1cbiAgZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDwgdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgZXBvY2ggKyB0cmFpbGluZ1plcm9zKE1JTklNVU1fU0xPVF9QRVJfRVBPQ0gpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICB9XG4gIH1cbn1cblxudmFyIGZldGNoSW1wbCA9IHR5cGVvZiBnbG9iYWxUaGlzLmZldGNoID09PSAnZnVuY3Rpb24nID9cbi8vIFRoZSBGZXRjaCBBUEkgaXMgc3VwcG9ydGVkIGV4cGVyaW1lbnRhbGx5IGluIE5vZGUgMTcuNSsgYW5kIG5hdGl2ZWx5IGluIE5vZGUgMTgrLlxuZ2xvYmFsVGhpcy5mZXRjaCA6XG4vLyBPdGhlcndpc2UgdXNlIHRoZSBwb2x5ZmlsbC5cbmFzeW5jIGZ1bmN0aW9uIChpbnB1dCwgaW5pdCkge1xuICBjb25zdCBwcm9jZXNzZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgJiYgaW5wdXQuc2xpY2UoMCwgMikgPT09ICcvLycgPyAnaHR0cHM6JyArIGlucHV0IDogaW5wdXQ7XG4gIHJldHVybiBhd2FpdCBub2RlRmV0Y2hfX25hbWVzcGFjZS5kZWZhdWx0KHByb2Nlc3NlZElucHV0LCBpbml0KTtcbn07XG5cbmNsYXNzIFJwY1dlYlNvY2tldENsaWVudCBleHRlbmRzIHJwY1dlYnNvY2tldHMuQ29tbW9uQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoYWRkcmVzcywgb3B0aW9ucywgZ2VuZXJhdGVfcmVxdWVzdF9pZCkge1xuICAgIGNvbnN0IHdlYlNvY2tldEZhY3RvcnkgPSB1cmwgPT4ge1xuICAgICAgY29uc3QgcnBjID0gcnBjV2Vic29ja2V0cy5XZWJTb2NrZXQodXJsLCB7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0cnVlLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogNSxcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IDEwMDAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCdzb2NrZXQnIGluIHJwYykge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGMuc29ja2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJwYztcbiAgICB9O1xuICAgIHN1cGVyKHdlYlNvY2tldEZhY3RvcnksIGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpO1xuICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHZvaWQgMDtcbiAgfVxuICBjYWxsKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FsbCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gY2FsbCBhIEpTT04tUlBDIG1ldGhvZCBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxuICBub3RpZnkoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIHNlbmQgYSBKU09OLVJQQyBub3RpZmljYXRpb24gYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIERlY29kZSBhY2NvdW50IGRhdGEgYnVmZmVyIHVzaW5nIGFuIEFjY291bnRUeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSh0eXBlLCBkYXRhKSB7XG4gIGxldCBkZWNvZGVkO1xuICB0cnkge1xuICAgIGRlY29kZWQgPSB0eXBlLmxheW91dC5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRlY29kZWQudHlwZUluZGV4ICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFjY291bnQgZGF0YTsgYWNjb3VudCB0eXBlIG1pc21hdGNoICR7ZGVjb2RlZC50eXBlSW5kZXh9ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLy8vIFRoZSBzZXJpYWxpemVkIHNpemUgb2YgbG9va3VwIHRhYmxlIG1ldGFkYXRhXG5jb25zdCBMT09LVVBfVEFCTEVfTUVUQV9TSVpFID0gNTY7XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBhcmdzLmtleTtcbiAgICB0aGlzLnN0YXRlID0gYXJncy5zdGF0ZTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICBjb25zdCBVNjRfTUFYID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kZWFjdGl2YXRpb25TbG90ID09PSBVNjRfTUFYO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShhY2NvdW50RGF0YSkge1xuICAgIGNvbnN0IG1ldGEgPSBkZWNvZGVEYXRhKExvb2t1cFRhYmxlTWV0YUxheW91dCwgYWNjb3VudERhdGEpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPSBhY2NvdW50RGF0YS5sZW5ndGggLSBMT09LVVBfVEFCTEVfTUVUQV9TSVpFO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuID49IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuICUgMzIgPT09IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMgPSBzZXJpYWxpemVkQWRkcmVzc2VzTGVuIC8gMzI7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKHB1YmxpY0tleSgpLCBudW1TZXJpYWxpemVkQWRkcmVzc2VzLCAnYWRkcmVzc2VzJyldKS5kZWNvZGUoYWNjb3VudERhdGEuc2xpY2UoTE9PS1VQX1RBQkxFX01FVEFfU0laRSkpO1xuICAgIHJldHVybiB7XG4gICAgICBkZWFjdGl2YXRpb25TbG90OiBtZXRhLmRlYWN0aXZhdGlvblNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90OiBtZXRhLmxhc3RFeHRlbmRlZFNsb3QsXG4gICAgICBsYXN0RXh0ZW5kZWRTbG90U3RhcnRJbmRleDogbWV0YS5sYXN0RXh0ZW5kZWRTdGFydEluZGV4LFxuICAgICAgYXV0aG9yaXR5OiBtZXRhLmF1dGhvcml0eS5sZW5ndGggIT09IDAgPyBuZXcgUHVibGljS2V5KG1ldGEuYXV0aG9yaXR5WzBdKSA6IHVuZGVmaW5lZCxcbiAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpXG4gICAgfTtcbiAgfVxufVxuY29uc3QgTG9va3VwVGFibGVNZXRhTGF5b3V0ID0ge1xuICBpbmRleDogMSxcbiAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigndHlwZUluZGV4JyksIHU2NCgnZGVhY3RpdmF0aW9uU2xvdCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdsYXN0RXh0ZW5kZWRTbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdsYXN0RXh0ZW5kZWRTdGFydEluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCksXG4gIC8vIG9wdGlvblxuICBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm9mZnNldChCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgpLCAtMSksICdhdXRob3JpdHknKV0pXG59O1xuXG5jb25zdCBVUkxfUkUgPSAvXlteOl0rOlxcL1xcLyhbXjpbXSt8XFxbW15cXF1dK1xcXSkoOlxcZCspPyguKikvaTtcbmZ1bmN0aW9uIG1ha2VXZWJzb2NrZXRVcmwoZW5kcG9pbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGVuZHBvaW50Lm1hdGNoKFVSTF9SRSk7XG4gIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoYEZhaWxlZCB0byB2YWxpZGF0ZSBlbmRwb2ludCBVUkwgXFxgJHtlbmRwb2ludH1cXGBgKTtcbiAgfVxuICBjb25zdCBbXyxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgaG9zdGlzaCwgcG9ydFdpdGhDb2xvbiwgcmVzdF0gPSBtYXRjaGVzO1xuICBjb25zdCBwcm90b2NvbCA9IGVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHBzOicpID8gJ3dzczonIDogJ3dzOic7XG4gIGNvbnN0IHN0YXJ0UG9ydCA9IHBvcnRXaXRoQ29sb24gPT0gbnVsbCA/IG51bGwgOiBwYXJzZUludChwb3J0V2l0aENvbG9uLnNsaWNlKDEpLCAxMCk7XG4gIGNvbnN0IHdlYnNvY2tldFBvcnQgPVxuICAvLyBPbmx5IHNoaWZ0IHRoZSBwb3J0IGJ5ICsxIGFzIGEgY29udmVudGlvbiBmb3Igd3Mocykgb25seSBpZiBnaXZlbiBlbmRwb2ludFxuICAvLyBpcyBleHBsaWNpdGx5IHNwZWNpZnlpbmcgdGhlIGVuZHBvaW50IHBvcnQgKEhUVFAtYmFzZWQgUlBDKSwgYXNzdW1pbmdcbiAgLy8gd2UncmUgZGlyZWN0bHkgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gYWdhdmUtdmFsaWRhdG9yJ3Mgd3MgbGlzdGVuaW5nIHBvcnQuXG4gIC8vIFdoZW4gdGhlIGVuZHBvaW50IG9taXRzIHRoZSBwb3J0LCB3ZSdyZSBjb25uZWN0aW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyBkZWZhdWx0IHBvcnRzOiBodHRwKDgwKSBvciBodHRwcyg0NDMpIGFuZCBpdCdzIGFzc3VtZWQgd2UncmUgYmVoaW5kIGEgcmV2ZXJzZVxuICAvLyBwcm94eSB3aGljaCBtYW5hZ2VzIFdlYlNvY2tldCB1cGdyYWRlIGFuZCBiYWNrZW5kIHBvcnQgcmVkaXJlY3Rpb24uXG4gIHN0YXJ0UG9ydCA9PSBudWxsID8gJycgOiBgOiR7c3RhcnRQb3J0ICsgMX1gO1xuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3Rpc2h9JHt3ZWJzb2NrZXRQb3J0fSR7cmVzdH1gO1xufVxuXG5jb25zdCBQdWJsaWNLZXlGcm9tU3RyaW5nID0gc3VwZXJzdHJ1Y3QuY29lcmNlKHN1cGVyc3RydWN0Lmluc3RhbmNlKFB1YmxpY0tleSksIHN1cGVyc3RydWN0LnN0cmluZygpLCB2YWx1ZSA9PiBuZXcgUHVibGljS2V5KHZhbHVlKSk7XG5jb25zdCBSYXdBY2NvdW50RGF0YVJlc3VsdCA9IHN1cGVyc3RydWN0LnR1cGxlKFtzdXBlcnN0cnVjdC5zdHJpbmcoKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnYmFzZTY0JyldKTtcbmNvbnN0IEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSA9IHN1cGVyc3RydWN0LmNvZXJjZShzdXBlcnN0cnVjdC5pbnN0YW5jZShidWZmZXIuQnVmZmVyKSwgUmF3QWNjb3VudERhdGFSZXN1bHQsIHZhbHVlID0+IGJ1ZmZlci5CdWZmZXIuZnJvbSh2YWx1ZVswXSwgJ2Jhc2U2NCcpKTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHVzZSBhIHJlY2VudCBibG9ja2hhc2ggZm9yIHVwIHRvIDMwIHNlY29uZHNcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyA9IDMwICogMTAwMDtcblxuLyoqXG4gKiBIQUNLLlxuICogQ29waWVkIGZyb20gcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50LlxuICogT3RoZXJ3aXNlLCBgeWFybiBidWlsZGAgZmFpbHMgd2l0aDpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9jMDU3ZWNhODFkNDc5ZWY3MDVjZGI1MzE2MmY5OTcxZFxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEV2ZXJ5IHN1YnNjcmlwdGlvbiBjb250YWlucyB0aGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoXG4gKiB0aGUgc2VydmVyLCBhbmQgYSBsaXN0IG9mIGNhbGxlcnMgaW50ZXJlc3RlZCBpbiBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBBIHN1YnNjcmlwdGlvbiBtYXkgYmUgaW4gdmFyaW91cyBzdGF0ZXMgb2YgY29ubmVjdGVkbmVzcy4gT25seSB3aGVuIGl0IGlzXG4gKiBmdWxseSBjb25uZWN0ZWQgd2lsbCBpdCBoYXZlIGEgc2VydmVyIHN1YnNjcmlwdGlvbiBpZCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBUaGlzIGlkIGNhbiBiZSByZXR1cm5lZCB0byB0aGUgc2VydmVyIHRvIHVuc3Vic2NyaWJlIHRoZSBjbGllbnQgZW50aXJlbHkuXG4gKi9cblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBlbmNhcHN1bGF0ZXMgYSBzdWJzY3JpcHRpb24ncyBSUEMgbWV0aG9kXG4gKiBuYW1lcyBhbmQgbm90aWZpY2F0aW9uIChjYWxsYmFjaykgc2lnbmF0dXJlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBVdGlsaXR5IHR5cGUgdGhhdCBrZWVwcyB0YWdnZWQgdW5pb25zIGludGFjdCB3aGlsZSBvbWl0dGluZyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhIHNpbmdsZSBzdWJzY3JpYmFibGUgJ3RvcGljLicgSXQncyBtYWRlIHVwIG9mOlxuICpcbiAqIC0gVGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aCB0aGUgc2VydmVyLFxuICogLSBUaGUgc3RhdGUgb2YgdGhlIHN1YnNjcmlwdGlvbiwgaW4gdGVybXMgb2YgaXRzIGNvbm5lY3RlZG5lc3MsIGFuZFxuICogLSBUaGUgc2V0IG9mIGNhbGxiYWNrcyB0byBjYWxsIHdoZW4gdGhlIHNlcnZlciBwdWJsaXNoZXMgbm90aWZpY2F0aW9uc1xuICpcbiAqIFRoaXMgcmVjb3JkIGdldHMgaW5kZXhlZCBieSBgU3Vic2NyaXB0aW9uQ29uZmlnSGFzaGAgYW5kIGlzIHVzZWQgdG9cbiAqIHNldCB1cCBzdWJzY3JpcHRpb25zLCBmYW4gb3V0IG5vdGlmaWNhdGlvbnMsIGFuZCB0cmFjayBzdWJzY3JpcHRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gZm9yIFJQQyByZXNwb25zZXNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHNlbmRpbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1xuICovXG5cbi8qKlxuICogUlBDIFJlc3BvbnNlIHdpdGggZXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnMgdGhhdCB1c2VzIHRoZSBsYXN0IHZhbGlkXG4gKiBibG9jayBoZWlnaHQgZm9yIGEgZ2l2ZW4gYmxvY2toYXNoIHRvIGNoZWNrIGZvciB0cmFuc2FjdGlvbiBleHBpcmF0aW9uLlxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBhc3NlcnRFbmRwb2ludFVybChwdXRhdGl2ZVVybCkge1xuICBpZiAoL15odHRwcz86Ly50ZXN0KHB1dGF0aXZlVXJsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmRwb2ludCBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJyk7XG4gIH1cbiAgcmV0dXJuIHB1dGF0aXZlVXJsO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gIGxldCBjb21taXRtZW50O1xuICBsZXQgY29uZmlnO1xuICBpZiAodHlwZW9mIGNvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb21taXRtZW50ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICB9IGVsc2UgaWYgKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQ6IHNwZWNpZmllZENvbW1pdG1lbnQsXG4gICAgICAuLi5zcGVjaWZpZWRDb25maWdcbiAgICB9ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIGNvbW1pdG1lbnQgPSBzcGVjaWZpZWRDb21taXRtZW50O1xuICAgIGNvbmZpZyA9IHNwZWNpZmllZENvbmZpZztcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1pdG1lbnQsXG4gICAgY29uZmlnXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE1lbWNtcEVuY29kaW5nVG9GaWx0ZXJzKGZpbHRlcnMpIHtcbiAgcmV0dXJuIGZpbHRlcnMubWFwKGZpbHRlciA9PiAnbWVtY21wJyBpbiBmaWx0ZXIgPyB7XG4gICAgLi4uZmlsdGVyLFxuICAgIG1lbWNtcDoge1xuICAgICAgLi4uZmlsdGVyLm1lbWNtcCxcbiAgICAgIGVuY29kaW5nOiBmaWx0ZXIubWVtY21wLmVuY29kaW5nID8/ICdiYXNlNTgnXG4gICAgfVxuICB9IDogZmlsdGVyKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUnBjUmVzdWx0KHJlc3VsdCkge1xuICByZXR1cm4gc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LnR5cGUoe1xuICAgIGpzb25ycGM6IHN1cGVyc3RydWN0LmxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICByZXN1bHRcbiAgfSksIHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGpzb25ycGM6IHN1cGVyc3RydWN0LmxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICBlcnJvcjogc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgICBjb2RlOiBzdXBlcnN0cnVjdC51bmtub3duKCksXG4gICAgICBtZXNzYWdlOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICAgIGRhdGE6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LmFueSgpKVxuICAgIH0pXG4gIH0pXSk7XG59XG5jb25zdCBVbmtub3duUnBjUmVzdWx0ID0gY3JlYXRlUnBjUmVzdWx0KHN1cGVyc3RydWN0LnVua25vd24oKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHQoc2NoZW1hKSB7XG4gIHJldHVybiBzdXBlcnN0cnVjdC5jb2VyY2UoY3JlYXRlUnBjUmVzdWx0KHNjaGVtYSksIFVua25vd25ScGNSZXN1bHQsIHZhbHVlID0+IHtcbiAgICBpZiAoJ2Vycm9yJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgcmVzdWx0OiBzdXBlcnN0cnVjdC5jcmVhdGUodmFsdWUucmVzdWx0LCBzY2hlbWEpXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGNvbnRleHQ6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgICAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGNvbnRleHQ6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgICAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCByZXNwb25zZSkge1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcjogcmVzcG9uc2UuaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IHJlc3BvbnNlLmFjY291bnRLZXlzLm1hcChhY2NvdW50S2V5ID0+IG5ldyBQdWJsaWNLZXkoYWNjb3VudEtleSkpLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiByZXNwb25zZS5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogcmVzcG9uc2UuaW5zdHJ1Y3Rpb25zLm1hcChpeCA9PiAoe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgZGF0YTogYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmRlY29kZShpeC5kYXRhKVxuICAgICAgfSkpLFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3VwczogcmVzcG9uc2UuYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZShyZXNwb25zZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGV2ZWwgb2YgY29tbWl0bWVudCBkZXNpcmVkIHdoZW4gcXVlcnlpbmcgc3RhdGVcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNvbm5lY3RlZCBub2RlXG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8vIERlcHJlY2F0ZWQgYXMgb2YgdjEuNS41XG5cbi8qKlxuICogQSBzdWJzZXQgb2YgQ29tbWl0bWVudCBsZXZlbHMsIHdoaWNoIGFyZSBhdCBsZWFzdCBvcHRpbWlzdGljYWxseSBjb25maXJtZWRcbiAqIDxwcmU+XG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogRmlsdGVyIGZvciBsYXJnZXN0IGFjY291bnRzIHF1ZXJ5XG4gKiA8cHJlPlxuICogICAnY2lyY3VsYXRpbmcnOiAgICBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiAgICdub25DaXJjdWxhdGluZyc6IFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgY2lyY3VsYXRpbmcgc3VwcGx5XG4gKiA8L3ByZT5cbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QWNjb3VudEluZm9gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJhbGFuY2VgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tIZWlnaHRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEVwb2NoSW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0SW5mbGF0aW9uUmV3YXJkYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXRlc3RCbG9ja2hhc2hgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGlzQmxvY2toYXNoVmFsaWRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFNsb3RgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFNsb3RMZWFkZXJgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0TGFyZ2VzdEFjY291bnRzYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdXBwbHlgIHJlcXVlc3QgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhIGNsdXN0ZXIgbm9kZVxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhIHZvdGUgYWNjb3VudFxuICovXG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNsdXN0ZXIgdm90ZSBhY2NvdW50c1xuICovXG5cbi8qKlxuICogTmV0d29yayBJbmZsYXRpb25cbiAqIChzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vaW1wbGVtZW50ZWQtcHJvcG9zYWxzL2VkX292ZXJ2aWV3KVxuICovXG5cbmNvbnN0IEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGZvdW5kYXRpb246IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBmb3VuZGF0aW9uVGVybTogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGluaXRpYWw6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0YXBlcjogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRlcm1pbmFsOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxufSk7XG5cbi8qKlxuICogVGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGFuIGVwb2NoXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmV3YXJkXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGVmZmVjdGl2ZVNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBhbW91bnQ6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBwb3N0QmFsYW5jZTogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGNvbW1pc3Npb246IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSlcbn0pKSkpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0ID0gc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBwcmlvcml0aXphdGlvbkZlZTogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pKTtcbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJhdGVSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgdG90YWw6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB2YWxpZGF0b3I6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBmb3VuZGF0aW9uOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgZXBvY2g6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlcG9jaFxuICovXG5cbmNvbnN0IEdldEVwb2NoSW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNsb3RJbmRleDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNsb3RzSW5FcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGFic29sdXRlU2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGJsb2NrSGVpZ2h0OiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHRyYW5zYWN0aW9uQ291bnQ6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSk7XG5jb25zdCBHZXRFcG9jaFNjaGVkdWxlUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3RzUGVyRXBvY2g6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB3YXJtdXA6IHN1cGVyc3RydWN0LmJvb2xlYW4oKSxcbiAgZmlyc3ROb3JtYWxFcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGZpcnN0Tm9ybWFsU2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIExlYWRlciBzY2hlZHVsZVxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS90ZXJtaW5vbG9neSNsZWFkZXItc2NoZWR1bGUpXG4gKi9cblxuY29uc3QgR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQgPSBzdXBlcnN0cnVjdC5yZWNvcmQoc3VwZXJzdHJ1Y3Quc3RyaW5nKCksIHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bWJlcigpKSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3Igb3IgbnVsbFxuICovXG5jb25zdCBUcmFuc2FjdGlvbkVycm9yUmVzdWx0ID0gc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LnR5cGUoe30pLCBzdXBlcnN0cnVjdC5zdHJpbmcoKV0pKTtcblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIGZvciBhIHRyYW5zYWN0aW9uXG4gKi9cbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHRcbn0pO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSByZWNlaXZlZCBub3RpZmljYXRpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHQgPSBzdXBlcnN0cnVjdC5saXRlcmFsKCdyZWNlaXZlZFNpZ25hdHVyZScpO1xuXG4vKipcbiAqIFZlcnNpb24gaW5mbyBmb3IgYSBub2RlXG4gKi9cblxuY29uc3QgVmVyc2lvblJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICAnc29sYW5hLWNvcmUnOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgJ2ZlYXR1cmUtc2V0Jzogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KTtcbmNvbnN0IFBhcnNlZEluc3RydWN0aW9uU3RydWN0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHByb2dyYW06IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHBhcnNlZDogc3VwZXJzdHJ1Y3QudW5rbm93bigpXG59KTtcbmNvbnN0IFBhcnRpYWxseURlY29kZWRJbnN0cnVjdGlvblN0cnVjdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnRzOiBzdXBlcnN0cnVjdC5hcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgZGF0YTogc3VwZXJzdHJ1Y3Quc3RyaW5nKClcbn0pO1xuY29uc3QgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcnI6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnVuaW9uKFtzdXBlcnN0cnVjdC50eXBlKHt9KSwgc3VwZXJzdHJ1Y3Quc3RyaW5nKCldKSksXG4gIGxvZ3M6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSksXG4gIGFjY291bnRzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC50eXBlKHtcbiAgICBleGVjdXRhYmxlOiBzdXBlcnN0cnVjdC5ib29sZWFuKCksXG4gICAgb3duZXI6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICAgIGxhbXBvcnRzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICBkYXRhOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gICAgcmVudEVwb2NoOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udW1iZXIoKSlcbiAgfSkpKSkpLFxuICB1bml0c0NvbnN1bWVkOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHJldHVybkRhdGE6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIHByb2dyYW1JZDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gICAgZGF0YTogc3VwZXJzdHJ1Y3QudHVwbGUoW3N1cGVyc3RydWN0LnN0cmluZygpLCBzdXBlcnN0cnVjdC5saXRlcmFsKCdiYXNlNjQnKV0pXG4gIH0pKSksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC50eXBlKHtcbiAgICBpbmRleDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC51bmlvbihbUGFyc2VkSW5zdHJ1Y3Rpb25TdHJ1Y3QsIFBhcnRpYWxseURlY29kZWRJbnN0cnVjdGlvblN0cnVjdF0pKVxuICB9KSkpKVxufSkpO1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIHBhcnNlZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25NZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBhZGRyZXNzZXMgbG9hZGVkIGJ5IGEgdHJhbnNhY3Rpb24gdXNpbmcgYWRkcmVzcyB0YWJsZSBsb29rdXBzXG4gKi9cblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIEEgcGFydGlhbGx5IGRlY29kZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG1lc3NhZ2UgYWNjb3VudFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFkZHJlc3MgdGFibGUgbG9va3VwXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvblxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgYW5kIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBQYXJzZWRUcmFuc2FjdGlvbldpdGhNZXRhfSBpbnN0ZWFkLlxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlciB3aXRoIG1ldGFcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgYmxvY2sgd2l0aCBwYXJzZWQgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9ucyB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSVxuICovXG5cbi8qKlxuICogQSBwcm9jZXNzZWQgYmxvY2sgZmV0Y2hlZCBmcm9tIHRoZSBSUEMgQVBJIHdoZXJlIHRoZSBgdHJhbnNhY3Rpb25EZXRhaWxzYCBtb2RlIGlzIGBhY2NvdW50c2BcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgbm9uZWBcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIGJsb2NrIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIEJsb2NrIG9uIHRoZSBsZWRnZXIgd2l0aCBzaWduYXR1cmVzIG9ubHlcbiAqL1xuXG4vKipcbiAqIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tQcm9kdWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LnR5cGUoe1xuICBieUlkZW50aXR5OiBzdXBlcnN0cnVjdC5yZWNvcmQoc3VwZXJzdHJ1Y3Quc3RyaW5nKCksIHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bWJlcigpKSksXG4gIHJhbmdlOiBzdXBlcnN0cnVjdC50eXBlKHtcbiAgICBmaXJzdFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICAgIGxhc3RTbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEEgcGVyZm9ybWFuY2Ugc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUnBjQ2xpZW50KHVybCwgaHR0cEhlYWRlcnMsIGN1c3RvbUZldGNoLCBmZXRjaE1pZGRsZXdhcmUsIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0LCBodHRwQWdlbnQpIHtcbiAgY29uc3QgZmV0Y2ggPSBjdXN0b21GZXRjaCA/IGN1c3RvbUZldGNoIDogZmV0Y2hJbXBsO1xuICBsZXQgYWdlbnQ7XG4gIHtcbiAgICBpZiAoaHR0cEFnZW50ID09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAgICAgIC8vIE9uZSBzZWNvbmQgZmV3ZXIgdGhhbiB0aGUgU29sYW5hIFJQQydzIGtlZXBhbGl2ZSB0aW1lb3V0LlxuICAgICAgICAgIC8vIFJlYWQgbW9yZTogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMjc4NTkjaXNzdWVjb21tZW50LTEzNDAwOTc4ODlcbiAgICAgICAgICBmcmVlU29ja2V0VGltZW91dDogMTkwMDAsXG4gICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgIG1heFNvY2tldHM6IDI1XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aCgnaHR0cHM6JykpIHtcbiAgICAgICAgICBhZ2VudCA9IG5ldyBhZ2VudGtlZXBhbGl2ZUV4cG9ydHMuSHR0cHNBZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFnZW50ID0gbmV3IEh0dHBLZWVwQWxpdmVBZ2VudChhZ2VudE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChodHRwQWdlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlzSHR0cHMgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Jyk7XG4gICAgICAgIGlmIChpc0h0dHBzICYmICEoaHR0cEFnZW50IGluc3RhbmNlb2YgcmVxdWlyZSQkMCQyLkFnZW50KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVuZHBvaW50IGAnICsgdXJsICsgJ2AgY2FuIG9ubHkgYmUgcGFpcmVkIHdpdGggYW4gYGh0dHBzLkFnZW50YC4gWW91IGhhdmUsIGluc3RlYWQsIHN1cHBsaWVkIGFuICcgKyAnYGh0dHAuQWdlbnRgIHRocm91Z2ggYGh0dHBBZ2VudGAuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzSHR0cHMgJiYgaHR0cEFnZW50IGluc3RhbmNlb2YgcmVxdWlyZSQkMCQyLkFnZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZW5kcG9pbnQgYCcgKyB1cmwgKyAnYCBjYW4gb25seSBiZSBwYWlyZWQgd2l0aCBhbiBgaHR0cC5BZ2VudGAuIFlvdSBoYXZlLCBpbnN0ZWFkLCBzdXBwbGllZCBhbiAnICsgJ2BodHRwcy5BZ2VudGAgdGhyb3VnaCBgaHR0cEFnZW50YC4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZldGNoV2l0aE1pZGRsZXdhcmU7XG4gIGlmIChmZXRjaE1pZGRsZXdhcmUpIHtcbiAgICBmZXRjaFdpdGhNaWRkbGV3YXJlID0gYXN5bmMgKGluZm8sIGluaXQpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVkRmV0Y2hBcmdzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZldGNoTWlkZGxld2FyZShpbmZvLCBpbml0LCAobW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXQpID0+IHJlc29sdmUoW21vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0XSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF3YWl0IGZldGNoKC4uLm1vZGlmaWVkRmV0Y2hBcmdzKTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNsaWVudEJyb3dzZXIgPSBuZXcgUnBjQ2xpZW50X19kZWZhdWx0LmRlZmF1bHQoYXN5bmMgKHJlcXVlc3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGFnZW50LFxuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sIGh0dHBIZWFkZXJzIHx8IHt9LCBDT01NT05fSFRUUF9IRUFERVJTKVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID0gNTtcbiAgICAgIGxldCByZXM7XG4gICAgICBsZXQgd2FpdFRpbWUgPSA1MDA7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChmZXRjaFdpdGhNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2hXaXRoTWlkZGxld2FyZSh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT09IDQyOSAvKiBUb28gbWFueSByZXF1ZXN0cyAqLykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgLT0gMTtcbiAgICAgICAgaWYgKHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fS4gIFJldHJ5aW5nIGFmdGVyICR7d2FpdFRpbWV9bXMgZGVsYXkuLi5gKTtcbiAgICAgICAgYXdhaXQgc2xlZXAod2FpdFRpbWUpO1xuICAgICAgICB3YWl0VGltZSAqPSAyO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9OiAke3RleHR9YCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSwge30pO1xuICByZXR1cm4gY2xpZW50QnJvd3Nlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY1JlcXVlc3QoY2xpZW50KSB7XG4gIHJldHVybiAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgYXJncywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gcmVxdWVzdHMgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHJlcXVlc3RzIGlzIGVtcHR5XG4gICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKTtcbiAgICAgIGNvbnN0IGJhdGNoID0gcmVxdWVzdHMubWFwKHBhcmFtcyA9PiB7XG4gICAgICAgIHJldHVybiBjbGllbnQucmVxdWVzdChwYXJhbXMubWV0aG9kTmFtZSwgcGFyYW1zLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBjbGllbnQucmVxdWVzdChiYXRjaCwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25Hb3Zlcm5vclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaEluZm9cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoSW5mb1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hJbmZvUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExlYWRlclNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJtaW5pbXVtTGVkZ2VyU2xvdFwiIGFuZCBcImdldEZpcnN0QXZhaWxhYmxlQmxvY2tcIiBtZXNzYWdlc1xuICovXG5jb25zdCBTbG90UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udW1iZXIoKSk7XG5cbi8qKlxuICogU3VwcGx5XG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U3VwcGx5XCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTdXBwbHlScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC50eXBlKHtcbiAgdG90YWw6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBjaXJjdWxhdGluZzogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmdBY2NvdW50czogc3VwZXJzdHJ1Y3QuYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pKTtcblxuLyoqXG4gKiBUb2tlbiBhbW91bnQgb2JqZWN0IHdoaWNoIHJldHVybnMgYSB0b2tlbiBhbW91bnQgaW4gZGlmZmVyZW50IGZvcm1hdHNcbiAqIGZvciB2YXJpb3VzIGNsaWVudCB1c2UgY2FzZXMuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyBzdHJ1Y3R1cmUgZm9yIHRva2VuIGFtb3VudHNcbiAqL1xuY29uc3QgVG9rZW5BbW91bnRSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgYW1vdW50OiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgdWlBbW91bnQ6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgZGVjaW1hbHM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBUb2tlbiBhZGRyZXNzIGFuZCBiYWxhbmNlLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuTGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhbW91bnQ6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICB1aUFtb3VudDogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBkZWNpbWFsczogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHVpQW1vdW50U3RyaW5nOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5zdHJpbmcoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IHN1cGVyc3RydWN0LmJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gICAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICAgIHJlbnRFcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgfSlcbn0pKSk7XG5jb25zdCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwcm9ncmFtOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcGFyc2VkOiBzdXBlcnN0cnVjdC51bmtub3duKCksXG4gIHNwYWNlOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZSB3aXRoIHBhcnNlZCBkYXRhXG4gKi9cbmNvbnN0IEdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgZXhlY3V0YWJsZTogc3VwZXJzdHJ1Y3QuYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICBkYXRhOiBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCxcbiAgICByZW50RXBvY2g6IHN1cGVyc3RydWN0Lm51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIFBhaXIgb2YgYW4gYWNjb3VudCBhZGRyZXNzIGFuZCBpdHMgYmFsYW5jZVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGxhbXBvcnRzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZ1xufSkpKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQWNjb3VudEluZm9SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgZXhlY3V0YWJsZTogc3VwZXJzdHJ1Y3QuYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBLZXllZEFjY291bnRJbmZvUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuY29uc3QgUGFyc2VkT3JSYXdBY2NvdW50RGF0YSA9IHN1cGVyc3RydWN0LmNvZXJjZShzdXBlcnN0cnVjdC51bmlvbihbc3VwZXJzdHJ1Y3QuaW5zdGFuY2UoYnVmZmVyLkJ1ZmZlciksIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIHN1cGVyc3RydWN0LnVuaW9uKFtSYXdBY2NvdW50RGF0YVJlc3VsdCwgUGFyc2VkQWNjb3VudERhdGFSZXN1bHRdKSwgdmFsdWUgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3VwZXJzdHJ1Y3QuY3JlYXRlKHZhbHVlLCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGV4ZWN1dGFibGU6IHN1cGVyc3RydWN0LmJvb2xlYW4oKSxcbiAgb3duZXI6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGxhbXBvcnRzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgZGF0YTogUGFyc2VkT3JSYXdBY2NvdW50RGF0YSxcbiAgcmVudEVwb2NoOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxufSk7XG5jb25zdCBLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogUGFyc2VkQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTdGFrZUFjdGl2YXRpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgc3RhdGU6IHN1cGVyc3RydWN0LnVuaW9uKFtzdXBlcnN0cnVjdC5saXRlcmFsKCdhY3RpdmUnKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnaW5hY3RpdmUnKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnYWN0aXZhdGluZycpLCBzdXBlcnN0cnVjdC5saXRlcmFsKCdkZWFjdGl2YXRpbmcnKV0pLFxuICBhY3RpdmU6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBpbmFjdGl2ZTogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcIiBtZXNzYWdlXG4gKi9cblxuY29uc3QgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC50eXBlKHtcbiAgc2lnbmF0dXJlOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZXNGb3JBZGRyZXNzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNpZ25hdHVyZTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSkpXG59KSkpO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiYWNjb3VudE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBzdWJzY3JpcHRpb246IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuXG4vKioqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicHJvZ3JhbU5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbG90SW5mb1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwYXJlbnQ6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBzbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcm9vdDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTbG90Tm90aWZpY2F0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHJlc3VsdDogU2xvdEluZm9SZXN1bHRcbn0pO1xuXG4vKipcbiAqIFNsb3QgdXBkYXRlcyB3aGljaCBjYW4gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIGxpdmUgcHJvZ3Jlc3Mgb2YgYSBjbHVzdGVyLlxuICogLSBgXCJmaXJzdFNocmVkUmVjZWl2ZWRcImA6IGNvbm5lY3RlZCBub2RlIHJlY2VpdmVkIHRoZSBmaXJzdCBzaHJlZCBvZiBhIGJsb2NrLlxuICogSW5kaWNhdGVzIHRoYXQgYSBuZXcgYmxvY2sgdGhhdCBpcyBiZWluZyBwcm9kdWNlZC5cbiAqIC0gYFwiY29tcGxldGVkXCJgOiBjb25uZWN0ZWQgbm9kZSBoYXMgcmVjZWl2ZWQgYWxsIHNocmVkcyBvZiBhIGJsb2NrLiBJbmRpY2F0ZXNcbiAqIGEgYmxvY2sgd2FzIHJlY2VudGx5IHByb2R1Y2VkLlxuICogLSBgXCJvcHRpbWlzdGljQ29uZmlybWF0aW9uXCJgOiBibG9jayB3YXMgb3B0aW1pc3RpY2FsbHkgY29uZmlybWVkIGJ5IHRoZVxuICogY2x1c3Rlci4gSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCBhbiBvcHRpbWlzdGljIGNvbmZpcm1hdGlvbiBub3RpZmljYXRpb25cbiAqIHdpbGwgYmUgc2VudCBmb3IgZXZlcnkgZmluYWxpemVkIGJsb2Nrcy5cbiAqIC0gYFwicm9vdFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIHJvb3RlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJjcmVhdGVkQmFua1wiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyBzdGFydGVkIHZhbGlkYXRpbmcgdGhpcyBibG9jay5cbiAqIC0gYFwiZnJvemVuXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHZhbGlkYXRlZCB0aGlzIGJsb2NrLlxuICogLSBgXCJkZWFkXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgZmFpbGVkIHRvIHZhbGlkYXRlIHRoaXMgYmxvY2suXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZVJlc3VsdCA9IHN1cGVyc3RydWN0LnVuaW9uKFtzdXBlcnN0cnVjdC50eXBlKHtcbiAgdHlwZTogc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LmxpdGVyYWwoJ2ZpcnN0U2hyZWRSZWNlaXZlZCcpLCBzdXBlcnN0cnVjdC5saXRlcmFsKCdjb21wbGV0ZWQnKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnb3B0aW1pc3RpY0NvbmZpcm1hdGlvbicpLCBzdXBlcnN0cnVjdC5saXRlcmFsKCdyb290JyldKSxcbiAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRpbWVzdGFtcDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pLCBzdXBlcnN0cnVjdC50eXBlKHtcbiAgdHlwZTogc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnY3JlYXRlZEJhbmsnKSxcbiAgcGFyZW50OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgc2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRpbWVzdGFtcDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbn0pLCBzdXBlcnN0cnVjdC50eXBlKHtcbiAgdHlwZTogc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnZnJvemVuJyksXG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0aW1lc3RhbXA6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBzdGF0czogc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgbnVtVHJhbnNhY3Rpb25FbnRyaWVzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICBudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICBudW1GYWlsZWRUcmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICAgIG1heFRyYW5zYWN0aW9uc1BlckVudHJ5OiBzdXBlcnN0cnVjdC5udW1iZXIoKVxuICB9KVxufSksIHN1cGVyc3RydWN0LnR5cGUoe1xuICB0eXBlOiBzdXBlcnN0cnVjdC5saXRlcmFsKCdkZWFkJyksXG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0aW1lc3RhbXA6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBlcnI6IHN1cGVyc3RydWN0LnN0cmluZygpXG59KV0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90c1VwZGF0ZXNOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90VXBkYXRlUmVzdWx0XG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2lnbmF0dXJlTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBTaWduYXR1cmVOb3RpZmljYXRpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LnVuaW9uKFtTaWduYXR1cmVTdGF0dXNSZXN1bHQsIFNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0XSkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicm9vdE5vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBzdWJzY3JpcHRpb246IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICByZXN1bHQ6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcbmNvbnN0IENvbnRhY3RJbmZvUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHB1YmtleTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIGdvc3NpcDogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICB0cHU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgcnBjOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gIHZlcnNpb246IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnN0cmluZygpKVxufSk7XG5jb25zdCBWb3RlQWNjb3VudEluZm9SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgdm90ZVB1YmtleTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIG5vZGVQdWJrZXk6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBhY3RpdmF0ZWRTdGFrZTogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGVwb2NoVm90ZUFjY291bnQ6IHN1cGVyc3RydWN0LmJvb2xlYW4oKSxcbiAgZXBvY2hDcmVkaXRzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC50dXBsZShbc3VwZXJzdHJ1Y3QubnVtYmVyKCksIHN1cGVyc3RydWN0Lm51bWJlcigpLCBzdXBlcnN0cnVjdC5udW1iZXIoKV0pKSxcbiAgY29tbWlzc2lvbjogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIGxhc3RWb3RlOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcm9vdFNsb3Q6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFZvdGVBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0Vm90ZUFjY291bnRzID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC50eXBlKHtcbiAgY3VycmVudDogc3VwZXJzdHJ1Y3QuYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KSxcbiAgZGVsaW5xdWVudDogc3VwZXJzdHJ1Y3QuYXJyYXkoVm90ZUFjY291bnRJbmZvUmVzdWx0KVxufSkpO1xuY29uc3QgQ29uZmlybWF0aW9uU3RhdHVzID0gc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LmxpdGVyYWwoJ3Byb2Nlc3NlZCcpLCBzdXBlcnN0cnVjdC5saXRlcmFsKCdjb25maXJtZWQnKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnZmluYWxpemVkJyldKTtcbmNvbnN0IFNpZ25hdHVyZVN0YXR1c1Jlc3BvbnNlID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBjb25maXJtYXRpb25zOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgY29uZmlybWF0aW9uU3RhdHVzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChDb25maXJtYXRpb25TdGF0dXMpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U2lnbmF0dXJlU3RhdHVzZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVsbGFibGUoU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UpKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udW1iZXIoKSk7XG5jb25zdCBBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgYWNjb3VudEtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgd3JpdGFibGVJbmRleGVzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHJlYWRvbmx5SW5kZXhlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KTtcbmNvbnN0IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNpZ25hdHVyZXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgbWVzc2FnZTogc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgYWNjb3VudEtleXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgICBoZWFkZXI6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxuICAgIH0pLFxuICAgIGluc3RydWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgICBhY2NvdW50czogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSksXG4gICAgcmVjZW50QmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5hcnJheShBZGRyZXNzVGFibGVMb29rdXBTdHJ1Y3QpKVxuICB9KVxufSk7XG5jb25zdCBBbm5vdGF0ZWRBY2NvdW50S2V5ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgc2lnbmVyOiBzdXBlcnN0cnVjdC5ib29sZWFuKCksXG4gIHdyaXRhYmxlOiBzdXBlcnN0cnVjdC5ib29sZWFuKCksXG4gIHNvdXJjZTogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LmxpdGVyYWwoJ3RyYW5zYWN0aW9uJyksIHN1cGVyc3RydWN0LmxpdGVyYWwoJ2xvb2t1cFRhYmxlJyldKSlcbn0pO1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgYWNjb3VudEtleXM6IHN1cGVyc3RydWN0LmFycmF5KEFubm90YXRlZEFjY291bnRLZXkpLFxuICBzaWduYXR1cmVzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5zdHJpbmcoKSlcbn0pO1xuY29uc3QgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgcGFyc2VkOiBzdXBlcnN0cnVjdC51bmtub3duKCksXG4gIHByb2dyYW06IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pO1xuY29uc3QgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgYWNjb3VudHM6IHN1cGVyc3RydWN0LmFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbmNvbnN0IEluc3RydWN0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudW5pb24oW1Jhd0luc3RydWN0aW9uUmVzdWx0LCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdF0pO1xuY29uc3QgVW5rbm93bkluc3RydWN0aW9uUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudW5pb24oW3N1cGVyc3RydWN0LnR5cGUoe1xuICBwYXJzZWQ6IHN1cGVyc3RydWN0LnVua25vd24oKSxcbiAgcHJvZ3JhbTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3VwZXJzdHJ1Y3Quc3RyaW5nKClcbn0pLCBzdXBlcnN0cnVjdC50eXBlKHtcbiAgYWNjb3VudHM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgZGF0YTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByb2dyYW1JZDogc3VwZXJzdHJ1Y3Quc3RyaW5nKClcbn0pXSk7XG5jb25zdCBQYXJzZWRPclJhd0luc3RydWN0aW9uID0gc3VwZXJzdHJ1Y3QuY29lcmNlKEluc3RydWN0aW9uUmVzdWx0LCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQsIHZhbHVlID0+IHtcbiAgaWYgKCdhY2NvdW50cycgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzdHJ1Y3QuY3JlYXRlKHZhbHVlLCBSYXdJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN1cGVyc3RydWN0LmNyZWF0ZSh2YWx1ZSwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQpO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgc2lnbmF0dXJlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICBtZXNzYWdlOiBzdXBlcnN0cnVjdC50eXBlKHtcbiAgICBhY2NvdW50S2V5czogc3VwZXJzdHJ1Y3QuYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBzdXBlcnN0cnVjdC5hcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpKVxuICB9KVxufSk7XG5jb25zdCBUb2tlbkJhbGFuY2VSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgYWNjb3VudEluZGV4OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgbWludDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIG93bmVyOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gIHByb2dyYW1JZDogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG5jb25zdCBMb2FkZWRBZGRyZXNzZXNSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgd3JpdGFibGU6IHN1cGVyc3RydWN0LmFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICByZWFkb25seTogc3VwZXJzdHJ1Y3QuYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBmZWU6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBpbm5lckluc3RydWN0aW9uczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgaW5kZXg6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICAgIGluc3RydWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgICBhY2NvdW50czogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICAgICAgZGF0YTogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gICAgICBwcm9ncmFtSWRJbmRleDogc3VwZXJzdHJ1Y3QubnVtYmVyKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHBvc3RCYWxhbmNlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBsb2dNZXNzYWdlczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KFRva2VuQmFsYW5jZVJlc3VsdCkpKSxcbiAgbG9hZGVkQWRkcmVzc2VzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChMb2FkZWRBZGRyZXNzZXNSZXN1bHQpLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGluZGV4OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5hcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSk7XG5jb25zdCBUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QgPSBzdXBlcnN0cnVjdC51bmlvbihbc3VwZXJzdHJ1Y3QubGl0ZXJhbCgwKSwgc3VwZXJzdHJ1Y3QubGl0ZXJhbCgnbGVnYWN5JyldKTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgUmV3YXJkc1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBwdWJrZXk6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBsYW1wb3J0czogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIHJld2FyZFR5cGU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgY29tbWlzc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IHN1cGVyc3RydWN0Lm51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LmFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC50eXBlKHtcbiAgYmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwYXJlbnRTbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmV3YXJkczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QuYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlIHdoZW4gYHRyYW5zYWN0aW9uRGV0YWlsc2AgaXMgYGFjY291bnRzYFxuICovXG5jb25zdCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogc3VwZXJzdHJ1Y3QuYXJyYXkoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0LFxuICAgIG1ldGE6IHN1cGVyc3RydWN0Lm51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LmFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBibG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IHN1cGVyc3RydWN0Lm9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5hcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBibG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IHN1cGVyc3RydWN0Lm9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5hcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG5jb25zdCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC50eXBlKHtcbiAgYmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwYXJlbnRTbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgcmV3YXJkczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QuYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Q29uZmlybWVkQmxvY2tcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRCbG9ja1JwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0LnR5cGUoe1xuICBibG9ja2hhc2g6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpXG4gIH0pKSxcbiAgcmV3YXJkczogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QuYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGJsb2NraGFzaDogc3VwZXJzdHJ1Y3Quc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogc3VwZXJzdHJ1Y3QubnVtYmVyKCksXG4gIHNpZ25hdHVyZXM6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBzdXBlcnN0cnVjdC5udWxsYWJsZShzdXBlcnN0cnVjdC5udW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBtZXRhOiBzdXBlcnN0cnVjdC5udWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSksXG4gIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIHNsb3Q6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIG1ldGE6IHN1cGVyc3RydWN0Lm51bGxhYmxlKFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gIGJsb2NrVGltZTogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKSxcbiAgdmVyc2lvbjogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGF0ZXN0QmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC50eXBlKHtcbiAgYmxvY2toYXNoOiBzdXBlcnN0cnVjdC5zdHJpbmcoKSxcbiAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImlzQmxvY2toYXNoVmFsaWRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5ib29sZWFuKCkpO1xuY29uc3QgUGVyZlNhbXBsZVJlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBzbG90OiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgbnVtVHJhbnNhY3Rpb25zOiBzdXBlcnN0cnVjdC5udW1iZXIoKSxcbiAgbnVtU2xvdHM6IHN1cGVyc3RydWN0Lm51bWJlcigpLFxuICBzYW1wbGVQZXJpb2RTZWNzOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxufSk7XG5cbi8qXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgXCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QuYXJyYXkoUGVyZlNhbXBsZVJlc3VsdCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIGZlZUNhbGN1bGF0b3I6IHN1cGVyc3RydWN0LnR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBzdXBlcnN0cnVjdC5udW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicmVxdWVzdEFpcmRyb3BcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5zdHJpbmcoKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNlbmRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5zdHJpbmcoKSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBzbG90IGJlaW5nIHByb2Nlc3NlZCBieSBhIG5vZGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlZCBhY2NvdW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFN0YWtlIEFjdGl2YXRpb24gZGF0YVxuICovXG5cbi8qKlxuICogRGF0YSBzbGljZSBhcmd1bWVudCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBNZW1vcnkgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogRGF0YSBzaXplIGNvbXBhcmlzb24gZmlsdGVyIGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIEEgZmlsdGVyIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0TXVsdGlwbGVBY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZWBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VBbmRDb250ZXh0YFxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhbiBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBY2NvdW50IGluZm9ybWF0aW9uIGlkZW50aWZpZWQgYnkgcHVia2V5XG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHByb2dyYW0gYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IHVwZGF0ZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbiB3aXRoIHRyYW5zYWN0aW9uIHJlc3VsdFxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciByb290IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9nc1Jlc3VsdCA9IHN1cGVyc3RydWN0LnR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGxvZ3M6IHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgc2lnbmF0dXJlOiBzdXBlcnN0cnVjdC5zdHJpbmcoKVxufSk7XG5cbi8qKlxuICogTG9ncyByZXN1bHQuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibG9nc05vdGlmaWNhdGlvblwiIG1lc3NhZ2UuXG4gKi9cbmNvbnN0IExvZ3NOb3RpZmljYXRpb25SZXN1bHQgPSBzdXBlcnN0cnVjdC50eXBlKHtcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KExvZ3NSZXN1bHQpLFxuICBzdWJzY3JpcHRpb246IHN1cGVyc3RydWN0Lm51bWJlcigpXG59KTtcblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxvZyBzdWJzY3JpcHRpb25zLlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGxvZyBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlc3VsdFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3JcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdGF0dXNcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1c1xuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgc2lnbmF0dXJlIHdpdGggaXRzIHN0YXR1c1xuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGRlZmluaW5nIGhlYWRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBSUEMgc2VydmVyXG4gKi9cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgSmF2YVNjcmlwdCBgZmV0Y2goKWAgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIHVzZWQgdG8gYXVnbWVudCB0aGUgb3V0Z29pbmcgSFRUUCByZXF1ZXN0XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgQ29ubmVjdGlvblxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IENPTU1PTl9IVFRQX0hFQURFUlMgPSB7XG4gICdzb2xhbmEtY2xpZW50JzogYGpzLyR7XCIxLjAuMC1tYWludGVuYW5jZVwifWBcbn07XG5cbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGEgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiB7XG4gIC8qKlxuICAgKiBFc3RhYmxpc2ggYSBKU09OIFJQQyBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbmRwb2ludCBVUkwgdG8gdGhlIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gICAqIEBwYXJhbSBjb21taXRtZW50T3JDb25maWcgb3B0aW9uYWwgZGVmYXVsdCBjb21taXRtZW50IGxldmVsIG9yIG9wdGlvbmFsIENvbm5lY3Rpb25Db25maWcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVuZHBvaW50LCBfY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbW1pdG1lbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAvKiogQGludGVybmFsXG4gICAgICogQSBudW1iZXIgdGhhdCB3ZSBpbmNyZW1lbnQgZXZlcnkgdGltZSBhbiBhY3RpdmUgY29ubmVjdGlvbiBjbG9zZXMuXG4gICAgICogVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc2FtZSBzb2NrZXQgY29ubmVjdGlvbiB0aGF0IHdhcyBvcGVuXG4gICAgICogd2hlbiBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzIGFjdGl2ZSB3aGVuXG4gICAgICogaXRzIGNvbnRpbnVhdGlvbiBmaXJlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZyA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICBsYXRlc3RCbG9ja2hhc2g6IG51bGwsXG4gICAgICBsYXN0RmV0Y2g6IDAsXG4gICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZUNoYW5nZUNhbGxiYWNrc0J5SGFzaCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2ggPSB7fTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICogQWZ0ZXIgYSBzaWduYXR1cmUgaXMgcHJvY2Vzc2VkLCBSUENzIGF1dG9tYXRpY2FsbHkgZGlzcG9zZSBvZiB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICogd2hldGhlciB0aGUgY2xpZW50IGlzIGRlYWxpbmcgd2l0aCBhIG5vdC15ZXQtcHJvY2Vzc2VkIHNpZ25hdHVyZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgKiBjbGVhciBvdXQgdGhlIHN1YnNjcmlwdGlvbiBsb2NhbGx5IHdpdGhvdXQgdGVsbGluZyB0aGUgc2VydmVyKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvaXNzdWVzLzE4ODkyXG4gICAgICovXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyA9IG5ldyBTZXQoKTtcbiAgICAvKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IG9mIHRoZSBub2RlXG4gICAgICovXG4gICAgdGhpcy5nZXRCbG9ja0hlaWdodCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSB7fTtcbiAgICAgIHJldHVybiBhc3luYyBjb21taXRtZW50T3JDb25maWcgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29tbWl0bWVudCxcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RIYXNoID0gZmFzdFN0YWJsZVN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA9IHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF0gPz8gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tIZWlnaHQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgaGVpZ2h0IGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBsZXQgd3NFbmRwb2ludDtcbiAgICBsZXQgaHR0cEhlYWRlcnM7XG4gICAgbGV0IGZldGNoO1xuICAgIGxldCBmZXRjaE1pZGRsZXdhcmU7XG4gICAgbGV0IGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0O1xuICAgIGxldCBodHRwQWdlbnQ7XG4gICAgaWYgKF9jb21taXRtZW50T3JDb25maWcgJiYgdHlwZW9mIF9jb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9jb21taXRtZW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZztcbiAgICB9IGVsc2UgaWYgKF9jb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmNvbW1pdG1lbnQ7XG4gICAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IF9jb21taXRtZW50T3JDb25maWcuY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQ7XG4gICAgICB3c0VuZHBvaW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZy53c0VuZHBvaW50O1xuICAgICAgaHR0cEhlYWRlcnMgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBIZWFkZXJzO1xuICAgICAgZmV0Y2ggPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoO1xuICAgICAgZmV0Y2hNaWRkbGV3YXJlID0gX2NvbW1pdG1lbnRPckNvbmZpZy5mZXRjaE1pZGRsZXdhcmU7XG4gICAgICBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9IF9jb21taXRtZW50T3JDb25maWcuZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgICBodHRwQWdlbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBBZ2VudDtcbiAgICB9XG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSBhc3NlcnRFbmRwb2ludFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHdzRW5kcG9pbnQgfHwgbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gY3JlYXRlUnBjQ2xpZW50KGVuZHBvaW50LCBodHRwSGVhZGVycywgZmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCk7XG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IGNyZWF0ZVJwY1JlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSBjcmVhdGVScGNCYXRjaFJlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSBuZXcgUnBjV2ViU29ja2V0Q2xpZW50KHRoaXMuX3JwY1dzRW5kcG9pbnQsIHtcbiAgICAgIGF1dG9jb25uZWN0OiBmYWxzZSxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiBJbmZpbml0eVxuICAgIH0pO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignb3BlbicsIHRoaXMuX3dzT25PcGVuLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignZXJyb3InLCB0aGlzLl93c09uRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuX3dzT25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2FjY291bnROb3RpZmljYXRpb24nLCB0aGlzLl93c09uQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Byb2dyYW1Ob3RpZmljYXRpb24nLCB0aGlzLl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblNsb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90c1VwZGF0ZXNOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzaWduYXR1cmVOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncm9vdE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Sb290Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignbG9nc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Mb2dzTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbW1pdG1lbnQgdXNlZCBmb3IgcmVxdWVzdHNcbiAgICovXG4gIGdldCBjb21taXRtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jb21taXRtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBSUEMgZW5kcG9pbnRcbiAgICovXG4gIGdldCBycGNFbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjRW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGJhbGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBiYWxhbmNlIGZvciAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBiYWxhbmNlIG9mIGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlc3RpbWF0ZWQgcHJvZHVjdGlvbiB0aW1lIG9mIGEgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrVGltZShzbG90KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tUaW1lJywgW3Nsb3RdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJsb2NrIHRpbWUgZm9yIHNsb3QgJHtzbG90fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbG93ZXN0IHNsb3QgdGhhdCB0aGUgbm9kZSBoYXMgaW5mb3JtYXRpb24gYWJvdXQgaW4gaXRzIGxlZGdlci5cbiAgICogVGhpcyB2YWx1ZSBtYXkgaW5jcmVhc2Ugb3ZlciB0aW1lIGlmIHRoZSBub2RlIGlzIGNvbmZpZ3VyZWQgdG8gcHVyZ2Ugb2xkZXIgbGVkZ2VyIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1MZWRnZXJTbG90KCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ21pbmltdW1MZWRnZXJTbG90JywgW10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QubnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBtaW5pbXVtIGxlZGdlciBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzbG90IG9mIHRoZSBsb3dlc3QgY29uZmlybWVkIGJsb2NrIHRoYXQgaGFzIG5vdCBiZWVuIHB1cmdlZCBmcm9tIHRoZSBsZWRnZXJcbiAgICovXG4gIGFzeW5jIGdldEZpcnN0QXZhaWxhYmxlQmxvY2soKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBTbG90UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmaXJzdCBhdmFpbGFibGUgYmxvY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3VwcGx5XG4gICAqL1xuICBhc3luYyBnZXRTdXBwbHkoY29uZmlnKSB7XG4gICAgbGV0IGNvbmZpZ0FyZyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICBjb21taXRtZW50OiBjb25maWdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb25maWcpIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3VwcGx5JywgW2NvbmZpZ0FyZ10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFN1cHBseVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN1cHBseSBvZiBhIHRva2VuIG1pbnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuU3VwcGx5KHRva2VuTWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbk1pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlblN1cHBseScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgYSB0b2tlbiBhY2NvdW50XG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkFjY291bnRCYWxhbmNlKHRva2VuQWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuQWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50QmFsYW5jZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudCBiYWxhbmNlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCBfYXJncyA9IFtvd25lckFkZHJlc3MudG9CYXNlNTgoKV07XG4gICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBtaW50OiBmaWx0ZXIubWludC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZDogZmlsdGVyLnByb2dyYW1JZC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhfYXJncywgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88UGFyc2VkQWNjb3VudERhdGE+fT4+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50KSB7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudHNCeU93bmVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnRzIG93bmVkIGJ5IGFjY291bnQgJHtvd25lckFkZHJlc3MudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRMYXJnZXN0QWNjb3VudHMoY29uZmlnKSB7XG4gICAgY29uc3QgYXJnID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IGFyZy5maWx0ZXIgfHwgYXJnLmNvbW1pdG1lbnQgPyBbYXJnXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhcmdlc3RBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCB0b2tlbiBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICogZm9yIGEgZ2l2ZW4gbWludC5cbiAgICovXG4gIGFzeW5jIGdldFRva2VuTGFyZ2VzdEFjY291bnRzKG1pbnRBZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbbWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuTGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIGxhcmdlc3QgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoc3VwZXJzdHJ1Y3QubnVsbGFibGUoUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRJbmZvKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlUGFyc2VkQWNjb3VudHMocHVibGljS2V5cywgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5udWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBmb3IgYWNjb3VudHMgJHtrZXlzfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0LmFycmF5KHN1cGVyc3RydWN0Lm51bGxhYmxlKEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXNcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvKHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVwb2NoIGFjdGl2YXRpb24gaW5mb3JtYXRpb24gZm9yIGEgc3Rha2UgYWNjb3VudCB0aGF0IGhhcyBiZWVuIGRlbGVnYXRlZFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS4xODsgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZUFjdGl2YXRpb24ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcsIGVwb2NoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZUFjdGl2YXRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFN0YWtlQWN0aXZhdGlvblJlc3VsdCkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IFN0YWtlIEFjdGl2YXRpb24gJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlcj59Pj59XG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3Qge1xuICAgICAgZW5jb2RpbmcsXG4gICAgICAuLi5jb25maWdXaXRob3V0RW5jb2RpbmdcbiAgICB9ID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgZW5jb2RpbmcgfHwgJ2Jhc2U2NCcsIHtcbiAgICAgIC4uLmNvbmZpZ1dpdGhvdXRFbmNvZGluZyxcbiAgICAgIC4uLihjb25maWdXaXRob3V0RW5jb2RpbmcuZmlsdGVycyA/IHtcbiAgICAgICAgZmlsdGVyczogYXBwbHlEZWZhdWx0TWVtY21wRW5jb2RpbmdUb0ZpbHRlcnMoY29uZmlnV2l0aG91dEVuY29kaW5nLmZpbHRlcnMpXG4gICAgICB9IDogbnVsbClcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCBiYXNlU2NoZW1hID0gc3VwZXJzdHJ1Y3QuYXJyYXkoS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCk7XG4gICAgY29uc3QgcmVzID0gY29uZmlnV2l0aG91dEVuY29kaW5nLndpdGhDb250ZXh0ID09PSB0cnVlID8gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYmFzZVNjaGVtYSkpIDogc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChiYXNlU2NoZW1hKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSAke3Byb2dyYW1JZC50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbmQgcGFyc2UgYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlciB8IFBhcnNlZEFjY291bnREYXRhPn0+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFByb2dyYW1BY2NvdW50cyhwcm9ncmFtSWQsIGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5hcnJheShLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGFjY291bnRzIG93bmVkIGJ5IHByb2dyYW0gJHtwcm9ncmFtSWQudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgY29uZmlybVRyYW5zYWN0aW9uYCBhbmQgcGFzcyBpbiB7QGxpbmsgVHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uKHN0cmF0ZWd5LCBjb21taXRtZW50KSB7XG4gICAgbGV0IHJhd1NpZ25hdHVyZTtcbiAgICBpZiAodHlwZW9mIHN0cmF0ZWd5ID09ICdzdHJpbmcnKSB7XG4gICAgICByYXdTaWduYXR1cmUgPSBzdHJhdGVneTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uZmlnID0gc3RyYXRlZ3k7XG4gICAgICBpZiAoY29uZmlnLmFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjb25maWcuYWJvcnRTaWduYWwucmVhc29uKTtcbiAgICAgIH1cbiAgICAgIHJhd1NpZ25hdHVyZSA9IGNvbmZpZy5zaWduYXR1cmU7XG4gICAgfVxuICAgIGxldCBkZWNvZGVkU2lnbmF0dXJlO1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkU2lnbmF0dXJlID0gYnM1OF9fZGVmYXVsdC5kZWZhdWx0LmRlY29kZShyYXdTaWduYXR1cmUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBiYXNlNTggZW5jb2RlZDogJyArIHJhd1NpZ25hdHVyZSk7XG4gICAgfVxuICAgIGFzc2VydChkZWNvZGVkU2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsICdzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoJyk7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHNpZ25hdHVyZTogcmF3U2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdsYXN0VmFsaWRCbG9ja0hlaWdodCcgaW4gc3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQ7XG4gICAgbGV0IGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgY29uZmlybWF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdGhpcy5vblNpZ25hdHVyZShzaWduYXR1cmUsIChyZXN1bHQsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29tbWl0bWVudCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCA9PiB7XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHRoaXMuX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2Uoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQsIG5leHRTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUgPT09ICdzdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWU/LmVycikge1xuICAgICAgICAgICAgcmVqZWN0KHZhbHVlLmVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcgfHwgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAnY29uZmlybWVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGV4aGF1c3QgZW51bXMgdG8gZW5zdXJlIGZ1bGwgY292ZXJhZ2VcbiAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0Q29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKSB7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKCk7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihzaWduYXR1cmVTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgY2hlY2tCbG9ja0hlaWdodCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tIZWlnaHQoY29tbWl0bWVudCk7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrSGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChjdXJyZW50QmxvY2tIZWlnaHQgPD0gbGFzdFZhbGlkQmxvY2tIZWlnaHQpIHtcbiAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuQkxPQ0tIRUlHSFRfRVhDRUVERURcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgY3VycmVudE5vbmNlVmFsdWUgPSBub25jZVZhbHVlO1xuICAgICAgbGV0IGxhc3RDaGVja2VkU2xvdCA9IG51bGw7XG4gICAgICBjb25zdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IG5vbmNlQWNjb3VudFxuICAgICAgICAgIH0gPSBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnRQdWJrZXksIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgICBtaW5Db250ZXh0U2xvdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RDaGVja2VkU2xvdCA9IGNvbnRleHQuc2xvdDtcbiAgICAgICAgICByZXR1cm4gbm9uY2VBY2NvdW50Py5ub25jZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgY2FuJ3QgcmVhY2gvcmVhZCB0aGUgbm9uY2VcbiAgICAgICAgICAvLyBhY2NvdW50LCBqdXN0IGtlZXAgdXNpbmcgdGhlIGxhc3Qta25vd24gdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROb25jZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAobm9uY2VWYWx1ZSAhPT0gY3VycmVudE5vbmNlVmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLk5PTkNFX0lOVkFMSUQsXG4gICAgICAgICAgICAgIHNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlOiBsYXN0Q2hlY2tlZFNsb3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBpbmRlZWQgdW5jb25maXJtZWQuXG4gICAgICAgIGxldCBzaWduYXR1cmVTdGF0dXM7XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXR1cy5jb250ZXh0LnNsb3QgPCAob3V0Y29tZS5zbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSA/PyBtaW5Db250ZXh0U2xvdCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDQwMCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmF0dXJlU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYXR1cmVTdGF0dXM/LnZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWl0bWVudEZvclN0YXR1cyA9IGNvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzXG4gICAgICAgICAgfSA9IHNpZ25hdHVyZVN0YXR1cy52YWx1ZTtcbiAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnRGb3JTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAncHJvY2Vzc2VkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEV4aGF1c3RpdmUgc3dpdGNoLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgIChfID0+IHt9KShjb21taXRtZW50Rm9yU3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29udGV4dDogc2lnbmF0dXJlU3RhdHVzLmNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBlcnI6IHNpZ25hdHVyZVN0YXR1cy52YWx1ZS5lcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDYwICogMTAwMDtcbiAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDMwICogMTAwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuVElNRURfT1VULFxuICAgICAgICB0aW1lb3V0TXNcbiAgICAgIH0pLCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3Ioc2lnbmF0dXJlLCBvdXRjb21lLnRpbWVvdXRNcyAvIDEwMDApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRDbHVzdGVyTm9kZXMoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q2x1c3Rlck5vZGVzJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3VwZXJzdHJ1Y3QuYXJyYXkoQ29udGFjdEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY2x1c3RlciBub2RlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFZvdGVBY2NvdW50cyhjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Vm90ZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0Vm90ZUFjY291bnRzKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2b3RlIGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgdGhhdCB0aGUgbm9kZSBpcyBwcm9jZXNzaW5nXG4gICAqL1xuICBhc3luYyBnZXRTbG90KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3QnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IGxlYWRlciBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcihjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5zdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGBsaW1pdGAgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIGBzdGFydFNsb3RgXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFNsb3QgZmV0Y2ggc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gdGhpcyBzbG90XG4gICAqIEBwYXJhbSBsaW1pdCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHRvIHJldHVyblxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcnMoc3RhcnRTbG90LCBsaW1pdCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbc3RhcnRTbG90LCBsaW1pdF07XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcnMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LmFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIHNpZ25hdHVyZVxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXNlcyhbc2lnbmF0dXJlXSwgY29uZmlnKTtcbiAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA9PT0gMSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzZXMgb2YgYSBiYXRjaCBvZiBzaWduYXR1cmVzXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXNlcyhzaWduYXR1cmVzLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbc2lnbmF0dXJlc107XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcGFyYW1zLnB1c2goY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlU3RhdHVzZXMnLCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmUgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uQ291bnQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0Lm51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gY291bnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdG90YWwgY3VycmVuY3kgc3VwcGx5IG9mIHRoZSBjbHVzdGVyIGluIGxhbXBvcnRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjIuOC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0U3VwcGx5fSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxTdXBwbHkoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0U3VwcGx5KHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBleGNsdWRlTm9uQ2lyY3VsYXRpbmdBY2NvdW50c0xpc3Q6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlLnRvdGFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjbHVzdGVyIEluZmxhdGlvbkdvdmVybm9yIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvbkdvdmVybm9yKGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25Hb3Zlcm5vcicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXMgZm9yIGFuIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SZXdhcmQoYWRkcmVzc2VzLCBlcG9jaCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFthZGRyZXNzZXMubWFwKHB1YmtleSA9PiBwdWJrZXkudG9CYXNlNTgoKSldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGVwb2NoOiBlcG9jaCAhPSBudWxsID8gZXBvY2ggOiBjb25maWc/LmVwb2NoXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmV3YXJkJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBpbmZsYXRpb24gcmV3YXJkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzcGVjaWZpYyBpbmZsYXRpb24gdmFsdWVzIGZvciB0aGUgY3VycmVudCBlcG9jaFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uUmF0ZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SYXRlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJhdGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByYXRlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBFcG9jaCBJbmZvIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoSW5mbyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaEluZm8nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaEluZm9ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIGluZm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIFNjaGVkdWxlIHBhcmFtZXRlcnNcbiAgICovXG4gIGFzeW5jIGdldEVwb2NoU2NoZWR1bGUoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBlcG9jaCBzY2hlZHVsZScpO1xuICAgIH1cbiAgICBjb25zdCBlcG9jaFNjaGVkdWxlID0gcmVzLnJlc3VsdDtcbiAgICByZXR1cm4gbmV3IEVwb2NoU2NoZWR1bGUoZXBvY2hTY2hlZHVsZS5zbG90c1BlckVwb2NoLCBlcG9jaFNjaGVkdWxlLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgZXBvY2hTY2hlZHVsZS53YXJtdXAsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxFcG9jaCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbFNsb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PExlYWRlclNjaGVkdWxlPj59XG4gICAqL1xuICBhc3luYyBnZXRMZWFkZXJTY2hlZHVsZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMZWFkZXJTY2hlZHVsZScsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGVhZGVyIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBtaW5pbXVtIGJhbGFuY2UgbmVlZGVkIHRvIGV4ZW1wdCBhbiBhY2NvdW50IG9mIGBkYXRhTGVuZ3RoYFxuICAgKiBzaXplIGZyb20gcmVudFxuICAgKi9cbiAgYXN5bmMgZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGFMZW5ndGgsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtkYXRhTGVuZ3RoXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGZldGNoIG1pbmltdW0gYmFsYW5jZSBmb3IgcmVudCBleGVtcHRpb24nKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pj59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjkuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGJsb2NraGFzaFxuICAgICAgfVxuICAgIH0gPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCk7XG4gICAgY29uc3QgZmVlQ2FsY3VsYXRvciA9IHtcbiAgICAgIGdldCBsYW1wb3J0c1BlclNpZ25hdHVyZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FwYWJpbGl0eSB0byBmZXRjaCBgbGFtcG9ydHNQZXJTaWduYXR1cmVgIHVzaW5nIHRoZSBgZ2V0UmVjZW50QmxvY2toYXNoYCBBUEkgaXMgJyArICdubyBsb25nZXIgb2ZmZXJlZCBieSB0aGUgbmV0d29yay4gVXNlIHRoZSBgZ2V0RmVlRm9yTWVzc2FnZWAgQVBJIHRvIG9idGFpbiB0aGUgZmVlICcgKyAnZm9yIGEgZ2l2ZW4gbWVzc2FnZS4nKTtcbiAgICAgIH0sXG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgYmxvY2toYXNoLFxuICAgICAgICBmZWVDYWxjdWxhdG9yXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCByZWNlbnQgcGVyZm9ybWFuY2Ugc2FtcGxlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PFBlcmZTYW1wbGU+Pn1cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcyhsaW1pdCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcycsIGxpbWl0ID8gW2xpbWl0XSA6IFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBmZWUgY2FsY3VsYXRvciBmb3IgYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuOS4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRGZWVGb3JNZXNzYWdlfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaChibG9ja2hhc2gsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGNhbGN1bGF0b3InKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfSA9IHJlcy5yZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT09IG51bGwgPyB2YWx1ZS5mZWVDYWxjdWxhdG9yIDogbnVsbFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldEZlZUZvck1lc3NhZ2UobWVzc2FnZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IHdpcmVNZXNzYWdlID0gdG9CdWZmZXIobWVzc2FnZS5zZXJpYWxpemUoKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3dpcmVNZXNzYWdlXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RmVlRm9yTWVzc2FnZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0Lm51bGxhYmxlKHN1cGVyc3RydWN0Lm51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBmb3IgbWVzc2FnZScpO1xuICAgIH1cbiAgICBpZiAocmVzLnJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgcHJpb3JpdGl6YXRpb24gZmVlcyBmcm9tIHJlY2VudCBibG9ja3MuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXMoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBjb25maWc/LmxvY2tlZFdyaXRhYmxlQWNjb3VudHM/Lm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgIGNvbnN0IGFyZ3MgPSBhY2NvdW50cz8ubGVuZ3RoID8gW2FjY291bnRzXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHByaW9yaXRpemF0aW9uIGZlZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8e2Jsb2NraGFzaDogQmxvY2toYXNoLCBmZWVDYWxjdWxhdG9yOiBGZWVDYWxjdWxhdG9yfT59XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50QmxvY2toYXNoKGNvbW1pdG1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpO1xuICAgICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICovXG4gIGFzeW5jIGdldExhdGVzdEJsb2NraGFzaChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsYXRlc3QgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRMYXRlc3RCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGxhdGVzdCBibG9ja2hhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgYmxvY2toYXNoIGlzIHN0aWxsIHZhbGlkIG9yIG5vdFxuICAgKi9cbiAgYXN5bmMgaXNCbG9ja2hhc2hWYWxpZChibG9ja2hhc2gsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbYmxvY2toYXNoXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2lzQmxvY2toYXNoVmFsaWQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGRldGVybWluZSBpZiB0aGUgYmxvY2toYXNoIGAnICsgYmxvY2toYXNoICsgJ2BpcyB2YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbm9kZSB2ZXJzaW9uXG4gICAqL1xuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZlcnNpb24nLCBbXSk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChWZXJzaW9uUmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdmVyc2lvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZ2VuZXNpcyBoYXNoXG4gICAqL1xuICBhc3luYyBnZXRHZW5lc2lzSGFzaCgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRHZW5lc2lzSGFzaCcsIFtdKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN1cGVyc3RydWN0LnN0cmluZygpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZ2VuZXNpcyBoYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAqIHNldHRpbmcgdGhlIGBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25gIHByb3BlcnR5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldEJsb2NrKHNsb3QsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWc/LnRyYW5zYWN0aW9uRGV0YWlscykge1xuICAgICAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfSA9IHJlcztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcCgoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSh2ZXJzaW9uLCB0cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmVyc2lvblxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKGUsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIGJsb2NrXG4gICAqL1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRQYXJzZWRCbG9jayhzbG90LCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnPy50cmFuc2FjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgY2FzZSAnYWNjb3VudHMnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gIH1cbiAgLypcbiAgICogUmV0dXJucyByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjdXJyZW50IG9yIHByZXZpb3VzIGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja1Byb2R1Y3Rpb24oY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgbGV0IGV4dHJhO1xuICAgIGxldCBjb21taXRtZW50O1xuICAgIGlmICh0eXBlb2YgY29uZmlnT3JDb21taXRtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29tbWl0bWVudCA9IGNvbmZpZ09yQ29tbWl0bWVudDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZ09yQ29tbWl0bWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb21taXRtZW50OiBjLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9ID0gY29uZmlnT3JDb21taXRtZW50O1xuICAgICAgY29tbWl0bWVudCA9IGM7XG4gICAgICBleHRyYSA9IHJlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBleHRyYSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tQcm9kdWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGluayBUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25zYCB1c2luZyBhXG4gICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICogYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAqIFNpbWlsYXIgdG8ge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gYnV0IHJldHVybnMgYSB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb25SZXNwb25zZX0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zKHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0KGJhdGNoKTtcbiAgICBjb25zdCByZXMgPSB1bnNhZmVSZXMubWFwKHVuc2FmZVJlcyA9PiB7XG4gICAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgIC4uLnJlc3VsdC50cmFuc2FjdGlvbixcbiAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHJlc3VsdC52ZXJzaW9uLCByZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBUcmFuc2FjdGlvbnMgYW5kIHRyYW5zYWN0aW9uIHN0YXR1c2VzIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogZm9yIGEgY29uZmlybWVkIGJsb2NrLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2soc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSh0cmFuc2FjdGlvbi5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmJsb2NrLFxuICAgICAgdHJhbnNhY3Rpb25zOiBibG9jay50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtZXRhXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb24ubWVzc2FnZSwgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcylcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBjb25maXJtZWQgYmxvY2tzIGJldHdlZW4gdHdvIHNsb3RzXG4gICAqL1xuICBhc3luYyBnZXRCbG9ja3Moc3RhcnRTbG90LCBlbmRTbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoZW5kU2xvdCAhPT0gdW5kZWZpbmVkID8gW3N0YXJ0U2xvdCwgZW5kU2xvdF0gOiBbc3RhcnRTbG90XSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdXBlcnN0cnVjdC5hcnJheShzdXBlcnN0cnVjdC5udW1iZXIoKSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9ja3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBibG9jaywgZXhjbHVkaW5nIHJld2FyZHNcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrU2lnbmF0dXJlcyhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgcmV3YXJkczogZmFsc2VcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldEJsb2NrU2lnbmF0dXJlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCbG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBjb25maXJtZWQgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjcuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2tTaWduYXR1cmVzfSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICByZXdhcmRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBjb25maXJtZWQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgTWVzc2FnZShyZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlcyA9IHJlc3VsdC50cmFuc2FjdGlvbi5zaWduYXR1cmVzO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24ucG9wdWxhdGUobWVzc2FnZSwgc2lnbmF0dXJlcylcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFJQQyB2MS43LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBzdXBlcnN0cnVjdC5jcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhbiBhZGRyZXNzXG4gICAqIHdpdGhpbiBhIHNwZWNpZmllZCBzbG90IHJhbmdlLiBNYXggcmFuZ2UgYWxsb3dlZCBpcyAxMCwwMDAgc2xvdHMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgUlBDIHYxLjMuIFBsZWFzZSB1c2Uge0BsaW5rIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBzdGFydFNsb3Qgc3RhcnQgc2xvdCwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSBlbmRTbG90IGVuZCBzbG90LCBpbmNsdXNpdmVcbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIHN0YXJ0U2xvdCwgZW5kU2xvdCkge1xuICAgIGxldCBvcHRpb25zID0ge307XG4gICAgbGV0IGZpcnN0QXZhaWxhYmxlQmxvY2sgPSBhd2FpdCB0aGlzLmdldEZpcnN0QXZhaWxhYmxlQmxvY2soKTtcbiAgICB3aGlsZSAoISgndW50aWwnIGluIG9wdGlvbnMpKSB7XG4gICAgICBzdGFydFNsb3QtLTtcbiAgICAgIGlmIChzdGFydFNsb3QgPD0gMCB8fCBzdGFydFNsb3QgPCBmaXJzdEF2YWlsYWJsZUJsb2NrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhzdGFydFNsb3QsICdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMudW50aWwgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBoaWdoZXN0Q29uZmlybWVkUm9vdCA9IGF3YWl0IHRoaXMuZ2V0U2xvdCgnZmluYWxpemVkJyk7XG4gICAgd2hpbGUgKCEoJ2JlZm9yZScgaW4gb3B0aW9ucykpIHtcbiAgICAgIGVuZFNsb3QrKztcbiAgICAgIGlmIChlbmRTbG90ID4gaGlnaGVzdENvbmZpcm1lZFJvb3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKGVuZFNsb3QpO1xuICAgICAgICBpZiAoYmxvY2suc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb3B0aW9ucy5iZWZvcmUgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29uZmlybWVkU2lnbmF0dXJlSW5mby5tYXAoaW5mbyA9PiBpbmZvLnNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhblxuICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBSUEMgdjEuNy4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRTaWduYXR1cmVzRm9yQWRkcmVzc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgR2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAqIGFkZHJlc3MgYmFja3dhcmRzIGluIHRpbWUgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmF0dXJlIG9yIG1vc3QgcmVjZW50IGNvbmZpcm1lZCBibG9ja1xuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBxdWVyaWVkIGFkZHJlc3NcbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzKGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTaWduYXR1cmVzRm9yQWRkcmVzcycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3NMb29rdXBUYWJsZShhY2NvdW50S2V5LCBjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KGFjY291bnRLZXksIGNvbmZpZyk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gbmV3IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQoe1xuICAgICAgICBrZXk6IGFjY291bnRLZXksXG4gICAgICAgIHN0YXRlOiBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50LmRlc2VyaWFsaXplKGFjY291bnRJbmZvLmRhdGEpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWU6IGFjY291bnRJbmZvXG4gICAgfSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChhY2NvdW50SW5mbyAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBOb25jZUFjY291bnQuZnJvbUFjY291bnREYXRhKGFjY291bnRJbmZvLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlKG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0Tm9uY2VBbmRDb250ZXh0KG5vbmNlQWNjb3VudCwgY29tbWl0bWVudE9yQ29uZmlnKS50aGVuKHggPT4geC52YWx1ZSkuY2F0Y2goZSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgbm9uY2UgZm9yIGFjY291bnQgJyArIG5vbmNlQWNjb3VudC50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYW4gYWxsb2NhdGlvbiBvZiBsYW1wb3J0cyB0byB0aGUgc3BlY2lmaWVkIGFkZHJlc3NcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIExBTVBPUlRTX1BFUl9TT0wgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG4gICAqXG4gICAqIChhc3luYyAoKSA9PiB7XG4gICAqICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFwiaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tXCIsIFwiY29uZmlybWVkXCIpO1xuICAgKiAgIGNvbnN0IG15QWRkcmVzcyA9IG5ldyBQdWJsaWNLZXkoXCIybnIxYkhGVDg2Vzl0R255dm1ZVzR2Y0hLc1FCM3NWUWZuZGRhc3o0a0V4TVwiKTtcbiAgICogICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnJlcXVlc3RBaXJkcm9wKG15QWRkcmVzcywgTEFNUE9SVFNfUEVSX1NPTCk7XG4gICAqICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlKTtcbiAgICogfSkoKTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyByZXF1ZXN0QWlyZHJvcCh0bywgbGFtcG9ydHMpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdyZXF1ZXN0QWlyZHJvcCcsIFt0by50b0Jhc2U1OCgpLCBsYW1wb3J0c10pO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgYWlyZHJvcCB0byAke3RvLnRvQmFzZTU4KCl9IGZhaWxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFzeW5jIF9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKSB7XG4gICAgaWYgKCFkaXNhYmxlQ2FjaGUpIHtcbiAgICAgIC8vIFdhaXQgZm9yIHBvbGxpbmcgdG8gZmluaXNoXG4gICAgICB3aGlsZSAodGhpcy5fcG9sbGluZ0Jsb2NraGFzaCkge1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGltZVNpbmNlRmV0Y2ggPSBEYXRlLm5vdygpIC0gdGhpcy5fYmxvY2toYXNoSW5mby5sYXN0RmV0Y2g7XG4gICAgICBjb25zdCBleHBpcmVkID0gdGltZVNpbmNlRmV0Y2ggPj0gQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVM7XG4gICAgICBpZiAodGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2ggIT09IG51bGwgJiYgIWV4cGlyZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcG9sbE5ld0Jsb2NraGFzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX3BvbGxOZXdCbG9ja2hhc2goKSB7XG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgIGNvbnN0IGNhY2hlZEJsb2NraGFzaCA9IGNhY2hlZExhdGVzdEJsb2NraGFzaCA/IGNhY2hlZExhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2ggOiBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoKCdmaW5hbGl6ZWQnKTtcbiAgICAgICAgaWYgKGNhY2hlZEJsb2NraGFzaCAhPT0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCkge1xuICAgICAgICAgIHRoaXMuX2Jsb2NraGFzaEluZm8gPSB7XG4gICAgICAgICAgICBsYXRlc3RCbG9ja2hhc2gsXG4gICAgICAgICAgICBsYXN0RmV0Y2g6IERhdGUubm93KCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvblNpZ25hdHVyZXM6IFtdLFxuICAgICAgICAgICAgc2ltdWxhdGVkU2lnbmF0dXJlczogW11cbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBsYXRlc3RCbG9ja2hhc2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbGVlcCBmb3IgYXBwcm94aW1hdGVseSBoYWxmIGEgc2xvdFxuICAgICAgICBhd2FpdCBzbGVlcChNU19QRVJfU0xPVCAvIDIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gb2J0YWluIGEgbmV3IGJsb2NraGFzaCBhZnRlciAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHN0YWtlIG1pbmltdW0gZGVsZWdhdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbihjb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnOiBjb25maWdBcmdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZ0FyZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHN1cGVyc3RydWN0Lm51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uYCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2ltdWxhdGVUcmFuc2FjdGlvbn0gd2l0aCB7QGxpbmtcbiAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259IGFuZCB7QGxpbmsgU2ltdWxhdGVUcmFuc2FjdGlvbkNvbmZpZ30gcGFyYW1ldGVyc1xuICAgKi9cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNpbXVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Pck1lc3NhZ2UsIGNvbmZpZ09yU2lnbmVycywgaW5jbHVkZUFjY291bnRzKSB7XG4gICAgaWYgKCdtZXNzYWdlJyBpbiB0cmFuc2FjdGlvbk9yTWVzc2FnZSkge1xuICAgICAgY29uc3QgdmVyc2lvbmVkVHggPSB0cmFuc2FjdGlvbk9yTWVzc2FnZTtcbiAgICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHZlcnNpb25lZFR4LnNlcmlhbGl6ZSgpO1xuICAgICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gYnVmZmVyLkJ1ZmZlci5mcm9tKHdpcmVUcmFuc2FjdGlvbikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25maWcgPSBjb25maWdPclNpZ25lcnMgfHwge307XG4gICAgICBjb25maWcuZW5jb2RpbmcgPSAnYmFzZTY0JztcbiAgICAgIGlmICghKCdjb21taXRtZW50JyBpbiBjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5jb21taXRtZW50ID0gdGhpcy5jb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZ09yU2lnbmVycyAmJiB0eXBlb2YgY29uZmlnT3JTaWduZXJzID09PSAnb2JqZWN0JyAmJiAnaW5uZXJJbnN0cnVjdGlvbnMnIGluIGNvbmZpZ09yU2lnbmVycykge1xuICAgICAgICBjb25maWcuaW5uZXJJbnN0cnVjdGlvbnMgPSBjb25maWdPclNpZ25lcnMuaW5uZXJJbnN0cnVjdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNpbXVsYXRlIHRyYW5zYWN0aW9uOiAnICsgcmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBpZiAodHJhbnNhY3Rpb25Pck1lc3NhZ2UgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikge1xuICAgICAgbGV0IG9yaWdpbmFsVHggPSB0cmFuc2FjdGlvbk9yTWVzc2FnZTtcbiAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IG9yaWdpbmFsVHguZmVlUGF5ZXI7XG4gICAgICB0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMgPSB0cmFuc2FjdGlvbk9yTWVzc2FnZS5pbnN0cnVjdGlvbnM7XG4gICAgICB0cmFuc2FjdGlvbi5ub25jZUluZm8gPSBvcmlnaW5hbFR4Lm5vbmNlSW5mbztcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMgPSBvcmlnaW5hbFR4LnNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb25Pck1lc3NhZ2UpO1xuICAgICAgLy8gSEFDSzogdGhpcyBmdW5jdGlvbiByZWxpZXMgb24gbXV0YXRpbmcgdGhlIHBvcHVsYXRlZCB0cmFuc2FjdGlvblxuICAgICAgdHJhbnNhY3Rpb24uX21lc3NhZ2UgPSB0cmFuc2FjdGlvbi5fanNvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ09yU2lnbmVycyAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvbmZpZ09yU2lnbmVycykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IGNvbmZpZ09yU2lnbmVycztcbiAgICBpZiAodHJhbnNhY3Rpb24ubm9uY2VJbmZvICYmIHNpZ25lcnMpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICBpZiAoIXNpZ25lcnMpIGJyZWFrO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSAmJiAhdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2YgdGhpcyB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gc2VlbiBiZWZvcmUgd2l0aCB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHJlY2VudEJsb2NraGFzaCwgYWxsIGRvbmUuIExldCdzIGJyZWFrXG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdvdWxkIGJlIHRyZWF0ZWQgYXMgZHVwbGljYXRlIChpdHMgZGVyaXZlZCBzaWduYXR1cmVcbiAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgIC8vIFNvLCB3ZSBtdXN0IGZldGNoIGEgbmV3IGJsb2NraGFzaCBmb3IgYSBkaWZmZXJlbnQgc2lnbmF0dXJlIGJ5IGRpc2FibGluZ1xuICAgICAgICAgIC8vIG91ciBjYWNoZSBub3QgdG8gd2FpdCBmb3IgdGhlIGNhY2hlIGV4cGlyYXRpb24gKEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TKS5cbiAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSB0cmFuc2FjdGlvbi5fY29tcGlsZSgpO1xuICAgIGNvbnN0IHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSB3aXJlVHJhbnNhY3Rpb24udG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGVuY29kaW5nOiAnYmFzZTY0JyxcbiAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgaWYgKGluY2x1ZGVBY2NvdW50cykge1xuICAgICAgY29uc3QgYWRkcmVzc2VzID0gKEFycmF5LmlzQXJyYXkoaW5jbHVkZUFjY291bnRzKSA/IGluY2x1ZGVBY2NvdW50cyA6IG1lc3NhZ2Uubm9uUHJvZ3JhbUlkcygpKS5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICAgIGNvbmZpZ1snYWNjb3VudHMnXSA9IHtcbiAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICBhZGRyZXNzZXNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzaWduZXJzKSB7XG4gICAgICBjb25maWcuc2lnVmVyaWZ5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ09yU2lnbmVycyAmJiB0eXBlb2YgY29uZmlnT3JTaWduZXJzID09PSAnb2JqZWN0JyAmJiAnaW5uZXJJbnN0cnVjdGlvbnMnIGluIGNvbmZpZ09yU2lnbmVycykge1xuICAgICAgY29uZmlnLmlubmVySW5zdHJ1Y3Rpb25zID0gY29uZmlnT3JTaWduZXJzLmlubmVySW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncztcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgICBpZiAobG9ncyAmJiBBcnJheS5pc0FycmF5KGxvZ3MpKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2VJbmRlbnQgPSAnXFxuICAgICc7XG4gICAgICAgICAgY29uc3QgbG9nVHJhY2UgPSB0cmFjZUluZGVudCArIGxvZ3Muam9pbih0cmFjZUluZGVudCk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZXJyb3IubWVzc2FnZSwgbG9nVHJhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3Ioe1xuICAgICAgICBhY3Rpb246ICdzaW11bGF0ZScsXG4gICAgICAgIHNpZ25hdHVyZTogJycsXG4gICAgICAgIHRyYW5zYWN0aW9uTWVzc2FnZTogcmVzLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGxvZ3M6IGxvZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2VuZFRyYW5zYWN0aW9ufSB3aXRoIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9ufVxuICAgKi9cblxuICAvKipcbiAgICogU2VuZCBhIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBTaWduIGFuZCBzZW5kIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRSYXdUcmFuc2FjdGlvbih3aXJlVHJhbnNhY3Rpb24sIHNpZ25lcnNPck9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoc2lnbmVyc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBzaWduZXJzT3JPcHRpb25zO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8pIHtcbiAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnNpZ25hdHVyZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIXNpZ25hdHVyZScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyB0cmFuc2FjdGlvbiB3b3VsZCBiZSB0cmVhdGVkIGFzIGR1cGxpY2F0ZSAoaXRzIGRlcml2ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgLy8gbWF0Y2hlZCB0byBvbmUgb2YgYWxyZWFkeSByZWNvcmRlZCBzaWduYXR1cmVzKS5cbiAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAvLyBvdXIgY2FjaGUgbm90IHRvIHdhaXQgZm9yIHRoZSBjYWNoZSBleHBpcmF0aW9uIChCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUykuXG4gICAgICAgICAgZGlzYWJsZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3aXJlVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCBhbmQgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdFxuICAgKi9cbiAgYXN5bmMgc2VuZFJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gdG9CdWZmZXIocmF3VHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkLCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAqIHdpcmUgZm9ybWF0LCBhbmQgZW5jb2RlZCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgICovXG4gIGFzeW5jIHNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnXG4gICAgfTtcbiAgICBjb25zdCBza2lwUHJlZmxpZ2h0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBQcmVmbGlnaHQ7XG4gICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudCA9IHNraXBQcmVmbGlnaHQgPT09IHRydWUgPyAncHJvY2Vzc2VkJyAvLyBGSVhNRSBSZW1vdmUgd2hlbiBodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovYWdhdmUvcHVsbC80ODMgaXMgZGVwbG95ZWQuXG4gICAgOiBvcHRpb25zICYmIG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5tYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1pbkNvbnRleHRTbG90ICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5taW5Db250ZXh0U2xvdCA9IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgfVxuICAgIGlmIChza2lwUHJlZmxpZ2h0KSB7XG4gICAgICBjb25maWcuc2tpcFByZWZsaWdodCA9IHNraXBQcmVmbGlnaHQ7XG4gICAgfVxuICAgIGlmIChwcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICBjb25maWcucHJlZmxpZ2h0Q29tbWl0bWVudCA9IHByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3NlbmRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IHN1cGVyc3RydWN0LmNyZWF0ZSh1bnNhZmVSZXMsIFNlbmRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncyA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKHtcbiAgICAgICAgYWN0aW9uOiBza2lwUHJlZmxpZ2h0ID8gJ3NlbmQnIDogJ3NpbXVsYXRlJyxcbiAgICAgICAgc2lnbmF0dXJlOiAnJyxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiByZXMuZXJyb3IubWVzc2FnZSxcbiAgICAgICAgbG9nczogbG9nc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25PcGVuKCkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgLy8gUGluZyBzZXJ2ZXIgZXZlcnkgNXMgdG8gcHJldmVudCBpZGxlIHRpbWVvdXRzXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5ub3RpZnkoJ3BpbmcnKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfSkoKTtcbiAgICB9LCA1MDAwKTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkVycm9yKGVycikge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuZXJyb3IoJ3dzIGVycm9yOicsIGVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uQ2xvc2UoY29kZSkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAodGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiArIDEpICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMTAwMCkge1xuICAgICAgLy8gZXhwbGljaXQgY2xvc2UsIGNoZWNrIGlmIGFueSBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBtYWRlIHNpbmNlIGNsb3NlXG4gICAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW1wbGljaXQgY2xvc2UsIHByZXBhcmUgc3Vic2NyaXB0aW9ucyBmb3IgYXV0by1yZWNvbm5lY3RcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkuZm9yRWFjaCgoW2hhc2gsIHN1YnNjcmlwdGlvbl0pID0+IHtcbiAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0U3Vic2NyaXB0aW9uKGhhc2gsIG5leHRTdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdPy5zdGF0ZTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0gbmV4dFN1YnNjcmlwdGlvbjtcbiAgICBpZiAocHJldlN0YXRlICE9PSBuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKSB7XG4gICAgICBjb25zdCBzdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UoY2xpZW50U3Vic2NyaXB0aW9uSWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoaGFzaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF0gfHw9IG5ldyBTZXQoKTtcbiAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBzd2FsbG93IGVycm9yIGlmIHNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3Igd2hlbiBjbG9zaW5nIHNvY2tldCBjb25uZWN0aW9uOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldC5jb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIGNvbnN0IGlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uID09PSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIH07XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgLy8gRG9uJ3QgYmUgdGVtcHRlZCB0byBjaGFuZ2UgdGhpcyB0byBgT2JqZWN0LmVudHJpZXNgLiBXZSBjYWxsXG4gICAgLy8gYF91cGRhdGVTdWJzY3JpcHRpb25zYCByZWN1cnNpdmVseSB3aGVuIHByb2Nlc3NpbmcgdGhlIHN0YXRlLFxuICAgIC8vIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgbG9vayB1cCB0aGUgKmN1cnJlbnQqIHZlcnNpb24gb2ZcbiAgICAvLyBlYWNoIHN1YnNjcmlwdGlvbiwgZXZlcnkgdGltZSB3ZSBwcm9jZXNzIGEgaGFzaC5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5tYXAoYXN5bmMgaGFzaCA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoaXMgZW50cnkgaGFzIHNpbmNlIGJlZW4gZGVsZXRlZC4gU2tpcC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBZb3UgY2FuIGVuZCB1cCBoZXJlIHdoZW46XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBhIHN1YnNjcmlwdGlvbiBoYXMgcmVjZW50bHkgdW5zdWJzY3JpYmVkXG4gICAgICAgICAgICAgKiAgIHdpdGhvdXQgaGF2aW5nIG5ldyBjYWxsYmFja3MgYWRkZWQgdG8gaXRcbiAgICAgICAgICAgICAqICAgd2hpbGUgdGhlIHVuc3Vic2NyaWJlIHdhcyBpbiBmbGlnaHQsIG9yXG4gICAgICAgICAgICAgKiAtIHdoZW4gYSBwZW5kaW5nIHN1YnNjcmlwdGlvbiBoYXMgaXRzXG4gICAgICAgICAgICAgKiAgIGxpc3RlbmVycyByZW1vdmVkIGJlZm9yZSBhIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAgKiAgIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCZWluZyB0aGF0IG5vYm9keSBpcyBpbnRlcmVzdGVkIGluIHRoaXNcbiAgICAgICAgICAgICAqIHN1YnNjcmlwdGlvbiBhbnkgbG9uZ2VyLCBkZWxldGUgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdGF0ZSA9PT0gJ3Vuc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc3Vic2NyaXB0aW9uLnNlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgbWV0aG9kXG4gICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1YnNjcmlwdGlvbklkID0gYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0gPSBzdWJzY3JpcHRpb24uY2FsbGJhY2tzO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFJlY2VpdmVkICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gJycgOiAnSlNPTi1SUEMgJ31lcnJvciBjYWxsaW5nIFxcYCR7bWV0aG9kfVxcYGAsIHtcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZWQnOlxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEJ5IHRoZSB0aW1lIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdXAgYSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHNlcnZlciwgdGhlIGNsaWVudCBzdG9wcGVkIGNhcmluZyBhYm91dCBpdC5cbiAgICAgICAgICAgIC8vIFRlYXIgaXQgZG93biBub3cuXG4gICAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVNZXRob2RcbiAgICAgICAgICAgICAgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5oYXMoc2VydmVyU3Vic2NyaXB0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN1YnNjcmlwdGlvbiB0aGF0IGhhcyBiZWVuIGF1dG8tXG4gICAgICAgICAgICAgICAgICogZGlzcG9zZWQgYnkgdGhlIFJQQywgdGhlbiB3ZSBjYW4gc2tpcCB0aGUgUlBDIGNhbGwgdG9cbiAgICAgICAgICAgICAgICAgKiB0ZWFyIGRvd24gdGhlIHN1YnNjcmlwdGlvbiBoZXJlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuZGVsZXRlKHNlcnZlclN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5jYWxsKHVuc3Vic2NyaWJlTWV0aG9kLCBbc2VydmVyU3Vic2NyaXB0aW9uSWRdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7dW5zdWJzY3JpYmVNZXRob2R9IGVycm9yOmAsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzZXJ2ZXJTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2tBcmdzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKFxuICAgICAgICAvLyBJIGZhaWxlZCB0byBmaW5kIGEgd2F5IHRvIGNvbnZpbmNlIFR5cGVTY3JpcHQgdGhhdCBgY2JgIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYFRDYWxsYmFja2Agd2hpY2ggaXMgY2VydGFpbmx5IGNvbXBhdGlibGUgd2l0aCBgUGFyYW1ldGVyczxUQ2FsbGJhY2s+YC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDc2MTVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAuLi5jYWxsYmFja0FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBzdXBlcnN0cnVjdC5jcmVhdGUobm90aWZpY2F0aW9uLCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX21ha2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAvKipcbiAgICogV2hlbiBwcmVwYXJpbmcgYGFyZ3NgIGZvciBhIGNhbGwgdG8gYF9tYWtlU3Vic2NyaXB0aW9uYCwgYmUgc3VyZVxuICAgKiB0byBjYXJlZnVsbHkgYXBwbHkgYSBkZWZhdWx0IGBjb21taXRtZW50YCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiAtIElmIHRoZSB1c2VyIHN1cHBsaWVkIGEgYGNvbW1pdG1lbnRgIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgaWYgdGhlIGBDb25uZWN0aW9uOjpjb21taXRtZW50YCBpcyBzZXQsIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgc2V0IGl0IHRvIHRoZSBSUEMgc2VydmVyIGRlZmF1bHQ6IGBmaW5hbGl6ZWRgLlxuICAgKlxuICAgKiBUaGlzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgdGhlc2UgdHdvIGZ1bmRhbWVudGFsbHlcbiAgICogaWRlbnRpY2FsIHN1YnNjcmlwdGlvbnMgcHJvZHVjZSB0aGUgc2FtZSBpZGVudGlmeWluZyBoYXNoOlxuICAgKlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2l0aG91dCBzcGVjaWZ5aW5nIGEgY29tbWl0bWVudC5cbiAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdoZXJlIHRoZSBjb21taXRtZW50IHNwZWNpZmllZCBpcyB0aGUgc2FtZVxuICAgKiAgIGFzIHRoZSBkZWZhdWx0IGFwcGxpZWQgdG8gdGhlIHN1YnNjcmlwdGlvbiBhYm92ZS5cbiAgICpcbiAgICogRXhhbXBsZTsgdGhlc2UgdHdvIHN1YnNjcmlwdGlvbnMgbXVzdCBwcm9kdWNlIHRoZSBzYW1lIGhhc2g6XG4gICAqXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYFxuICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2Agd2l0aCBjb21taXRtZW50XG4gICAqICAgYCdmaW5hbGl6ZWQnYC5cbiAgICpcbiAgICogU2VlIHRoZSAnbWFraW5nIGEgc3Vic2NyaXB0aW9uIHdpdGggZGVmYXVsdGVkIHBhcmFtcyBvbWl0dGVkJyB0ZXN0XG4gICAqIGluIGBjb25uZWN0aW9uLXN1YnNjcmlwdGlvbnMudHNgIGZvciBtb3JlLlxuICAgKi9cbiAgYXJncykge1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkKys7XG4gICAgY29uc3QgaGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkoW3N1YnNjcmlwdGlvbkNvbmZpZy5tZXRob2QsIGFyZ3NdKTtcbiAgICBjb25zdCBleGlzdGluZ1N1YnNjcmlwdGlvbiA9IHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF0gPSB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbkNvbmZpZyxcbiAgICAgICAgYXJncyxcbiAgICAgICAgY2FsbGJhY2tzOiBuZXcgU2V0KFtzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2tdKSxcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmdTdWJzY3JpcHRpb24uY2FsbGJhY2tzLmFkZChzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2spO1xuICAgIH1cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSBoYXNoO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICBkZWxldGUgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdO1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICAgIGFzc2VydChzdWJzY3JpcHRpb24gIT09IHVuZGVmaW5lZCwgYENvdWxkIG5vdCBmaW5kIGEgXFxgU3Vic2NyaXB0aW9uXFxgIHdoZW4gdGVhcmluZyBkb3duIGNsaWVudCBzdWJzY3JpcHRpb24gIyR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9YCk7XG4gICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2tzLmRlbGV0ZShzdWJzY3JpcHRpb25Db25maWcuY2FsbGJhY2spO1xuICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgdGhlIHNwZWNpZmllZCBhY2NvdW50IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIHB1YmxpY0tleSBQdWJsaWMga2V5IG9mIHRoZSBhY2NvdW50IHRvIG1vbml0b3JcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgYWNjb3VudCBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSBjb25maWdcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG5cbiAgLyoqIEBkZXByZWNhdGVkIEluc3RlYWQsIHBhc3MgaW4gYW4ge0BsaW5rIEFjY291bnRTdWJzY3JpcHRpb25Db25maWd9ICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIG9uQWNjb3VudENoYW5nZShwdWJsaWNLZXksIGNhbGxiYWNrLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdhY2NvdW50U3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnYWNjb3VudFVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKG5vdGlmaWNhdGlvbiwgUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFt7XG4gICAgICBhY2NvdW50SWQ6IHJlc3VsdC52YWx1ZS5wdWJrZXksXG4gICAgICBhY2NvdW50SW5mbzogcmVzdWx0LnZhbHVlLmFjY291bnRcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciBhY2NvdW50cyBvd25lZCBieSB0aGVcbiAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAqXG4gICAqIEBwYXJhbSBwcm9ncmFtSWQgUHVibGljIGtleSBvZiB0aGUgcHJvZ3JhbSB0byBtb25pdG9yXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBwYXNzIGluIGEge0BsaW5rIFByb2dyYW1BY2NvdW50U3Vic2NyaXB0aW9uQ29uZmlnfSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBvblByb2dyYW1BY2NvdW50Q2hhbmdlKHByb2dyYW1JZCwgY2FsbGJhY2ssIGNvbW1pdG1lbnRPckNvbmZpZywgbWF5YmVGaWx0ZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyxcbiAgICAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICdiYXNlNjQnIC8qIGVuY29kaW5nICovLCBjb25maWcgPyBjb25maWcgOiBtYXliZUZpbHRlcnMgPyB7XG4gICAgICBmaWx0ZXJzOiBhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyhtYXliZUZpbHRlcnMpXG4gICAgfSA6IHVuZGVmaW5lZCAvKiBleHRyYSAqLyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdwcm9ncmFtU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncHJvZ3JhbVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncHJvZ3JhbSBhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgbG9ncyBhcmUgZW1pdHRlZC5cbiAgICovXG4gIG9uTG9ncyhmaWx0ZXIsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyB7XG4gICAgICBtZW50aW9uczogW2ZpbHRlci50b1N0cmluZygpXVxuICAgIH0gOiBmaWx0ZXJdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnbG9nc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2xvZ3NVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgbG9ncyBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3Rlci5cbiAgICovXG4gIGFzeW5jIHJlbW92ZU9uTG9nc0xpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdsb2dzJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkxvZ3NOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IHN1cGVyc3RydWN0LmNyZWF0ZShub3RpZmljYXRpb24sIExvZ3NOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNsb3ROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IHN1cGVyc3RydWN0LmNyZWF0ZShub3RpZmljYXRpb24sIFNsb3ROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCBjaGFuZ2VzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90VW5zdWJzY3JpYmUnXG4gICAgfSwgW10gLyogYXJncyAqLyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IHN1cGVyc3RydWN0LmNyZWF0ZShub3RpZmljYXRpb24sIFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IHVwZGF0ZXMuIHtAbGluayBTbG90VXBkYXRlfSdzXG4gICAqIG1heSBiZSB1c2VmdWwgdG8gdHJhY2sgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHNsb3QgdXBkYXRlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TbG90VXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdzbG90c1VwZGF0ZXNTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90c1VwZGF0ZXNVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCB1cGRhdGUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCB1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgYXN5bmMgX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCBzdWJzY3JpcHRpb25OYW1lKSB7XG4gICAgY29uc3QgZGlzcG9zZSA9IHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoZGlzcG9zZSkge1xuICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0lnbm9yZWQgdW5zdWJzY3JpYmUgcmVxdWVzdCBiZWNhdXNlIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gd2l0aCBpZCAnICsgYFxcYCR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9XFxgIGZvciAnJHtzdWJzY3JpcHRpb25OYW1lfScgZXZlbnRzIGAgKyAnY291bGQgbm90IGJlIGZvdW5kLicpO1xuICAgIH1cbiAgfVxuICBfYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCB8fCBlbmNvZGluZyB8fCBleHRyYSkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICBvcHRpb25zLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWl0bWVudCkge1xuICAgICAgICBvcHRpb25zLmNvbW1pdG1lbnQgPSBjb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGV4dHJhKTtcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKSB7XG4gICAgY29uc3QgY29tbWl0bWVudCA9IG92ZXJyaWRlIHx8IHRoaXMuX2NvbW1pdG1lbnQ7XG4gICAgaWYgKGNvbW1pdG1lbnQgJiYgIVsnY29uZmlybWVkJywgJ2ZpbmFsaXplZCddLmluY2x1ZGVzKGNvbW1pdG1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIENvbm5lY3Rpb24gd2l0aCBkZWZhdWx0IGNvbW1pdG1lbnQ6IGAnICsgdGhpcy5fY29tbWl0bWVudCArICdgLCBidXQgbWV0aG9kIHJlcXVpcmVzIGF0IGxlYXN0IGBjb25maXJtZWRgJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAncmVjZWl2ZWRTaWduYXR1cmUnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICAgKiBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBkaXNwb3NlZCBpbiBzdWNoIGEgd2F5LCBzbyB0aGF0IHdlIGtub3dcbiAgICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAgICogYWxyZWFkeS1wcm9jZXNzZWQgc2lnbmF0dXJlIChpbiB3aGljaCBjYXNlIHRoZSBjbGllbnQgY2FuIHNpbXBseVxuICAgICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICAgKlxuICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICovXG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIHJlc3VsdC52YWx1ZSA9PT0gJ3JlY2VpdmVkU2lnbmF0dXJlJyA/IFt7XG4gICAgICB0eXBlOiAncmVjZWl2ZWQnXG4gICAgfSwgcmVzdWx0LmNvbnRleHRdIDogW3tcbiAgICAgIHR5cGU6ICdzdGF0dXMnLFxuICAgICAgcmVzdWx0OiByZXN1bHQudmFsdWVcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNpZ25hdHVyZSB1cGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZShzaWduYXR1cmUsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGNhbGxiYWNrKG5vdGlmaWNhdGlvbi5yZXN1bHQsIGNvbnRleHQpO1xuICAgICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhIHRyYW5zYWN0aW9uIGlzXG4gICAqIHJlY2VpdmVkIGFuZC9vciBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgRW5hYmxlIHJlY2VpdmVkIG5vdGlmaWNhdGlvbnMgYW5kIHNldCB0aGUgY29tbWl0bWVudFxuICAgKiAgIGxldmVsIHRoYXQgc2lnbmF0dXJlIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TaWduYXR1cmVXaXRoT3B0aW9ucyhzaWduYXR1cmUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIC4uLmV4dHJhXG4gICAgfSA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjb21taXRtZW50OiBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGV4dHJhKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2Q6ICdzaWduYXR1cmVTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNpZ25hdHVyZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3NpZ25hdHVyZSByZXN1bHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUm9vdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gc3VwZXJzdHJ1Y3QuY3JlYXRlKG5vdGlmaWNhdGlvbiwgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHJvb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSByb290IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uUm9vdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAncm9vdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Jvb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcm9vdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdyb290IGNoYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogS2V5cGFpciBzaWduZXIgaW50ZXJmYWNlXG4gKi9cblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleXBhaXIgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIEtleXBhaXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGtleXBhaXIgaW5zdGFuY2UuXG4gICAqIEdlbmVyYXRlIHJhbmRvbSBrZXlwYWlyIGlmIG5vIHtAbGluayBFZDI1NTE5S2V5cGFpcn0gaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWQyNTUxOUtleXBhaXJ9IGtleXBhaXIgZWQyNTUxOSBrZXlwYWlyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXlwYWlyKSB7XG4gICAgdGhpcy5fa2V5cGFpciA9IHZvaWQgMDtcbiAgICB0aGlzLl9rZXlwYWlyID0ga2V5cGFpciA/PyBnZW5lcmF0ZUtleXBhaXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiBuZXcgS2V5cGFpcihnZW5lcmF0ZUtleXBhaXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcmF3IHNlY3JldCBrZXkgYnl0ZSBhcnJheS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byByZWNyZWF0ZSBhIGtleXBhaXIgZnJvbSBhIHByZXZpb3VzbHlcbiAgICogZ2VuZXJhdGVkIHNlY3JldCBrZXkuIEdlbmVyYXRpbmcga2V5cGFpcnMgZnJvbSBhIHJhbmRvbSBzZWVkIHNob3VsZCBiZSBkb25lXG4gICAqIHdpdGggdGhlIHtAbGluayBLZXlwYWlyLmZyb21TZWVkfSBtZXRob2QuXG4gICAqXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgdGhlIHByb3ZpZGVkIHNlY3JldCBrZXkgaXMgaW52YWxpZCBhbmQgdmFsaWRhdGlvbiBpcyBub3Qgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBzZWNyZXQga2V5IGJ5dGUgYXJyYXlcbiAgICogQHBhcmFtIG9wdGlvbnMgc2tpcCBzZWNyZXQga2V5IHZhbGlkYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VjcmV0S2V5KHNlY3JldEtleSwgb3B0aW9ucykge1xuICAgIGlmIChzZWNyZXRLZXkuYnl0ZUxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNyZXRLZXkuc2xpY2UoMzIsIDY0KTtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpO1xuICAgICAgY29uc3QgY29tcHV0ZWRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgMzI7IGlpKyspIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleVtpaV0gIT09IGNvbXB1dGVkUHVibGljS2V5W2lpXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdmlkZWQgc2VjcmV0S2V5IGlzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXlwYWlyIGZyb20gYSAzMiBieXRlIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkIHNlZWQgYnl0ZSBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoc2VlZCk7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHNlY3JldEtleS5zZXQoc2VlZCk7XG4gICAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHVibGljS2V5fSBQdWJsaWNLZXlcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fa2V5cGFpci5wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByYXcgc2VjcmV0IGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBTZWNyZXQga2V5IGluIGFuIGFycmF5IG9mIFVpbnQ4IGJ5dGVzXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLl9rZXlwYWlyLnNlY3JldEtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBMb29rdXBUYWJsZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdyZWNlbnRTbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdidW1wU2VlZCcpXSlcbiAgfSxcbiAgRnJlZXplTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgRXh0ZW5kTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc2VxKHB1YmxpY0tleSgpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5vZmZzZXQoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCksIC04KSwgJ2FkZHJlc3NlcycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIENsb3NlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfVxufSk7XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2xheW91dFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBsYXlvdXRUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5zdHJ1Y3Rpb24uIFNob3VsZCBiZSBhIExvb2t1cFRhYmxlIEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICByZWNlbnRTbG90XG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICByZWNlbnRTbG90OiBOdW1iZXIocmVjZW50U2xvdClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVFeHRlbmRMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7aW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IDJgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAyID8gaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYnVmZmVyID0+IG5ldyBQdWJsaWNLZXkoYnVmZmVyKSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDbG9zZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcmVjaXBpZW50OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgQWRkcmVzc0xvb2t1cFRhYmxlIFByb2dyYW0nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5c0xlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgY3JlYXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgW2xvb2t1cFRhYmxlQWRkcmVzcywgYnVtcFNlZWRdID0gUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoW3BhcmFtcy5hdXRob3JpdHkudG9CdWZmZXIoKSwgYmlnaW50QnVmZmVyLnRvQnVmZmVyTEUoQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSwgOCldLCB0aGlzLnByb2dyYW1JZCk7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIHJlY2VudFNsb3Q6IEJpZ0ludChwYXJhbXMucmVjZW50U2xvdCksXG4gICAgICBidW1wU2VlZDogYnVtcFNlZWRcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogbG9va3VwVGFibGVBZGRyZXNzLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBbbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSksIGxvb2t1cFRhYmxlQWRkcmVzc107XG4gIH1cbiAgc3RhdGljIGZyZWV6ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5GcmVlemVMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGV4dGVuZExvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhZGRyZXNzZXM6IHBhcmFtcy5hZGRyZXNzZXMubWFwKGFkZHIgPT4gYWRkci50b0J5dGVzKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgaWYgKHBhcmFtcy5wYXllcikge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGRlYWN0aXZhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY2xvc2VMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ2xvc2VMb29rdXBUYWJsZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5yZWNpcGllbnQsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG59XG5BZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0FkZHJlc3NMb29rdXBUYWIxZTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBDb21wdXRlIEJ1ZGdldCBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0VW5pdHMoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RVbml0cywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzLFxuICAgICAgYWRkaXRpb25hbEZlZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgaGVhcCBmcmFtZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ5dGVzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBieXRlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgbGltaXQgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IHByaWNlIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0UHJpY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKENvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBDb21wdXRlQnVkZ2V0UHJvZ3JhbScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCB1bml0cyBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaGVhcCBmcmFtZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgbGltaXQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IHByaWNlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldCBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVxdWVzdFVuaXRzOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ3VuaXRzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignYWRkaXRpb25hbEZlZScpXSlcbiAgfSxcbiAgUmVxdWVzdEhlYXBGcmFtZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdieXRlcycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCd1bml0cycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRQcmljZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnaW5zdHJ1Y3Rpb24nKSwgdTY0KCdtaWNyb0xhbXBvcnRzJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNldENvbXB1dGVVbml0TGltaXR9IGFuZC9vciB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRQcmljZX1cbiAgICovXG4gIHN0YXRpYyByZXF1ZXN0VW5pdHMocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcmVxdWVzdEhlYXBGcmFtZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0SGVhcEZyYW1lO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRMaW1pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRQcmljZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG1pY3JvTGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubWljcm9MYW1wb3J0cylcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Db21wdXRlQnVkZ2V0UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdDb21wdXRlQnVkZ2V0MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTJDEgPSA2NDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMkMSA9IDMyO1xuY29uc3QgU0lHTkFUVVJFX0JZVEVTID0gNjQ7XG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ251bVNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3BhZGRpbmcnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdzaWduYXR1cmVPZmZzZXQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNigncHVibGljS2V5T2Zmc2V0JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNigncHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNignbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKV0pO1xuY2xhc3MgRWQyNTUxOVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBlZDI1NTE5IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5IGFuZCBzaWduYXR1cmUuIFRoZVxuICAgKiBwdWJsaWMga2V5IG11c3QgYmUgYSBidWZmZXIgdGhhdCBpcyAzMiBieXRlcyBsb25nLCBhbmQgdGhlIHNpZ25hdHVyZVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIG9mIDY0IGJ5dGVzLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwdWJsaWNLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMkMSwgYFB1YmxpYyBLZXkgbXVzdCBiZSAke1BVQkxJQ19LRVlfQllURVMkMX0gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cHVibGljS2V5Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gU0lHTkFUVVJFX0JZVEVTLCBgU2lnbmF0dXJlIG11c3QgYmUgJHtTSUdOQVRVUkVfQllURVN9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3NpZ25hdHVyZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgcHVibGljS2V5T2Zmc2V0ID0gRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbjtcbiAgICBjb25zdCBzaWduYXR1cmVPZmZzZXQgPSBwdWJsaWNLZXlPZmZzZXQgKyBwdWJsaWNLZXkubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aDtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKG1lc3NhZ2VEYXRhT2Zmc2V0ICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3Rpb25JbmRleCA9PSBudWxsID8gMHhmZmZmIC8vIEFuIGluZGV4IG9mIGB1MTY6Ok1BWGAgbWFrZXMgaXQgZGVmYXVsdCB0byB0aGUgY3VycmVudCBpbnN0cnVjdGlvbi5cbiAgICA6IGluc3RydWN0aW9uSW5kZXg7XG4gICAgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICBwdWJsaWNLZXlPZmZzZXQsXG4gICAgICBwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbmRleFxuICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwocHVibGljS2V5LCBwdWJsaWNLZXlPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHNpZ25hdHVyZSwgc2lnbmF0dXJlT2Zmc2V0KTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChtZXNzYWdlLCBtZXNzYWdlRGF0YU9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiBFZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUyQxLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3ByaXZhdGVLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlwYWlyID0gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5cGFpci5wdWJsaWNLZXkudG9CeXRlcygpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihtZXNzYWdlLCBrZXlwYWlyLnNlY3JldEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5FZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdFZDI1NTE5U2lnVmVyaWZ5MTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IGVjZHNhU2lnbiA9IChtc2dIYXNoLCBwcml2S2V5KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5zZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2S2V5KTtcbiAgcmV0dXJuIFtzaWduYXR1cmUudG9Db21wYWN0UmF3Qnl0ZXMoKSwgc2lnbmF0dXJlLnJlY292ZXJ5XTtcbn07XG5zZWNwMjU2azEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5O1xuY29uc3QgcHVibGljS2V5Q3JlYXRlID0gc2VjcDI1NmsxLnNlY3AyNTZrMS5nZXRQdWJsaWNLZXk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTID0gMzI7XG5jb25zdCBFVEhFUkVVTV9BRERSRVNTX0JZVEVTID0gMjA7XG5jb25zdCBQVUJMSUNfS0VZX0JZVEVTID0gNjQ7XG5jb25zdCBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUgPSAxMTtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51OCgnc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MTYoJ2V0aEFkZHJlc3NPZmZzZXQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2V0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoMjAsICdldGhBZGRyZXNzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLmJsb2IoNjQsICdzaWduYXR1cmUnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ3JlY292ZXJ5SWQnKV0pO1xuY2xhc3MgU2VjcDI1NmsxUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gYWRkcmVzcyBmcm9tIGEgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IGEgNjQgYnl0ZSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXJcbiAgICovXG4gIHN0YXRpYyBwdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMsIGBQdWJsaWMga2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYnVmZmVyLkJ1ZmZlci5mcm9tKHNoYTMua2VjY2FrXzI1Nih0b0J1ZmZlcihwdWJsaWNLZXkpKSkuc2xpY2UoLUVUSEVSRVVNX0FERFJFU1NfQllURVMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNvbnN0cnVjdGluZyBFdGhlcmV1bSBhZGRyZXNzOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5LiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgIGV0aEFkZHJlc3M6IFNlY3AyNTZrMVByb2dyYW0ucHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYW4gRXRoZXJldW0gYWRkcmVzcy4gVGhlIGFkZHJlc3NcbiAgICogbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYSBidWZmZXIgdGhhdCBpcyAyMCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXRoQWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleCA9IDBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGxldCBldGhBZGRyZXNzO1xuICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyYXdBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IGJ1ZmZlci5CdWZmZXIuZnJvbShyYXdBZGRyZXNzLnN1YnN0cigyKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IGJ1ZmZlci5CdWZmZXIuZnJvbShyYXdBZGRyZXNzLCAnaGV4Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV0aEFkZHJlc3MgPSByYXdBZGRyZXNzO1xuICAgIH1cbiAgICBhc3NlcnQoZXRoQWRkcmVzcy5sZW5ndGggPT09IEVUSEVSRVVNX0FERFJFU1NfQllURVMsIGBBZGRyZXNzIG11c3QgYmUgJHtFVEhFUkVVTV9BRERSRVNTX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtldGhBZGRyZXNzLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICBjb25zdCBkYXRhU3RhcnQgPSAxICsgU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFO1xuICAgIGNvbnN0IGV0aEFkZHJlc3NPZmZzZXQgPSBkYXRhU3RhcnQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gZGF0YVN0YXJ0ICsgZXRoQWRkcmVzcy5sZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoICsgMTtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gMTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkRhdGEgPSBidWZmZXIuQnVmZmVyLmFsbG9jKFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbiArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZSh7XG4gICAgICBudW1TaWduYXR1cmVzLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIGV0aEFkZHJlc3NPZmZzZXQsXG4gICAgICBldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgc2lnbmF0dXJlOiB0b0J1ZmZlcihzaWduYXR1cmUpLFxuICAgICAgZXRoQWRkcmVzczogdG9CdWZmZXIoZXRoQWRkcmVzcyksXG4gICAgICByZWNvdmVyeUlkXG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbCh0b0J1ZmZlcihtZXNzYWdlKSwgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXk6IHBrZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHBrZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUywgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cGtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB0b0J1ZmZlcihwa2V5KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSAvKiBpc0NvbXByZXNzZWQgKi8pLnNsaWNlKDEpOyAvLyB0aHJvdyBhd2F5IGxlYWRpbmcgYnl0ZVxuICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBidWZmZXIuQnVmZmVyLmZyb20oc2hhMy5rZWNjYWtfMjU2KHRvQnVmZmVyKG1lc3NhZ2UpKSk7XG4gICAgICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeUlkXSA9IGVjZHNhU2lnbihtZXNzYWdlSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5TZWNwMjU2azFQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0tlY2Nha1NlY3AyNTZrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxudmFyIF9Mb2NrdXA7XG5cbi8qKlxuICogQWRkcmVzcyBvZiB0aGUgc3Rha2UgY29uZmlnIGFjY291bnQgd2hpY2ggY29uZmlndXJlcyB0aGUgcmF0ZVxuICogb2Ygc3Rha2Ugd2FybXVwIGFuZCBjb29sZG93biBhcyB3ZWxsIGFzIHRoZSBzbGFzaGluZyBwZW5hbHR5LlxuICovXG5jb25zdCBTVEFLRV9DT05GSUdfSUQgPSBuZXcgUHVibGljS2V5KCdTdGFrZUNvbmZpZzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBhdXRob3JpdHkgaW5mb1xuICovXG5jbGFzcyBBdXRob3JpemVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBdXRob3JpemVkIG9iamVjdFxuICAgKiBAcGFyYW0gc3Rha2VyIHRoZSBzdGFrZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIHdpdGhkcmF3ZXIgdGhlIHdpdGhkcmF3IGF1dGhvcml0eVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3Rha2VyLCB3aXRoZHJhd2VyKSB7XG4gICAgLyoqIHN0YWtlIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuc3Rha2VyID0gdm9pZCAwO1xuICAgIC8qKiB3aXRoZHJhdyBhdXRob3JpdHkgKi9cbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFrZXIgPSBzdGFrZXI7XG4gICAgdGhpcy53aXRoZHJhd2VyID0gd2l0aGRyYXdlcjtcbiAgfVxufVxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGxvY2t1cCBpbmZvXG4gKi9cbmNsYXNzIExvY2t1cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9ja3VwIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IodW5peFRpbWVzdGFtcCwgZXBvY2gsIGN1c3RvZGlhbikge1xuICAgIC8qKiBVbml4IHRpbWVzdGFtcCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICAvKiogRXBvY2ggb2YgbG9ja3VwIGV4cGlyYXRpb24gKi9cbiAgICB0aGlzLmVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBMb2NrdXAgY3VzdG9kaWFuIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuY3VzdG9kaWFuID0gdm9pZCAwO1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHVuaXhUaW1lc3RhbXA7XG4gICAgdGhpcy5lcG9jaCA9IGVwb2NoO1xuICAgIHRoaXMuY3VzdG9kaWFuID0gY3VzdG9kaWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQsIGluYWN0aXZlIExvY2t1cCB2YWx1ZVxuICAgKi9cbn1cbl9Mb2NrdXAgPSBMb2NrdXA7XG5Mb2NrdXAuZGVmYXVsdCA9IG5ldyBfTG9ja3VwKDAsIDAsIFB1YmxpY0tleS5kZWZhdWx0KTtcbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXMgdXNpbmcgYSBkZXJpdmVkIGtleVxuICovXG4vKipcbiAqIFNwbGl0IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFNwbGl0IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBXaXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIE1lcmdlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFN0YWtlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN0YWtlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgIGNvbnN0IHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgbGV0IHR5cGU7XG4gICAgZm9yIChjb25zdCBbaXhUeXBlLCBsYXlvdXRdIG9mIE9iamVjdC5lbnRyaWVzKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBTdGFrZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQ6IG5ldyBBdXRob3JpemVkKG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZC5zdGFrZXIpLCBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQud2l0aGRyYXdlcikpLFxuICAgICAgbG9ja3VwOiBuZXcgTG9ja3VwKGxvY2t1cC51bml4VGltZXN0YW1wLCBsb2NrdXAuZXBvY2gsIG5ldyBQdWJsaWNLZXkobG9ja3VwLmN1c3RvZGlhbikpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWxlZ2F0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVEZWxlZ2F0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDYpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlbGVnYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzVdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplLXdpdGgtc2VlZCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld0F1dGhvcml6ZWQsXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5QmFzZTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXR5T3duZXIpLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDMpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNwbGl0IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNwbGl0KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuU3BsaXQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIG1lcmdlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU1lcmdlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2UsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzb3VyY2VTdGFrZVB1YktleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDUpIHtcbiAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGRlYWN0aXZhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3Rha2VQcm9ncmFtJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgaWYgKGtleXMubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnN0cnVjdGlvbjsgZm91bmQgJHtrZXlzLmxlbmd0aH0ga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgJHtleHBlY3RlZExlbmd0aH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBTdGFrZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzdGFrZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIGF1dGhvcml6ZWQoKSwgbG9ja3VwKCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBEZWxlZ2F0ZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBTcGxpdDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBEZWFjdGl2YXRlOiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIE1lcmdlOiB7XG4gICAgaW5kZXg6IDcsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpLCBydXN0U3RyaW5nKCdhdXRob3JpdHlTZWVkJyksIHB1YmxpY0tleSgnYXV0aG9yaXR5T3duZXInKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFN0YWtlIGF1dGhvcml6YXRpb24gdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0J3NcbiAqL1xuY29uc3QgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3Rha2UgcHJvZ3JhbVxuICovXG5jbGFzcyBTdGFrZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTdGFrZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uIHRvIGFkZCB0byBhIFN0YWtlIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwOiBtYXliZUxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbG9ja3VwID0gbWF5YmVMb2NrdXAgfHwgTG9ja3VwLmRlZmF1bHQ7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB7XG4gICAgICAgIHN0YWtlcjogdG9CdWZmZXIoYXV0aG9yaXplZC5zdGFrZXIudG9CdWZmZXIoKSksXG4gICAgICAgIHdpdGhkcmF3ZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQud2l0aGRyYXdlci50b0J1ZmZlcigpKVxuICAgICAgfSxcbiAgICAgIGxvY2t1cDoge1xuICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgZXBvY2g6IGxvY2t1cC5lcG9jaCxcbiAgICAgICAgY3VzdG9kaWFuOiB0b0J1ZmZlcihsb2NrdXAuY3VzdG9kaWFuLnRvQnVmZmVyKCkpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHRoZSBTdGFrZSBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgU3Rha2UgdG9rZW5zIHRvIGEgdmFsaWRhdG9yXG4gICAqIFZvdGUgUHVibGljS2V5LiBUaGlzIHRyYW5zYWN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVkZWxlZ2F0ZSBTdGFrZVxuICAgKiB0byBhIG5ldyB2YWxpZGF0b3IgVm90ZSBQdWJsaWNLZXkuXG4gICAqL1xuICBzdGF0aWMgZGVsZWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNUQUtFX0NPTkZJR19JRCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2UsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IHRvQnVmZmVyKGF1dGhvcml0eU93bmVyLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXR5QmFzZSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIHNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgc3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIHNwbGl0KHBhcmFtcyxcbiAgLy8gQ29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIHRoZSBuZXcgc3Rha2UgYWNjb3VudCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAqIGRlcml2ZWQgZnJvbSBhIGJhc2UgcHVibGljIGtleSBhbmQgc2VlZFxuICAgKi9cbiAgc3RhdGljIHNwbGl0V2l0aFNlZWQocGFyYW1zLFxuICAvLyBJZiB0aGlzIHN0YWtlIGFjY291bnQgaXMgbmV3LCBjb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgaXQgaW4gbGFtcG9ydHNcbiAgcmVudEV4ZW1wdFJlc2VydmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICBhY2NvdW50UHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgaWYgKHJlbnRFeGVtcHRSZXNlcnZlICYmIHJlbnRFeGVtcHRSZXNlcnZlID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbih7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IG1lcmdlcyBTdGFrZSBhY2NvdW50cy5cbiAgICovXG4gIHN0YXRpYyBtZXJnZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzb3VyY2VTdGFrZVB1YktleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCB3aXRoZHJhd3MgZGVhY3RpdmF0ZWQgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHRvUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWFjdGl2YXRlcyBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgZGVhY3RpdmF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdTdGFrZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFN0YWtlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtc3Rha2UtcHJvZ3JhbSBTdGFrZVN0YXRlIHN0cnVjdCBhc1xuICogYFN0YWtlU3RhdGVWMjo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtc3Rha2UtcHJvZ3JhbS9sYXRlc3Qvc29sYW5hX3N0YWtlX3Byb2dyYW0vc3Rha2Vfc3RhdGUvZW51bS5TdGFrZVN0YXRlVjIuaHRtbFxuICovXG5TdGFrZVByb2dyYW0uc3BhY2UgPSAyMDA7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xuY2xhc3MgVm90ZUluaXQge1xuICAvKiogWzAsIDEwMF0gKi9cblxuICBjb25zdHJ1Y3Rvcihub2RlUHVia2V5LCBhdXRob3JpemVkVm90ZXIsIGF1dGhvcml6ZWRXaXRoZHJhd2VyLCBjb21taXNzaW9uKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMubm9kZVB1YmtleSA9IG5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSBhdXRob3JpemVkVm90ZXI7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGNvbW1pc3Npb247XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZUFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemVXaXRoU2VlZCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IGZyb20gdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVXBkYXRlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIHZvdGUgYWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gKi9cblxuLyoqXG4gKiBWb3RlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZvdGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBWb3RlSW5zdHJ1Y3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGluaXRpYWxpemUgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbml0aWFsaXplQWNjb3VudChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVJbml0XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5LFxuICAgICAgdm90ZUluaXQ6IG5ldyBWb3RlSW5pdChuZXcgUHVibGljS2V5KHZvdGVJbml0Lm5vZGVQdWJrZXkpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRWb3RlciksIG5ldyBQdWJsaWNLZXkodm90ZUluaXQuYXV0aG9yaXplZFdpdGhkcmF3ZXIpLCB2b3RlSW5pdC5jb21taXNzaW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHtcbiAgICAgICAgaW5kZXg6IHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3M6IHtcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiBuZXcgUHVibGljS2V5KGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkpLFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkOiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH0sXG4gICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgd2l0aGRyYXcgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBsYW1wb3J0cyxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFZvdGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBWb3RlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgVm90ZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuXG5jb25zdCBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZUFjY291bnQ6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlSW5pdCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBBdXRob3JpemVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzKCldKVxuICB9XG59KTtcblxuLyoqXG4gKiBWb3RlQXV0aG9yaXplIHR5cGVcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVBdXRob3JpemF0aW9uIGxheW91dHMuXG4gKi9cbmNvbnN0IFZvdGVBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFZvdGVyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBWb3RlIHByb2dyYW1cbiAqL1xuY2xhc3MgVm90ZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBWb3RlIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIEluaXRpYWxpemUgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBzdGF0aWMgaW5pdGlhbGl6ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplQWNjb3VudDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlSW5pdDoge1xuICAgICAgICBub2RlUHVia2V5OiB0b0J1ZmZlcih2b3RlSW5pdC5ub2RlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBhdXRob3JpemVkVm90ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRWb3Rlci50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IHRvQnVmZmVyKHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyLnRvQnVmZmVyKCkpLFxuICAgICAgICBjb21taXNzaW9uOiB2b3RlSW5pdC5jb21taXNzaW9uXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogbm9kZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemVBY2NvdW50KHtcbiAgICAgIHZvdGVQdWJrZXk6IHBhcmFtcy52b3RlUHVia2V5LFxuICAgICAgbm9kZVB1YmtleTogcGFyYW1zLnZvdGVJbml0Lm5vZGVQdWJrZXksXG4gICAgICB2b3RlSW5pdDogcGFyYW1zLnZvdGVJbml0XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudFxuICAgKiB3aGVyZSB0aGUgY3VycmVudCBWb3RlciBvciBXaXRoZHJhd2VyIGF1dGhvcml0eSBpcyBhIGRlcml2ZWQga2V5LlxuICAgKi9cbiAgc3RhdGljIGF1dGhvcml6ZVdpdGhTZWVkKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5QmFzZVB1YmtleSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXk6IHRvQnVmZmVyKGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHZvdGVBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgd2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdztcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdG8gd2l0aGRyYXcgc2FmZWx5IGZyb20gYSBWb3RlIGFjY291bnQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2FzIGNyZWF0ZWQgYXMgYSBzYWZlZ3VhcmQgZm9yIHZvdGUgYWNjb3VudHMgcnVubmluZyB2YWxpZGF0b3JzLCBgc2FmZVdpdGhkcmF3YFxuICAgKiBjaGVja3MgdGhhdCB0aGUgd2l0aGRyYXcgYW1vdW50IHdpbGwgbm90IGV4Y2VlZCB0aGUgc3BlY2lmaWVkIGJhbGFuY2Ugd2hpbGUgbGVhdmluZyBlbm91Z2ggbGVmdFxuICAgKiB0byBjb3ZlciByZW50LiBJZiB5b3Ugd2lzaCB0byBjbG9zZSB0aGUgdm90ZSBhY2NvdW50IGJ5IHdpdGhkcmF3aW5nIHRoZSBmdWxsIGFtb3VudCwgY2FsbCB0aGVcbiAgICogYHdpdGhkcmF3YCBtZXRob2QgZGlyZWN0bHkuXG4gICAqL1xuICBzdGF0aWMgc2FmZVdpdGhkcmF3KHBhcmFtcywgY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSwgcmVudEV4ZW1wdE1pbmltdW0pIHtcbiAgICBpZiAocGFyYW1zLmxhbXBvcnRzID4gY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSAtIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGhkcmF3IHdpbGwgbGVhdmUgdm90ZSBhY2NvdW50IHdpdGggaW5zdWZmaWNpZW50IGZ1bmRzLicpO1xuICAgIH1cbiAgICByZXR1cm4gVm90ZVByb2dyYW0ud2l0aGRyYXcocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHVwZGF0ZSB0aGUgdmFsaWRhdG9yIGlkZW50aXR5IChub2RlIHB1YmtleSkgb2YgYSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgdXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdm90ZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyUHVia2V5LFxuICAgICAgbm9kZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5VcGRhdGVWYWxpZGF0b3JJZGVudGl0eTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Wb3RlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFZvdGUgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS12b3RlLXByb2dyYW0gVm90ZVN0YXRlIHN0cnVjdCBhc1xuICogYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtdm90ZS1wcm9ncmFtLzEuOS41L3NvbGFuYV92b3RlX3Byb2dyYW0vdm90ZV9zdGF0ZS9zdHJ1Y3QuVm90ZVN0YXRlLmh0bWwjbWV0aG9kLnNpemVfb2ZcbiAqXG4gKiBLRUVQIElOIFNZTkMgV0lUSCBgVm90ZVN0YXRlOjpzaXplX29mKClgIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9hNDc0Y2IyNGI5MjM4ZjVlZGNjOTgyZjY1YzBiMzdkNGExMDQ2ZjdlL3Nkay9wcm9ncmFtL3NyYy92b3RlL3N0YXRlL21vZC5ycyNMMzQwLUwzNDJcbiAqL1xuVm90ZVByb2dyYW0uc3BhY2UgPSAzNzYyO1xuXG5jb25zdCBWQUxJREFUT1JfSU5GT19LRVkgPSBuZXcgUHVibGljS2V5KCdWYTFpZGF0b3IxbmZvMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBJbmZvIHVzZWQgdG8gaWRlbnRpdHkgdmFsaWRhdG9ycy5cbiAqL1xuXG5jb25zdCBJbmZvU3RyaW5nID0gc3VwZXJzdHJ1Y3QudHlwZSh7XG4gIG5hbWU6IHN1cGVyc3RydWN0LnN0cmluZygpLFxuICB3ZWJzaXRlOiBzdXBlcnN0cnVjdC5vcHRpb25hbChzdXBlcnN0cnVjdC5zdHJpbmcoKSksXG4gIGRldGFpbHM6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LnN0cmluZygpKSxcbiAgaWNvblVybDogc3VwZXJzdHJ1Y3Qub3B0aW9uYWwoc3VwZXJzdHJ1Y3Quc3RyaW5nKCkpLFxuICBrZXliYXNlVXNlcm5hbWU6IHN1cGVyc3RydWN0Lm9wdGlvbmFsKHN1cGVyc3RydWN0LnN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVmFsaWRhdG9ySW5mbyBjbGFzc1xuICovXG5jbGFzcyBWYWxpZGF0b3JJbmZvIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIHZhbGlkIFZhbGlkYXRvckluZm9cbiAgICpcbiAgICogQHBhcmFtIGtleSB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgKiBAcGFyYW0gaW5mbyB2YWxpZGF0b3IgaW5mb3JtYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGtleSwgaW5mbykge1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBwdWJsaWMga2V5XG4gICAgICovXG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVmFsaWRhdG9ySW5mbyBmcm9tIHRoZSBjb25maWcgYWNjb3VudCBkYXRhLiBFeGFjdGx5IHR3byBjb25maWdcbiAgICoga2V5cyBhcmUgcmVxdWlyZWQgaW4gdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgY29uZmlnIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIG51bGwgaWYgaW5mbyB3YXMgbm90IGZvdW5kXG4gICAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZ0RhdGEoYnVmZmVyJDEpIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlciQxXTtcbiAgICBjb25zdCBjb25maWdLZXlDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGlmIChjb25maWdLZXlDb3VudCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29uZmlnS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3QgaXNTaWduZXIgPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSA9PT0gMTtcbiAgICAgIGNvbmZpZ0tleXMucHVzaCh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgaXNTaWduZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgIGlmIChjb25maWdLZXlzWzFdLmlzU2lnbmVyKSB7XG4gICAgICAgIGNvbnN0IHJhd0luZm8gPSBydXN0U3RyaW5nKCkuZGVjb2RlKGJ1ZmZlci5CdWZmZXIuZnJvbShieXRlQXJyYXkpKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UocmF3SW5mbyk7XG4gICAgICAgIHN1cGVyc3RydWN0LmFzc2VydChpbmZvLCBJbmZvU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0b3JJbmZvKGNvbmZpZ0tleXNbMV0ucHVibGljS2V5LCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuY29uc3QgVk9URV9QUk9HUkFNX0lEID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEhpc3Rvcnkgb2YgaG93IG1hbnkgY3JlZGl0cyBlYXJuZWQgYnkgdGhlIGVuZCBvZiBlYWNoIGVwb2NoXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzhhMTJlZDAyOWNmYTM4ZDRhNDU0MDA5MTZjMjQ2M2ZiODJiYmVjOGMvcHJvZ3JhbXMvdm90ZV9hcGkvc3JjL3ZvdGVfc3RhdGUucnMjTDY4LUw4OFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBWb3RlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2NvbW1pc3Npb24nKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnU2NCgpLFxuLy8gdm90ZXMubGVuZ3RoXG5CdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMignY29uZmlybWF0aW9uQ291bnQnKV0pLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5vZmZzZXQoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTMyKCksIC04KSwgJ3ZvdGVzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnU4KCdyb290U2xvdFZhbGlkJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoJ3Jvb3RTbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoKSxcbi8vIGF1dGhvcml6ZWRWb3RlcnMubGVuZ3RoXG5CdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdlcG9jaCcpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRWb3RlcicpXSksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm9mZnNldChCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS51MzIoKSwgLTgpLCAnYXV0aG9yaXplZFZvdGVycycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW0J1ZmZlckxheW91dF9fbmFtZXNwYWNlLnNlcShCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zdHJ1Y3QoW3B1YmxpY0tleSgnYXV0aG9yaXplZFB1YmtleScpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UubnU2NCgndGFyZ2V0RXBvY2gnKV0pLCAzMiwgJ2J1ZicpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdpZHgnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2UudTgoJ2lzRW1wdHknKV0sICdwcmlvclZvdGVycycpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCksXG4vLyBlcG9jaENyZWRpdHMubGVuZ3RoXG5CdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5zZXEoQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdlcG9jaCcpLCBCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdjcmVkaXRzJyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoJ3ByZXZDcmVkaXRzJyldKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uub2Zmc2V0KEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLnUzMigpLCAtOCksICdlcG9jaENyZWRpdHMnKSwgQnVmZmVyTGF5b3V0X19uYW1lc3BhY2Uuc3RydWN0KFtCdWZmZXJMYXlvdXRfX25hbWVzcGFjZS5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dF9fbmFtZXNwYWNlLm51NjQoJ3RpbWVzdGFtcCcpXSwgJ2xhc3RUaW1lc3RhbXAnKV0pO1xuLyoqXG4gKiBWb3RlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBWb3RlQWNjb3VudCB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbW1pc3Npb24gPSB2b2lkIDA7XG4gICAgdGhpcy5yb290U2xvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnZvdGVzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZXBvY2hDcmVkaXRzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZGVQdWJrZXkgPSBhcmdzLm5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGFyZ3MuYXV0aG9yaXplZFdpdGhkcmF3ZXI7XG4gICAgdGhpcy5jb21taXNzaW9uID0gYXJncy5jb21taXNzaW9uO1xuICAgIHRoaXMucm9vdFNsb3QgPSBhcmdzLnJvb3RTbG90O1xuICAgIHRoaXMudm90ZXMgPSBhcmdzLnZvdGVzO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVycyA9IGFyZ3MuYXV0aG9yaXplZFZvdGVycztcbiAgICB0aGlzLnByaW9yVm90ZXJzID0gYXJncy5wcmlvclZvdGVycztcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IGFyZ3MuZXBvY2hDcmVkaXRzO1xuICAgIHRoaXMubGFzdFRpbWVzdGFtcCA9IGFyZ3MubGFzdFRpbWVzdGFtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWb3RlQWNjb3VudCBmcm9tIHRoZSBhY2NvdW50IGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gVm90ZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3QgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgY29uc3QgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgbGV0IHJvb3RTbG90ID0gdmEucm9vdFNsb3Q7XG4gICAgaWYgKCF2YS5yb290U2xvdFZhbGlkKSB7XG4gICAgICByb290U2xvdCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVm90ZUFjY291bnQoe1xuICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiBuZXcgUHVibGljS2V5KHZhLmF1dGhvcml6ZWRXaXRoZHJhd2VyKSxcbiAgICAgIGNvbW1pc3Npb246IHZhLmNvbW1pc3Npb24sXG4gICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICByb290U2xvdCxcbiAgICAgIGF1dGhvcml6ZWRWb3RlcnM6IHZhLmF1dGhvcml6ZWRWb3RlcnMubWFwKHBhcnNlQXV0aG9yaXplZFZvdGVyKSxcbiAgICAgIHByaW9yVm90ZXJzOiBnZXRQcmlvclZvdGVycyh2YS5wcmlvclZvdGVycyksXG4gICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgIGxhc3RUaW1lc3RhbXA6IHZhLmxhc3RUaW1lc3RhbXBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VBdXRob3JpemVkVm90ZXIoe1xuICBhdXRob3JpemVkVm90ZXIsXG4gIGVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoe1xuICBhdXRob3JpemVkUHVia2V5LFxuICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gIHRhcmdldEVwb2NoXG59KSB7XG4gIHJldHVybiB7XG4gICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkUHVia2V5KSxcbiAgICBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFByaW9yVm90ZXJzKHtcbiAgYnVmLFxuICBpZHgsXG4gIGlzRW1wdHlcbn0pIHtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi5idWYuc2xpY2UoaWR4ICsgMSkubWFwKHBhcnNlUHJpb3JWb3RlcnMpLCAuLi5idWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycyldO1xufVxuXG5jb25zdCBlbmRwb2ludCA9IHtcbiAgaHR0cDoge1xuICAgIGRldm5ldDogJ2h0dHA6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfSxcbiAgaHR0cHM6IHtcbiAgICBkZXZuZXQ6ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbScsXG4gICAgJ21haW5uZXQtYmV0YSc6ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH1cbn07XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgUlBDIEFQSSBVUkwgZm9yIHRoZSBzcGVjaWZpZWQgY2x1c3RlclxuICogQHBhcmFtIHtDbHVzdGVyfSBbY2x1c3Rlcj1cImRldm5ldFwiXSAtIFRoZSBjbHVzdGVyIG5hbWUgb2YgdGhlIFJQQyBBUEkgVVJMIHRvIHVzZS4gUG9zc2libGUgb3B0aW9uczogJ2Rldm5ldCcgfCAndGVzdG5ldCcgfCAnbWFpbm5ldC1iZXRhJ1xuICogQHBhcmFtIHtib29sZWFufSBbdGxzPVwiaHR0cFwiXSAtIFVzZSBUTFMgd2hlbiBjb25uZWN0aW5nIHRvIGNsdXN0ZXIuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVVJMIHN0cmluZyBvZiB0aGUgUlBDIGVuZHBvaW50XG4gKi9cbmZ1bmN0aW9uIGNsdXN0ZXJBcGlVcmwoY2x1c3RlciwgdGxzKSB7XG4gIGNvbnN0IGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgY29uc3QgdXJsID0gZW5kcG9pbnRba2V5XVtjbHVzdGVyXTtcbiAgaWYgKCF1cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gJHtrZXl9IGNsdXN0ZXI6ICR7Y2x1c3Rlcn1gKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gIGxldCBjb25maXJtYXRpb25TdHJhdGVneTtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ2xhc3RWYWxpZEJsb2NrSGVpZ2h0JykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIGlmIChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgJ25vbmNlVmFsdWUnKSkge1xuICAgIGNvbmZpcm1hdGlvblN0cmF0ZWd5ID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gIH1cbiAgY29uc3Qgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICBza2lwUHJlZmxpZ2h0OiBvcHRpb25zLnNraXBQcmVmbGlnaHQsXG4gICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICBjb25zdCBjb21taXRtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQ7XG4gIGNvbnN0IGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gIGNvbnN0IHN0YXR1cyA9IChhd2FpdCBjb25maXJtYXRpb25Qcm9taXNlKS52YWx1ZTtcbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICBpZiAoc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcih7XG4gICAgICAgIGFjdGlvbjogc2VuZE9wdGlvbnM/LnNraXBQcmVmbGlnaHQgPyAnc2VuZCcgOiAnc2ltdWxhdGUnLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgdHJhbnNhY3Rpb25NZXNzYWdlOiBgU3RhdHVzOiAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG5jb25zdCBMQU1QT1JUU19QRVJfU09MID0gMTAwMDAwMDAwMDtcblxuZXhwb3J0cy5BY2NvdW50ID0gQWNjb3VudDtcbmV4cG9ydHMuQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCA9IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQ7XG5leHBvcnRzLkFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uID0gQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb247XG5leHBvcnRzLkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0gPSBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtO1xuZXhwb3J0cy5BdXRob3JpemVkID0gQXV0aG9yaXplZDtcbmV4cG9ydHMuQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMgPSBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUztcbmV4cG9ydHMuQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQgPSBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRDtcbmV4cG9ydHMuQlBGX0xPQURFUl9QUk9HUkFNX0lEID0gQlBGX0xPQURFUl9QUk9HUkFNX0lEO1xuZXhwb3J0cy5CcGZMb2FkZXIgPSBCcGZMb2FkZXI7XG5leHBvcnRzLkNPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTO1xuZXhwb3J0cy5Db21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24gPSBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb247XG5leHBvcnRzLkNvbXB1dGVCdWRnZXRQcm9ncmFtID0gQ29tcHV0ZUJ1ZGdldFByb2dyYW07XG5leHBvcnRzLkNvbm5lY3Rpb24gPSBDb25uZWN0aW9uO1xuZXhwb3J0cy5FZDI1NTE5UHJvZ3JhbSA9IEVkMjU1MTlQcm9ncmFtO1xuZXhwb3J0cy5FbnVtID0gRW51bTtcbmV4cG9ydHMuRXBvY2hTY2hlZHVsZSA9IEVwb2NoU2NoZWR1bGU7XG5leHBvcnRzLkZlZUNhbGN1bGF0b3JMYXlvdXQgPSBGZWVDYWxjdWxhdG9yTGF5b3V0O1xuZXhwb3J0cy5LZXlwYWlyID0gS2V5cGFpcjtcbmV4cG9ydHMuTEFNUE9SVFNfUEVSX1NPTCA9IExBTVBPUlRTX1BFUl9TT0w7XG5leHBvcnRzLkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFM7XG5leHBvcnRzLkxvYWRlciA9IExvYWRlcjtcbmV4cG9ydHMuTG9ja3VwID0gTG9ja3VwO1xuZXhwb3J0cy5NQVhfU0VFRF9MRU5HVEggPSBNQVhfU0VFRF9MRU5HVEg7XG5leHBvcnRzLk1lc3NhZ2UgPSBNZXNzYWdlO1xuZXhwb3J0cy5NZXNzYWdlQWNjb3VudEtleXMgPSBNZXNzYWdlQWNjb3VudEtleXM7XG5leHBvcnRzLk1lc3NhZ2VWMCA9IE1lc3NhZ2VWMDtcbmV4cG9ydHMuTk9OQ0VfQUNDT1VOVF9MRU5HVEggPSBOT05DRV9BQ0NPVU5UX0xFTkdUSDtcbmV4cG9ydHMuTm9uY2VBY2NvdW50ID0gTm9uY2VBY2NvdW50O1xuZXhwb3J0cy5QQUNLRVRfREFUQV9TSVpFID0gUEFDS0VUX0RBVEFfU0laRTtcbmV4cG9ydHMuUFVCTElDX0tFWV9MRU5HVEggPSBQVUJMSUNfS0VZX0xFTkdUSDtcbmV4cG9ydHMuUHVibGljS2V5ID0gUHVibGljS2V5O1xuZXhwb3J0cy5TSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUztcbmV4cG9ydHMuU09MQU5BX1NDSEVNQSA9IFNPTEFOQV9TQ0hFTUE7XG5leHBvcnRzLlNUQUtFX0NPTkZJR19JRCA9IFNUQUtFX0NPTkZJR19JRDtcbmV4cG9ydHMuU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFM7XG5leHBvcnRzLlNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFM7XG5leHBvcnRzLlNZU1ZBUl9DTE9DS19QVUJLRVkgPSBTWVNWQVJfQ0xPQ0tfUFVCS0VZO1xuZXhwb3J0cy5TWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZID0gU1lTVkFSX0VQT0NIX1NDSEVEVUxFX1BVQktFWTtcbmV4cG9ydHMuU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkgPSBTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWTtcbmV4cG9ydHMuU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVkgPSBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWTtcbmV4cG9ydHMuU1lTVkFSX1JFTlRfUFVCS0VZID0gU1lTVkFSX1JFTlRfUFVCS0VZO1xuZXhwb3J0cy5TWVNWQVJfUkVXQVJEU19QVUJLRVkgPSBTWVNWQVJfUkVXQVJEU19QVUJLRVk7XG5leHBvcnRzLlNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkgPSBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZO1xuZXhwb3J0cy5TWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSA9IFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZO1xuZXhwb3J0cy5TWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkgPSBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVk7XG5leHBvcnRzLlNlY3AyNTZrMVByb2dyYW0gPSBTZWNwMjU2azFQcm9ncmFtO1xuZXhwb3J0cy5TZW5kVHJhbnNhY3Rpb25FcnJvciA9IFNlbmRUcmFuc2FjdGlvbkVycm9yO1xuZXhwb3J0cy5Tb2xhbmFKU09OUlBDRXJyb3IgPSBTb2xhbmFKU09OUlBDRXJyb3I7XG5leHBvcnRzLlNvbGFuYUpTT05SUENFcnJvckNvZGUgPSBTb2xhbmFKU09OUlBDRXJyb3JDb2RlO1xuZXhwb3J0cy5TdGFrZUF1dGhvcml6YXRpb25MYXlvdXQgPSBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQ7XG5leHBvcnRzLlN0YWtlSW5zdHJ1Y3Rpb24gPSBTdGFrZUluc3RydWN0aW9uO1xuZXhwb3J0cy5TdGFrZVByb2dyYW0gPSBTdGFrZVByb2dyYW07XG5leHBvcnRzLlN0cnVjdCA9IFN0cnVjdDtcbmV4cG9ydHMuU3lzdGVtSW5zdHJ1Y3Rpb24gPSBTeXN0ZW1JbnN0cnVjdGlvbjtcbmV4cG9ydHMuU3lzdGVtUHJvZ3JhbSA9IFN5c3RlbVByb2dyYW07XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG5leHBvcnRzLlRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciA9IFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcjtcbmV4cG9ydHMuVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IgPSBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcjtcbmV4cG9ydHMuVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yID0gVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yO1xuZXhwb3J0cy5UcmFuc2FjdGlvbkluc3RydWN0aW9uID0gVHJhbnNhY3Rpb25JbnN0cnVjdGlvbjtcbmV4cG9ydHMuVHJhbnNhY3Rpb25NZXNzYWdlID0gVHJhbnNhY3Rpb25NZXNzYWdlO1xuZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzO1xuZXhwb3J0cy5WQUxJREFUT1JfSU5GT19LRVkgPSBWQUxJREFUT1JfSU5GT19LRVk7XG5leHBvcnRzLlZFUlNJT05fUFJFRklYX01BU0sgPSBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuZXhwb3J0cy5WT1RFX1BST0dSQU1fSUQgPSBWT1RFX1BST0dSQU1fSUQ7XG5leHBvcnRzLlZhbGlkYXRvckluZm8gPSBWYWxpZGF0b3JJbmZvO1xuZXhwb3J0cy5WZXJzaW9uZWRNZXNzYWdlID0gVmVyc2lvbmVkTWVzc2FnZTtcbmV4cG9ydHMuVmVyc2lvbmVkVHJhbnNhY3Rpb24gPSBWZXJzaW9uZWRUcmFuc2FjdGlvbjtcbmV4cG9ydHMuVm90ZUFjY291bnQgPSBWb3RlQWNjb3VudDtcbmV4cG9ydHMuVm90ZUF1dGhvcml6YXRpb25MYXlvdXQgPSBWb3RlQXV0aG9yaXphdGlvbkxheW91dDtcbmV4cG9ydHMuVm90ZUluaXQgPSBWb3RlSW5pdDtcbmV4cG9ydHMuVm90ZUluc3RydWN0aW9uID0gVm90ZUluc3RydWN0aW9uO1xuZXhwb3J0cy5Wb3RlUHJvZ3JhbSA9IFZvdGVQcm9ncmFtO1xuZXhwb3J0cy5jbHVzdGVyQXBpVXJsID0gY2x1c3RlckFwaVVybDtcbmV4cG9ydHMuc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbiA9IHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb247XG5leHBvcnRzLnNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gPSBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9PYmplY3QkZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicmVxdWlyZSIsIl9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9PYmplY3QkZGVmaW5lUHJvcGVydGllcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9PYmplY3QkY3JlYXRlIiwiX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5IiwiX09iamVjdCRrZXlzIiwiX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfT2JqZWN0JGRlZmluZVByb3BlcnR5IiwiX09iamVjdCRmcmVlemUiLCJfc2xpY2VJbnN0YW5jZVByb3BlcnR5IiwiX09iamVjdCRhc3NpZ24iLCJfbWFwSW5zdGFuY2VQcm9wZXJ0eSIsIl9NYXAiLCJfU3ltYm9sJHRvU3RyaW5nVGFnIiwiX2NvbmNhdEluc3RhbmNlUHJvcGVydHkiLCJfZmxhdEluc3RhbmNlUHJvcGVydHkiLCJfa2V5c0luc3RhbmNlUHJvcGVydHkiLCJfYmluZEluc3RhbmNlUHJvcGVydHkiLCJfQXJyYXkkaXNBcnJheSIsIl9lbnRyaWVzSW5zdGFuY2VQcm9wZXJ0eSIsIl9maWx0ZXJJbnN0YW5jZVByb3BlcnR5IiwiX2ZpbmRJbmRleEluc3RhbmNlUHJvcGVydHkiLCJfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eSIsIl92YWx1ZXNJbnN0YW5jZVByb3BlcnR5IiwiX0FycmF5JGZyb20iLCJfcmVkdWNlSW5zdGFuY2VQcm9wZXJ0eSIsIl9maW5kSW5zdGFuY2VQcm9wZXJ0eSIsIl9maWxsSW5zdGFuY2VQcm9wZXJ0eSIsIl9KU09OJHN0cmluZ2lmeSIsIl9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkiLCJfc29ydEluc3RhbmNlUHJvcGVydHkiLCJfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkiLCJfZXZlcnlJbnN0YW5jZVByb3BlcnR5IiwiX1NldCIsIl9zb21lSW5zdGFuY2VQcm9wZXJ0eSIsIl9Qcm9taXNlIiwiX3NldFRpbWVvdXQiLCJfT2JqZWN0JGVudHJpZXMiLCJfcGFyc2VGbG9hdCIsIl9TeW1ib2wiLCJfcGFyc2VJbnQiLCJfRGF0ZSRub3ciLCJfTnVtYmVyJE1BWF9TQUZFX0lOVEVHRVIiLCJfZ2xvYmFsVGhpcyIsIl9zdGFydHNXaXRoSW5zdGFuY2VQcm9wZXJ0eSIsIl9zZXRJbnRlcnZhbCIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJfZXhjbHVkZWQzIiwiX2V4Y2x1ZGVkNCIsIl9jb250ZXh0MjYiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwibyIsImNhbGwiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsIl9jb250ZXh0ODMiLCJfY29udGV4dDg0IiwiT2JqZWN0IiwiYnVmZmVyIiwiZWQyNTUxOSIsIkJOIiwiYnM1OCIsInNoYTI1NiIsImJvcnNoIiwiQnVmZmVyTGF5b3V0IiwiYmlnaW50QnVmZmVyIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDAkMSIsInJlcXVpcmUkJDAkMiIsInN1cGVyc3RydWN0IiwiUnBjQ2xpZW50Iiwibm9kZUZldGNoIiwicnBjV2Vic29ja2V0cyIsInNoYTMiLCJzZWNwMjU2azEiLCJfaW50ZXJvcERlZmF1bHRDb21wYXQiLCJkZWZhdWx0IiwiX2ludGVyb3BOYW1lc3BhY2VDb21wYXQiLCJuIiwiX2NvbnRleHQiLCJrIiwiZCIsImdldCIsIkJOX19kZWZhdWx0IiwiYnM1OF9fZGVmYXVsdCIsIkJ1ZmZlckxheW91dF9fbmFtZXNwYWNlIiwicmVxdWlyZSQkMF9fZGVmYXVsdCIsInJlcXVpcmUkJDBfX2RlZmF1bHQkMSIsInJlcXVpcmUkJDBfX2RlZmF1bHQkMiIsIlJwY0NsaWVudF9fZGVmYXVsdCIsIm5vZGVGZXRjaF9fbmFtZXNwYWNlIiwiZ2VuZXJhdGVQcml2YXRlS2V5IiwidXRpbHMiLCJyYW5kb21Qcml2YXRlS2V5IiwiZ2VuZXJhdGVLZXlwYWlyIiwicHJpdmF0ZVNjYWxhciIsInB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsInNlY3JldEtleSIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJpc09uQ3VydmUiLCJFeHRlbmRlZFBvaW50IiwiZnJvbUhleCIsInNpZ24iLCJtZXNzYWdlIiwidmVyaWZ5IiwidG9CdWZmZXIiLCJhcnIiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImZyb20iLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIlN0cnVjdCIsImNvbnN0cnVjdG9yIiwicHJvcGVydGllcyIsImVuY29kZSIsInNlcmlhbGl6ZSIsIlNPTEFOQV9TQ0hFTUEiLCJkZWNvZGUiLCJkYXRhIiwiZGVzZXJpYWxpemUiLCJkZWNvZGVVbmNoZWNrZWQiLCJkZXNlcmlhbGl6ZVVuY2hlY2tlZCIsIkVudW0iLCJfY29udGV4dDIiLCJlbnVtIiwiRXJyb3IiLCJrZXkiLCJfUHVibGljS2V5IiwiTUFYX1NFRURfTEVOR1RIIiwiUFVCTElDX0tFWV9MRU5HVEgiLCJpc1B1YmxpY0tleURhdGEiLCJ2YWx1ZSIsIl9ibiIsInVuZGVmaW5lZCIsInVuaXF1ZVB1YmxpY0tleUNvdW50ZXIiLCJQdWJsaWNLZXkiLCJkZWNvZGVkIiwidW5pcXVlIiwiZXF1YWxzIiwiZXEiLCJ0b0Jhc2U1OCIsInRvQnl0ZXMiLCJ0b0pTT04iLCJidWYiLCJiIiwidG9BcnJheUxpa2UiLCJ6ZXJvUGFkIiwiYWxsb2MiLCJjb3B5IiwidG9TdHJpbmciLCJjcmVhdGVXaXRoU2VlZCIsImZyb21QdWJsaWNLZXkiLCJzZWVkIiwicHJvZ3JhbUlkIiwiX2NvbnRleHQzIiwiYnVmZmVyJDEiLCJwdWJsaWNLZXlCeXRlcyIsImNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyIsInNlZWRzIiwiX2NvbnRleHQ1IiwiX2NvbnRleHQ0IiwiVHlwZUVycm9yIiwiY3JlYXRlUHJvZ3JhbUFkZHJlc3MiLCJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jIiwibm9uY2UiLCJhZGRyZXNzIiwic2VlZHNXaXRoTm9uY2UiLCJlcnIiLCJmaW5kUHJvZ3JhbUFkZHJlc3MiLCJwdWJrZXlEYXRhIiwicHVia2V5Iiwia2luZCIsImZpZWxkcyIsIkFjY291bnQiLCJfcHVibGljS2V5IiwiX3NlY3JldEtleSIsInNlY3JldEtleUJ1ZmZlciIsIl9jb250ZXh0NiIsIkJQRl9MT0FERVJfREVQUkVDQVRFRF9QUk9HUkFNX0lEIiwiUEFDS0VUX0RBVEFfU0laRSIsIlZFUlNJT05fUFJFRklYX01BU0siLCJTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTIiwiVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yIiwic2lnbmF0dXJlIiwicHJvdG90eXBlIiwiVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yIiwidGltZW91dFNlY29uZHMiLCJ0b0ZpeGVkIiwiVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IiLCJNZXNzYWdlQWNjb3VudEtleXMiLCJzdGF0aWNBY2NvdW50S2V5cyIsImFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJrZXlTZWdtZW50cyIsIndyaXRhYmxlIiwicmVhZG9ubHkiLCJpbmRleCIsImtleVNlZ21lbnQiLCJfY29udGV4dDciLCJjb21waWxlSW5zdHJ1Y3Rpb25zIiwiaW5zdHJ1Y3Rpb25zIiwiX2NvbnRleHQ4IiwiX2NvbnRleHQ5IiwiVThfTUFYIiwia2V5SW5kZXhNYXAiLCJmaW5kS2V5SW5kZXgiLCJrZXlJbmRleCIsImluc3RydWN0aW9uIiwiX2NvbnRleHQxMCIsInByb2dyYW1JZEluZGV4IiwiYWNjb3VudEtleUluZGV4ZXMiLCJtZXRhIiwicHJvcGVydHkiLCJibG9iIiwicnVzdFN0cmluZyIsIl9jb250ZXh0MTEiLCJfY29udGV4dDEyIiwicnNsIiwic3RydWN0IiwidTMyIiwib2Zmc2V0IiwiX2RlY29kZSIsIl9lbmNvZGUiLCJyc2xTaGltIiwic3RyIiwiY2hhcnMiLCJzcGFuIiwiYXV0aG9yaXplZCIsImxvY2t1cCIsIm5zNjQiLCJ2b3RlSW5pdCIsInU4Iiwidm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyIsImdldEFsbG9jIiwidHlwZSIsIl9jb250ZXh0MTMiLCJnZXRJdGVtQWxsb2MiLCJpdGVtIiwiZmllbGQiLCJlbGVtZW50TGF5b3V0IiwibGF5b3V0IiwiZGVjb2RlTGVuZ3RoIiwiYnl0ZXMiLCJsZW4iLCJzaXplIiwiZWxlbSIsInNoaWZ0IiwiZW5jb2RlTGVuZ3RoIiwicmVtX2xlbiIsImFzc2VydCIsImNvbmRpdGlvbiIsIkNvbXBpbGVkS2V5cyIsInBheWVyIiwia2V5TWV0YU1hcCIsImNvbXBpbGUiLCJnZXRPckluc2VydERlZmF1bHQiLCJrZXlNZXRhIiwiaXNTaWduZXIiLCJpc1dyaXRhYmxlIiwiaXNJbnZva2VkIiwicGF5ZXJLZXlNZXRhIiwiaXgiLCJhY2NvdW50TWV0YSIsImdldE1lc3NhZ2VDb21wb25lbnRzIiwiX2NvbnRleHQxNCIsIm1hcEVudHJpZXMiLCJ3cml0YWJsZVNpZ25lcnMiLCJyZWFkb25seVNpZ25lcnMiLCJ3cml0YWJsZU5vblNpZ25lcnMiLCJyZWFkb25seU5vblNpZ25lcnMiLCJoZWFkZXIiLCJudW1SZXF1aXJlZFNpZ25hdHVyZXMiLCJudW1SZWFkb25seVNpZ25lZEFjY291bnRzIiwibnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzIiwicGF5ZXJBZGRyZXNzIiwiZXh0cmFjdFRhYmxlTG9va3VwIiwibG9va3VwVGFibGUiLCJ3cml0YWJsZUluZGV4ZXMiLCJkcmFpbmVkV3JpdGFibGVLZXlzIiwiZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlIiwic3RhdGUiLCJhZGRyZXNzZXMiLCJyZWFkb25seUluZGV4ZXMiLCJkcmFpbmVkUmVhZG9ubHlLZXlzIiwiYWNjb3VudEtleSIsImxvb2t1cFRhYmxlRW50cmllcyIsImtleU1ldGFGaWx0ZXIiLCJsb29rdXBUYWJsZUluZGV4ZXMiLCJBcnJheSIsImRyYWluZWRLZXlzIiwiX2NvbnRleHQxNSIsImxvb2t1cFRhYmxlSW5kZXgiLCJlbnRyeSIsImRlbGV0ZSIsIkVORF9PRl9CVUZGRVJfRVJST1JfTUVTU0FHRSIsImd1YXJkZWRTaGlmdCIsImJ5dGVBcnJheSIsImd1YXJkZWRTcGxpY2UiLCJhcmdzIiwic3RhcnQiLCJNZXNzYWdlIiwiX2NvbnRleHQxNiIsIl9jb250ZXh0MTciLCJhY2NvdW50S2V5cyIsInJlY2VudEJsb2NraGFzaCIsImluZGV4VG9Qcm9ncmFtSWRzIiwiYWNjb3VudCIsInZlcnNpb24iLCJjb21waWxlZEluc3RydWN0aW9ucyIsIl9jb250ZXh0MTgiLCJhY2NvdW50cyIsImFkZHJlc3NUYWJsZUxvb2t1cHMiLCJnZXRBY2NvdW50S2V5cyIsIl9jb250ZXh0MTkiLCJjb21waWxlZEtleXMiLCJwYXllcktleSIsImlzQWNjb3VudFNpZ25lciIsImlzQWNjb3VudFdyaXRhYmxlIiwibnVtU2lnbmVkQWNjb3VudHMiLCJ1bnNpZ25lZEFjY291bnRJbmRleCIsIm51bVVuc2lnbmVkQWNjb3VudHMiLCJudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMiLCJudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzIiwiaXNQcm9ncmFtSWQiLCJoYXMiLCJwcm9ncmFtSWRzIiwiX2NvbnRleHQyMCIsIm5vblByb2dyYW1JZHMiLCJfY29udGV4dDIxIiwiXyIsIl9jb250ZXh0MjIiLCJfY29udGV4dDIzIiwibnVtS2V5cyIsImtleUNvdW50Iiwia2V5SW5kaWNlc0NvdW50IiwiZGF0YUNvdW50Iiwia2V5SW5kaWNlcyIsImRhdGFMZW5ndGgiLCJpbnN0cnVjdGlvbkNvdW50IiwiaW5zdHJ1Y3Rpb25CdWZmZXIiLCJpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCIsImluc3RydWN0aW9uTGF5b3V0Iiwic2VxIiwic2lnbkRhdGFMYXlvdXQiLCJ0cmFuc2FjdGlvbiIsImtleXMiLCJzaWduRGF0YSIsImFjY291bnRDb3VudCIsImkiLCJkYXRhU2xpY2UiLCJtZXNzYWdlQXJncyIsIk1lc3NhZ2VWMCIsIm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMiLCJjb3VudCIsImxvb2t1cCIsImFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzIiwicmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJudW1TdGF0aWNBY2NvdW50S2V5cyIsIl9jb250ZXh0MjQiLCJsb29rdXBBY2NvdW50S2V5c0luZGV4IiwibnVtV3JpdGFibGVMb29rdXBBY2NvdW50S2V5cyIsInRhYmxlTG9va3VwIiwidGFibGVBY2NvdW50IiwibG9va3VwVGFibGVBY2NvdW50cyIsImV4dHJhY3RSZXN1bHQiLCJhZGRyZXNzVGFibGVMb29rdXAiLCJfY29udGV4dDI1IiwiZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoIiwic2VyaWFsaXplZEluc3RydWN0aW9ucyIsInNlcmlhbGl6ZUluc3RydWN0aW9ucyIsImVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgiLCJzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyIsInNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMiLCJlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCIsIm1lc3NhZ2VMYXlvdXQiLCJzZXJpYWxpemVkTWVzc2FnZSIsIk1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCIsInNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoIiwicHJlZml4Iiwic3RhdGljQWNjb3VudEtleXNMZW5ndGgiLCJpbnN0cnVjdGlvbnNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoIiwic2VyaWFsaXplZExlbmd0aCIsImVuY29kZWRBY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImVuY29kZWREYXRhTGVuZ3RoIiwiZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCIsImVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgiLCJhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQiLCJtYXNrZWRQcmVmaXgiLCJhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCIsImFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCIsIndyaXRhYmxlSW5kZXhlc0xlbmd0aCIsInJlYWRvbmx5SW5kZXhlc0xlbmd0aCIsIlZlcnNpb25lZE1lc3NhZ2UiLCJkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uIiwiVHJhbnNhY3Rpb25TdGF0dXMiLCJERUZBVUxUX1NJR05BVFVSRSIsIlRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24iLCJvcHRzIiwiX2NvbnRleHQyNyIsIlRyYW5zYWN0aW9uIiwic2lnbmF0dXJlcyIsImZlZVBheWVyIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJub25jZUluZm8iLCJtaW5Ob25jZUNvbnRleHRTbG90IiwiX21lc3NhZ2UiLCJfanNvbiIsImhhc093blByb3BlcnR5IiwibWluQ29udGV4dFNsb3QiLCJibG9ja2hhc2giLCJfY29udGV4dDI4IiwiX2NvbnRleHQyOSIsIm5vbmNlSW5zdHJ1Y3Rpb24iLCJzaWduZXJzIiwiYWRkIiwiaXRlbXMiLCJfY29udGV4dDMwIiwiY29tcGlsZU1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImFjY291bnRNZXRhcyIsIl9jb250ZXh0MzEiLCJ1bmlxdWVNZXRhcyIsInB1YmtleVN0cmluZyIsInVuaXF1ZUluZGV4IiwieCIsInkiLCJvcHRpb25zIiwibG9jYWxlTWF0Y2hlciIsInVzYWdlIiwic2Vuc2l0aXZpdHkiLCJpZ25vcmVQdW5jdHVhdGlvbiIsIm51bWVyaWMiLCJjYXNlRmlyc3QiLCJsb2NhbGVDb21wYXJlIiwiZmVlUGF5ZXJJbmRleCIsInBheWVyTWV0YSIsInVuc2hpZnQiLCJzaWduZWRLZXlzIiwidW5zaWduZWRLZXlzIiwiX2NvbnRleHQzMiIsIl9jb250ZXh0MzMiLCJfY29tcGlsZSIsIl9jb250ZXh0MzQiLCJfY29udGV4dDM1IiwidmFsaWQiLCJwYWlyIiwic2VyaWFsaXplTWVzc2FnZSIsImdldEVzdGltYXRlZEZlZSIsImNvbm5lY3Rpb24iLCJnZXRGZWVGb3JNZXNzYWdlIiwic2V0U2lnbmVycyIsIl9jb250ZXh0MzYiLCJzZWVuIiwidW5pcXVlU2lnbmVycyIsInNpZ25lciIsIl9wYXJ0aWFsU2lnbiIsInBhcnRpYWxTaWduIiwiX2FkZFNpZ25hdHVyZSIsImFkZFNpZ25hdHVyZSIsIl9jb250ZXh0MzciLCJzaWdwYWlyIiwidmVyaWZ5U2lnbmF0dXJlcyIsInJlcXVpcmVBbGxTaWduYXR1cmVzIiwic2lnbmF0dXJlRXJyb3JzIiwiX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzIiwiZXJyb3JzIiwibWlzc2luZyIsImludmFsaWQiLCJjb25maWciLCJzaWdFcnJvcnMiLCJlcnJvck1lc3NhZ2UiLCJfY29udGV4dDM4IiwicCIsImpvaW4iLCJfY29udGV4dDM5IiwiX3NlcmlhbGl6ZSIsInNpZ25hdHVyZUNvdW50IiwidHJhbnNhY3Rpb25MZW5ndGgiLCJ3aXJlVHJhbnNhY3Rpb24iLCJfY29udGV4dDQwIiwia2V5T2JqIiwicG9wdWxhdGUiLCJfY29udGV4dDQxIiwic2lnUHVia2V5UGFpciIsIl9jb250ZXh0NDIiLCJfY29udGV4dDQzIiwiVHJhbnNhY3Rpb25NZXNzYWdlIiwiZGVjb21waWxlIiwiY29tcGlsZWRJeCIsImNvbXBpbGVUb0xlZ2FjeU1lc3NhZ2UiLCJjb21waWxlVG9WME1lc3NhZ2UiLCJWZXJzaW9uZWRUcmFuc2FjdGlvbiIsImRlZmF1bHRTaWduYXR1cmVzIiwiZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGgiLCJ0cmFuc2FjdGlvbkxheW91dCIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCIsInNpZ25hdHVyZXNMZW5ndGgiLCJfY29udGV4dDQ0IiwibWVzc2FnZURhdGEiLCJzaWduZXJQdWJrZXlzIiwic2lnbmVySW5kZXgiLCJfY29udGV4dDQ1IiwiTlVNX1RJQ0tTX1BFUl9TRUNPTkQiLCJERUZBVUxUX1RJQ0tTX1BFUl9TTE9UIiwiTlVNX1NMT1RTX1BFUl9TRUNPTkQiLCJNU19QRVJfU0xPVCIsIlNZU1ZBUl9DTE9DS19QVUJLRVkiLCJTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZIiwiU1lTVkFSX0lOU1RSVUNUSU9OU19QVUJLRVkiLCJTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSIsIlNZU1ZBUl9SRU5UX1BVQktFWSIsIlNZU1ZBUl9SRVdBUkRTX1BVQktFWSIsIlNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVkiLCJTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSIsIlNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSIsIlNlbmRUcmFuc2FjdGlvbkVycm9yIiwiYWN0aW9uIiwidHJhbnNhY3Rpb25NZXNzYWdlIiwibG9ncyIsIm1heWJlTG9nc091dHB1dCIsImd1aWRlVGV4dCIsImEiLCJ0cmFuc2FjdGlvbkxvZ3MiLCJ0cmFuc2FjdGlvbkVycm9yIiwiY2FjaGVkTG9ncyIsImdldExvZ3MiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ2V0VHJhbnNhY3Rpb24iLCJ0aGVuIiwidHgiLCJsb2dNZXNzYWdlcyIsImNhdGNoIiwiU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMVVJFIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFkiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fUFJFQ09NUElMRV9WRVJJRklDQVRJT05fRkFJTFVSRSIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1QiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTE9OR19URVJNX1NUT1JBR0VfU0xPVF9TS0lQUEVEIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWCIsIkpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEUiLCJKU09OX1JQQ19TQ0FOX0VSUk9SIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0giLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUIiwiSlNPTl9SUENfU0VSVkVSX0VSUk9SX1VOU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1ZFUlNJT04iLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRCIsIlNvbGFuYUpTT05SUENFcnJvciIsImNvZGUiLCJjdXN0b21NZXNzYWdlIiwibmFtZSIsInNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24iLCJzZW5kT3B0aW9ucyIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwiY29tbWl0bWVudCIsIm1heFJldHJpZXMiLCJzZW5kVHJhbnNhY3Rpb24iLCJzdGF0dXMiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJhYm9ydFNpZ25hbCIsIm5vbmNlQWNjb3VudFB1YmtleSIsIm5vbmNlVmFsdWUiLCJzbGVlcCIsIm1zIiwiZW5jb2RlRGF0YSIsImFsbG9jTGVuZ3RoIiwibGF5b3V0RmllbGRzIiwiZGVjb2RlRGF0YSQxIiwiRmVlQ2FsY3VsYXRvckxheW91dCIsIm51NjQiLCJOb25jZUFjY291bnRMYXlvdXQiLCJOT05DRV9BQ0NPVU5UX0xFTkdUSCIsIk5vbmNlQWNjb3VudCIsImF1dGhvcml6ZWRQdWJrZXkiLCJmZWVDYWxjdWxhdG9yIiwiZnJvbUFjY291bnREYXRhIiwibm9uY2VBY2NvdW50IiwiZW5jb2RlRGVjb2RlIiwiX2NvbnRleHQ0NiIsIl9jb250ZXh0NDciLCJiaWdJbnQiLCJiaWdJbnRMYXlvdXQiLCJzcmMiLCJ0b0JpZ0ludExFIiwidG9CdWZmZXJMRSIsInU2NCIsIlN5c3RlbUluc3RydWN0aW9uIiwiZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlIiwiY2hlY2tQcm9ncmFtSWQiLCJpbnN0cnVjdGlvblR5cGVMYXlvdXQiLCJ0eXBlSW5kZXgiLCJpeFR5cGUiLCJTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUNyZWF0ZUFjY291bnQiLCJjaGVja0tleUxlbmd0aCIsImxhbXBvcnRzIiwic3BhY2UiLCJDcmVhdGUiLCJmcm9tUHVia2V5IiwibmV3QWNjb3VudFB1YmtleSIsImRlY29kZVRyYW5zZmVyIiwiVHJhbnNmZXIiLCJ0b1B1YmtleSIsImRlY29kZVRyYW5zZmVyV2l0aFNlZWQiLCJUcmFuc2ZlcldpdGhTZWVkIiwiYmFzZVB1YmtleSIsImRlY29kZUFsbG9jYXRlIiwiQWxsb2NhdGUiLCJhY2NvdW50UHVia2V5IiwiZGVjb2RlQWxsb2NhdGVXaXRoU2VlZCIsImJhc2UiLCJBbGxvY2F0ZVdpdGhTZWVkIiwiZGVjb2RlQXNzaWduIiwiQXNzaWduIiwiZGVjb2RlQXNzaWduV2l0aFNlZWQiLCJBc3NpZ25XaXRoU2VlZCIsImRlY29kZUNyZWF0ZVdpdGhTZWVkIiwiQ3JlYXRlV2l0aFNlZWQiLCJkZWNvZGVOb25jZUluaXRpYWxpemUiLCJJbml0aWFsaXplTm9uY2VBY2NvdW50Iiwibm9uY2VQdWJrZXkiLCJkZWNvZGVOb25jZUFkdmFuY2UiLCJBZHZhbmNlTm9uY2VBY2NvdW50IiwiZGVjb2RlTm9uY2VXaXRoZHJhdyIsIldpdGhkcmF3Tm9uY2VBY2NvdW50IiwiZGVjb2RlTm9uY2VBdXRob3JpemUiLCJBdXRob3JpemVOb25jZUFjY291bnQiLCJuZXdBdXRob3JpemVkUHVia2V5IiwiU3lzdGVtUHJvZ3JhbSIsImV4cGVjdGVkTGVuZ3RoIiwiVXBncmFkZU5vbmNlQWNjb3VudCIsImNyZWF0ZUFjY291bnQiLCJwYXJhbXMiLCJ0cmFuc2ZlciIsIkJpZ0ludCIsImFzc2lnbiIsImNyZWF0ZUFjY291bnRXaXRoU2VlZCIsImNyZWF0ZU5vbmNlQWNjb3VudCIsImluaXRQYXJhbXMiLCJub25jZUluaXRpYWxpemUiLCJpbnN0cnVjdGlvbkRhdGEiLCJub25jZUFkdmFuY2UiLCJub25jZVdpdGhkcmF3Iiwibm9uY2VBdXRob3JpemUiLCJhbGxvY2F0ZSIsIkNIVU5LX1NJWkUiLCJMb2FkZXIiLCJnZXRNaW5OdW1TaWduYXR1cmVzIiwiTWF0aCIsImNlaWwiLCJjaHVua1NpemUiLCJsb2FkIiwicHJvZ3JhbSIsImJhbGFuY2VOZWVkZWQiLCJnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24iLCJwcm9ncmFtSW5mbyIsImdldEFjY291bnRJbmZvIiwiZXhlY3V0YWJsZSIsImVycm9yIiwib3duZXIiLCJkYXRhTGF5b3V0IiwiYXJyYXkiLCJ0cmFuc2FjdGlvbnMiLCJfY29udGV4dDQ4IiwiYnl0ZXNMZW5ndGgiLCJieXRlc0xlbmd0aFBhZGRpbmciLCJfcnBjRW5kcG9pbnQiLCJSRVFVRVNUU19QRVJfU0VDT05EIiwiYWxsIiwiZGVwbG95Q29tbWl0bWVudCIsImZpbmFsaXplU2lnbmF0dXJlIiwiY29udGV4dCIsImN1cnJlbnRTbG90IiwiZ2V0U2xvdCIsInNsb3QiLCJyb3VuZCIsIkJQRl9MT0FERVJfUFJPR1JBTV9JRCIsIkJwZkxvYWRlciIsImVsZiIsImxvYWRlclByb2dyYW1JZCIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwiX19lc01vZHVsZSIsImFnZW50a2VlcGFsaXZlIiwiZXhwb3J0cyIsImhhc1JlcXVpcmVkTXMiLCJyZXF1aXJlTXMiLCJzIiwibSIsImgiLCJ3IiwidmFsIiwicGFyc2UiLCJpc0Zpbml0ZSIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJTdHJpbmciLCJtYXRjaCIsImV4ZWMiLCJ0b0xvd2VyQ2FzZSIsIm1zQWJzIiwiYWJzIiwicGx1cmFsIiwiaXNQbHVyYWwiLCJodW1hbml6ZU1zIiwiaGFzUmVxdWlyZWRIdW1hbml6ZU1zIiwicmVxdWlyZUh1bWFuaXplTXMiLCJ1dGlsIiwiZm9ybWF0Iiwic3RhY2siLCJjb25zdGFudHMiLCJoYXNSZXF1aXJlZENvbnN0YW50cyIsInJlcXVpcmVDb25zdGFudHMiLCJDVVJSRU5UX0lEIiwiQ1JFQVRFX0lEIiwiSU5JVF9TT0NLRVQiLCJDUkVBVEVfSFRUUFNfQ09OTkVDVElPTiIsIlNPQ0tFVF9DUkVBVEVEX1RJTUUiLCJTT0NLRVRfTkFNRSIsIlNPQ0tFVF9SRVFVRVNUX0NPVU5UIiwiU09DS0VUX1JFUVVFU1RfRklOSVNIRURfQ09VTlQiLCJhZ2VudCIsImhhc1JlcXVpcmVkQWdlbnQiLCJyZXF1aXJlQWdlbnQiLCJPcmlnaW5hbEFnZW50IiwiQWdlbnQiLCJkZWJ1ZyIsImRlYnVnbG9nIiwiZGVmYXVsdFRpbWVvdXRMaXN0ZW5lckNvdW50IiwibWFqb3JWZXJzaW9uIiwicHJvY2VzcyIsInNwbGl0Iiwic3Vic3RyaW5nIiwiZGVwcmVjYXRlIiwibG9nIiwia2VlcEFsaXZlIiwiZnJlZVNvY2tldFRpbWVvdXQiLCJrZWVwQWxpdmVUaW1lb3V0IiwiZnJlZVNvY2tldEtlZXBBbGl2ZVRpbWVvdXQiLCJ0aW1lb3V0IiwibWF4Iiwic29ja2V0QWN0aXZlVFRMIiwiY3JlYXRlU29ja2V0Q291bnQiLCJjcmVhdGVTb2NrZXRDb3VudExhc3RDaGVjayIsImNyZWF0ZVNvY2tldEVycm9yQ291bnQiLCJjcmVhdGVTb2NrZXRFcnJvckNvdW50TGFzdENoZWNrIiwiY2xvc2VTb2NrZXRDb3VudCIsImNsb3NlU29ja2V0Q291bnRMYXN0Q2hlY2siLCJlcnJvclNvY2tldENvdW50IiwiZXJyb3JTb2NrZXRDb3VudExhc3RDaGVjayIsInJlcXVlc3RDb3VudCIsInJlcXVlc3RDb3VudExhc3RDaGVjayIsInRpbWVvdXRTb2NrZXRDb3VudCIsInRpbWVvdXRTb2NrZXRDb3VudExhc3RDaGVjayIsIm9uIiwic29ja2V0IiwiY2FsY1NvY2tldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYWxpdmVUaW1lIiwiZGlmZiIsImN1c3RvbUZyZWVTb2NrZXRUaW1lb3V0Iiwia2VlcFNvY2tldEFsaXZlIiwicmVzdWx0IiwiY3VzdG9tVGltZW91dCIsInJldXNlU29ja2V0IiwicmVxIiwicmV1c2VkU29ja2V0IiwiYWdlbnRUaW1lb3V0IiwiZ2V0U29ja2V0VGltZW91dCIsImlkIiwic2V0Tm9EZWxheSIsIl9hZ2VudEtleSIsImluc3RhbGxMaXN0ZW5lcnMiLCJjcmVhdGVDb25uZWN0aW9uIiwib25jcmVhdGUiLCJjYWxsZWQiLCJvbk5ld0NyZWF0ZSIsIm5ld1NvY2tldCIsInN0YXR1c0NoYW5nZWQiLCJjaGFuZ2VkIiwiZ2V0Q3VycmVudFN0YXR1cyIsImZyZWVTb2NrZXRzIiwiaW5zcGVjdCIsInNvY2tldHMiLCJyZXF1ZXN0cyIsIl9pZGxlVGltZW91dCIsIm9uRnJlZSIsIl9odHRwTWVzc2FnZSIsImdldE5hbWUiLCJvbkNsb3NlIiwiaXNFcnJvciIsIm9uVGltZW91dCIsIl9jb250ZXh0NTAiLCJsaXN0ZW5lckNvdW50IiwibGlzdGVuZXJzIiwicmVxVGltZW91dExpc3RlbmVyQ291bnQiLCJlbmFibGVkIiwiX2NvbnRleHQ0OSIsImYiLCJkZXN0cm95IiwicmVtb3ZlU29ja2V0Iiwib25FcnJvciIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCIsIm9uUmVtb3ZlIiwib2JqIiwicmVzIiwiaHR0cHNfYWdlbnQiLCJoYXNSZXF1aXJlZEh0dHBzX2FnZW50IiwicmVxdWlyZUh0dHBzX2FnZW50IiwiX2NvbnRleHQ1MSIsIk9yaWdpbmFsSHR0cHNBZ2VudCIsIkh0dHBBZ2VudCIsIkh0dHBzQWdlbnQiLCJkZWZhdWx0UG9ydCIsInByb3RvY29sIiwibWF4Q2FjaGVkU2Vzc2lvbnMiLCJfc2Vzc2lvbkNhY2hlIiwibWFwIiwibGlzdCIsIm1ldGhvZCIsImhhc1JlcXVpcmVkQWdlbnRrZWVwYWxpdmUiLCJyZXF1aXJlQWdlbnRrZWVwYWxpdmUiLCJhZ2VudGtlZXBhbGl2ZUV4cG9ydHMiLCJIdHRwS2VlcEFsaXZlQWdlbnQiLCJmYXN0U3RhYmxlU3RyaW5naWZ5JDEiLCJoYXNSZXF1aXJlZEZhc3RTdGFibGVTdHJpbmdpZnkiLCJyZXF1aXJlRmFzdFN0YWJsZVN0cmluZ2lmeSIsIm9ialRvU3RyaW5nIiwib2JqS2V5cyIsInN0cmluZ2lmeSIsImlzQXJyYXlQcm9wIiwicHJvcFZhbCIsInRvU3RyIiwiX2NvbnRleHQ1MiIsInJldHVyblZhbCIsImZhc3RTdGFibGVTdHJpbmdpZnlFeHBvcnRzIiwiZmFzdFN0YWJsZVN0cmluZ2lmeSIsIk1JTklNVU1fU0xPVF9QRVJfRVBPQ0giLCJ0cmFpbGluZ1plcm9zIiwibmV4dFBvd2VyT2ZUd28iLCJFcG9jaFNjaGVkdWxlIiwic2xvdHNQZXJFcG9jaCIsImxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCIsIndhcm11cCIsImZpcnN0Tm9ybWFsRXBvY2giLCJmaXJzdE5vcm1hbFNsb3QiLCJnZXRFcG9jaCIsImdldEVwb2NoQW5kU2xvdEluZGV4IiwiZXBvY2giLCJlcG9jaExlbiIsImdldFNsb3RzSW5FcG9jaCIsInNsb3RJbmRleCIsIm5vcm1hbFNsb3RJbmRleCIsIm5vcm1hbEVwb2NoSW5kZXgiLCJmbG9vciIsImdldEZpcnN0U2xvdEluRXBvY2giLCJwb3ciLCJnZXRMYXN0U2xvdEluRXBvY2giLCJmZXRjaEltcGwiLCJmZXRjaCIsImlucHV0IiwiaW5pdCIsInByb2Nlc3NlZElucHV0IiwiUnBjV2ViU29ja2V0Q2xpZW50IiwiQ29tbW9uQ2xpZW50IiwiZ2VuZXJhdGVfcmVxdWVzdF9pZCIsIndlYlNvY2tldEZhY3RvcnkiLCJ1cmwiLCJycGMiLCJXZWJTb2NrZXQiLCJhdXRvY29ubmVjdCIsIm1heF9yZWNvbm5lY3RzIiwicmVjb25uZWN0IiwicmVjb25uZWN0X2ludGVydmFsIiwidW5kZXJseWluZ1NvY2tldCIsInJlYWR5U3RhdGUiLCJub3RpZnkiLCJkZWNvZGVEYXRhIiwiTE9PS1VQX1RBQkxFX01FVEFfU0laRSIsIkFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQiLCJpc0FjdGl2ZSIsIlU2NF9NQVgiLCJkZWFjdGl2YXRpb25TbG90IiwiYWNjb3VudERhdGEiLCJMb29rdXBUYWJsZU1ldGFMYXlvdXQiLCJzZXJpYWxpemVkQWRkcmVzc2VzTGVuIiwibnVtU2VyaWFsaXplZEFkZHJlc3NlcyIsImxhc3RFeHRlbmRlZFNsb3QiLCJsYXN0RXh0ZW5kZWRTbG90U3RhcnRJbmRleCIsImxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgiLCJhdXRob3JpdHkiLCJVUkxfUkUiLCJtYWtlV2Vic29ja2V0VXJsIiwiZW5kcG9pbnQiLCJtYXRjaGVzIiwiaG9zdGlzaCIsInBvcnRXaXRoQ29sb24iLCJyZXN0Iiwic3RhcnRQb3J0Iiwid2Vic29ja2V0UG9ydCIsIlB1YmxpY0tleUZyb21TdHJpbmciLCJjb2VyY2UiLCJpbnN0YW5jZSIsInN0cmluZyIsIlJhd0FjY291bnREYXRhUmVzdWx0IiwidHVwbGUiLCJsaXRlcmFsIiwiQnVmZmVyRnJvbVJhd0FjY291bnREYXRhIiwiQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMiLCJhc3NlcnRFbmRwb2ludFVybCIsInB1dGF0aXZlVXJsIiwidGVzdCIsImV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyIsImNvbW1pdG1lbnRPckNvbmZpZyIsInNwZWNpZmllZENvbW1pdG1lbnQiLCJzcGVjaWZpZWRDb25maWciLCJhcHBseURlZmF1bHRNZW1jbXBFbmNvZGluZ1RvRmlsdGVycyIsImZpbHRlcnMiLCJmaWx0ZXIiLCJtZW1jbXAiLCJlbmNvZGluZyIsImNyZWF0ZVJwY1Jlc3VsdCIsInVuaW9uIiwianNvbnJwYyIsInVua25vd24iLCJvcHRpb25hbCIsImFueSIsIlVua25vd25ScGNSZXN1bHQiLCJqc29uUnBjUmVzdWx0Iiwic2NoZW1hIiwiY3JlYXRlIiwianNvblJwY1Jlc3VsdEFuZENvbnRleHQiLCJudW1iZXIiLCJub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0IiwidmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZSIsInJlc3BvbnNlIiwiX2NvbnRleHQ1MyIsIl9jb250ZXh0NTQiLCJHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCIsImZvdW5kYXRpb24iLCJmb3VuZGF0aW9uVGVybSIsImluaXRpYWwiLCJ0YXBlciIsInRlcm1pbmFsIiwiR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0IiwibnVsbGFibGUiLCJlZmZlY3RpdmVTbG90IiwiYW1vdW50IiwicG9zdEJhbGFuY2UiLCJjb21taXNzaW9uIiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUmVzdWx0IiwicHJpb3JpdGl6YXRpb25GZWUiLCJHZXRJbmZsYXRpb25SYXRlUmVzdWx0IiwidG90YWwiLCJ2YWxpZGF0b3IiLCJHZXRFcG9jaEluZm9SZXN1bHQiLCJzbG90c0luRXBvY2giLCJhYnNvbHV0ZVNsb3QiLCJibG9ja0hlaWdodCIsInRyYW5zYWN0aW9uQ291bnQiLCJHZXRFcG9jaFNjaGVkdWxlUmVzdWx0IiwiYm9vbGVhbiIsIkdldExlYWRlclNjaGVkdWxlUmVzdWx0IiwicmVjb3JkIiwiVHJhbnNhY3Rpb25FcnJvclJlc3VsdCIsIlNpZ25hdHVyZVN0YXR1c1Jlc3VsdCIsIlNpZ25hdHVyZVJlY2VpdmVkUmVzdWx0IiwiVmVyc2lvblJlc3VsdCIsIlBhcnNlZEluc3RydWN0aW9uU3RydWN0IiwicGFyc2VkIiwiUGFydGlhbGx5RGVjb2RlZEluc3RydWN0aW9uU3RydWN0IiwiU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCIsInJlbnRFcG9jaCIsInVuaXRzQ29uc3VtZWQiLCJyZXR1cm5EYXRhIiwiaW5uZXJJbnN0cnVjdGlvbnMiLCJCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCIsImJ5SWRlbnRpdHkiLCJyYW5nZSIsImZpcnN0U2xvdCIsImxhc3RTbG90IiwiY3JlYXRlUnBjQ2xpZW50IiwiaHR0cEhlYWRlcnMiLCJjdXN0b21GZXRjaCIsImZldGNoTWlkZGxld2FyZSIsImRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0IiwiaHR0cEFnZW50IiwiYWdlbnRPcHRpb25zIiwibWF4U29ja2V0cyIsImlzSHR0cHMiLCJmZXRjaFdpdGhNaWRkbGV3YXJlIiwiaW5mbyIsIm1vZGlmaWVkRmV0Y2hBcmdzIiwibW9kaWZpZWRJbmZvIiwibW9kaWZpZWRJbml0IiwiY2xpZW50QnJvd3NlciIsInJlcXVlc3QiLCJjYWxsYmFjayIsImJvZHkiLCJoZWFkZXJzIiwiQ09NTU9OX0hUVFBfSEVBREVSUyIsInRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMiLCJ3YWl0VGltZSIsInN0YXR1c1RleHQiLCJ0ZXh0Iiwib2siLCJjcmVhdGVScGNSZXF1ZXN0IiwiY2xpZW50IiwiY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0IiwiYmF0Y2giLCJtZXRob2ROYW1lIiwiR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQiLCJHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0IiwiR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0IiwiR2V0RXBvY2hJbmZvUnBjUmVzdWx0IiwiR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCIsIkdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0IiwiU2xvdFJwY1Jlc3VsdCIsIkdldFN1cHBseVJwY1Jlc3VsdCIsImNpcmN1bGF0aW5nIiwibm9uQ2lyY3VsYXRpbmciLCJub25DaXJjdWxhdGluZ0FjY291bnRzIiwiVG9rZW5BbW91bnRSZXN1bHQiLCJ1aUFtb3VudCIsImRlY2ltYWxzIiwidWlBbW91bnRTdHJpbmciLCJHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCIsIkdldFRva2VuQWNjb3VudHNCeU93bmVyIiwiUGFyc2VkQWNjb3VudERhdGFSZXN1bHQiLCJHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciIsIkdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCIsIkFjY291bnRJbmZvUmVzdWx0IiwiS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCIsIlBhcnNlZE9yUmF3QWNjb3VudERhdGEiLCJQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCIsIktleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQiLCJTdGFrZUFjdGl2YXRpb25SZXN1bHQiLCJhY3RpdmUiLCJpbmFjdGl2ZSIsIkdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCIsIm1lbW8iLCJibG9ja1RpbWUiLCJHZXRTaWduYXR1cmVzRm9yQWRkcmVzc1JwY1Jlc3VsdCIsIkFjY291bnROb3RpZmljYXRpb25SZXN1bHQiLCJzdWJzY3JpcHRpb24iLCJQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQiLCJQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCIsIlNsb3RJbmZvUmVzdWx0IiwicGFyZW50Iiwicm9vdCIsIlNsb3ROb3RpZmljYXRpb25SZXN1bHQiLCJTbG90VXBkYXRlUmVzdWx0IiwidGltZXN0YW1wIiwic3RhdHMiLCJudW1UcmFuc2FjdGlvbkVudHJpZXMiLCJudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zIiwibnVtRmFpbGVkVHJhbnNhY3Rpb25zIiwibWF4VHJhbnNhY3Rpb25zUGVyRW50cnkiLCJTbG90VXBkYXRlTm90aWZpY2F0aW9uUmVzdWx0IiwiU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0IiwiUm9vdE5vdGlmaWNhdGlvblJlc3VsdCIsIkNvbnRhY3RJbmZvUmVzdWx0IiwiZ29zc2lwIiwidHB1IiwiVm90ZUFjY291bnRJbmZvUmVzdWx0Iiwidm90ZVB1YmtleSIsIm5vZGVQdWJrZXkiLCJhY3RpdmF0ZWRTdGFrZSIsImVwb2NoVm90ZUFjY291bnQiLCJlcG9jaENyZWRpdHMiLCJsYXN0Vm90ZSIsInJvb3RTbG90IiwiR2V0Vm90ZUFjY291bnRzIiwiY3VycmVudCIsImRlbGlucXVlbnQiLCJDb25maXJtYXRpb25TdGF0dXMiLCJTaWduYXR1cmVTdGF0dXNSZXNwb25zZSIsImNvbmZpcm1hdGlvbnMiLCJjb25maXJtYXRpb25TdGF0dXMiLCJHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCIsIkdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblJwY1Jlc3VsdCIsIkFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiQW5ub3RhdGVkQWNjb3VudEtleSIsInNvdXJjZSIsIkNvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0IiwiUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHQiLCJSYXdJbnN0cnVjdGlvblJlc3VsdCIsIkluc3RydWN0aW9uUmVzdWx0IiwiVW5rbm93bkluc3RydWN0aW9uUmVzdWx0IiwiUGFyc2VkT3JSYXdJbnN0cnVjdGlvbiIsIlBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0IiwiVG9rZW5CYWxhbmNlUmVzdWx0IiwiYWNjb3VudEluZGV4IiwibWludCIsInVpVG9rZW5BbW91bnQiLCJMb2FkZWRBZGRyZXNzZXNSZXN1bHQiLCJDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQiLCJmZWUiLCJwcmVCYWxhbmNlcyIsInBvc3RCYWxhbmNlcyIsInByZVRva2VuQmFsYW5jZXMiLCJwb3N0VG9rZW5CYWxhbmNlcyIsImxvYWRlZEFkZHJlc3NlcyIsImNvbXB1dGVVbml0c0NvbnN1bWVkIiwiUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0IiwiVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0IiwiUmV3YXJkc1Jlc3VsdCIsInJld2FyZFR5cGUiLCJHZXRCbG9ja1JwY1Jlc3VsdCIsInByZXZpb3VzQmxvY2toYXNoIiwicGFyZW50U2xvdCIsInJld2FyZHMiLCJHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQiLCJHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCIsIkdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0IiwiR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCIsIkdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0IiwiR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0IiwiR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCIsIkdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCIsIklzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQiLCJQZXJmU2FtcGxlUmVzdWx0IiwibnVtVHJhbnNhY3Rpb25zIiwibnVtU2xvdHMiLCJzYW1wbGVQZXJpb2RTZWNzIiwiR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0IiwiR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCIsImxhbXBvcnRzUGVyU2lnbmF0dXJlIiwiUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQiLCJTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQiLCJMb2dzUmVzdWx0IiwiTG9nc05vdGlmaWNhdGlvblJlc3VsdCIsIkNvbm5lY3Rpb24iLCJfY29tbWl0bWVudE9yQ29uZmlnIiwiX2NvbnRleHQ1NSIsIl9jb250ZXh0NTYiLCJfY29udGV4dDU3IiwiX2NvbnRleHQ1OCIsIl9jb250ZXh0NTkiLCJfY29udGV4dDYwIiwiX2NvbnRleHQ2MSIsIl9jb250ZXh0NjIiLCJfY29udGV4dDYzIiwiX2NvbnRleHQ2NCIsIl9jb21taXRtZW50IiwiX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiX3JwY1dzRW5kcG9pbnQiLCJfcnBjQ2xpZW50IiwiX3JwY1JlcXVlc3QiLCJfcnBjQmF0Y2hSZXF1ZXN0IiwiX3JwY1dlYlNvY2tldCIsIl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQiLCJfcnBjV2ViU29ja2V0SGVhcnRiZWF0IiwiX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0IiwiX3JwY1dlYlNvY2tldEdlbmVyYXRpb24iLCJfZGlzYWJsZUJsb2NraGFzaENhY2hpbmciLCJfcG9sbGluZ0Jsb2NraGFzaCIsIl9ibG9ja2hhc2hJbmZvIiwibGF0ZXN0QmxvY2toYXNoIiwibGFzdEZldGNoIiwidHJhbnNhY3Rpb25TaWduYXR1cmVzIiwic2ltdWxhdGVkU2lnbmF0dXJlcyIsIl9uZXh0Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQiLCJfc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2giLCJfc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCIsIl9zdWJzY3JpcHRpb25zQnlIYXNoIiwiX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYyIsImdldEJsb2NrSGVpZ2h0IiwicmVxdWVzdFByb21pc2VzIiwiX2J1aWxkQXJncyIsInJlcXVlc3RIYXNoIiwidW5zYWZlUmVzIiwid3NFbmRwb2ludCIsImNvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IiwiSW5maW5pdHkiLCJfd3NPbk9wZW4iLCJfd3NPbkVycm9yIiwiX3dzT25DbG9zZSIsIl93c09uQWNjb3VudE5vdGlmaWNhdGlvbiIsIl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24iLCJfd3NPblNsb3ROb3RpZmljYXRpb24iLCJfd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uIiwiX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24iLCJfd3NPblJvb3ROb3RpZmljYXRpb24iLCJfd3NPbkxvZ3NOb3RpZmljYXRpb24iLCJycGNFbmRwb2ludCIsImdldEJhbGFuY2VBbmRDb250ZXh0IiwiZ2V0QmFsYW5jZSIsImdldEJsb2NrVGltZSIsImdldE1pbmltdW1MZWRnZXJTbG90IiwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9jayIsImdldFN1cHBseSIsImNvbmZpZ0FyZyIsImdldFRva2VuU3VwcGx5IiwidG9rZW5NaW50QWRkcmVzcyIsImdldFRva2VuQWNjb3VudEJhbGFuY2UiLCJ0b2tlbkFkZHJlc3MiLCJnZXRUb2tlbkFjY291bnRzQnlPd25lciIsIm93bmVyQWRkcmVzcyIsIl9hcmdzIiwiZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIiLCJnZXRMYXJnZXN0QWNjb3VudHMiLCJhcmciLCJnZXRUb2tlbkxhcmdlc3RBY2NvdW50cyIsIm1pbnRBZGRyZXNzIiwiZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0IiwiZ2V0UGFyc2VkQWNjb3VudEluZm8iLCJnZXRNdWx0aXBsZVBhcnNlZEFjY291bnRzIiwicHVibGljS2V5cyIsInJhd0NvbmZpZyIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dCIsImdldE11bHRpcGxlQWNjb3VudHNJbmZvIiwiZ2V0U3Rha2VBY3RpdmF0aW9uIiwiZ2V0UHJvZ3JhbUFjY291bnRzIiwiY29uZmlnT3JDb21taXRtZW50IiwiX3JlZiIsImNvbmZpZ1dpdGhvdXRFbmNvZGluZyIsImJhc2VTY2hlbWEiLCJ3aXRoQ29udGV4dCIsImdldFBhcnNlZFByb2dyYW1BY2NvdW50cyIsInN0cmF0ZWd5IiwicmF3U2lnbmF0dXJlIiwiYWJvcnRlZCIsInJlYXNvbiIsImRlY29kZWRTaWduYXR1cmUiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSIsImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3kiLCJjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5IiwiZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZSIsInNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2UiLCJzaWduYXR1cmVTdWJzY3JpcHRpb25JZCIsImRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyIiwiZG9uZSIsImNvbmZpcm1hdGlvblByb21pc2UiLCJvblNpZ25hdHVyZSIsIl9fdHlwZSIsIlBST0NFU1NFRCIsInN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSIsInJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCIsIl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlIiwibmV4dFN0YXRlIiwiZ2V0U2lnbmF0dXJlU3RhdHVzIiwiYWJvcnRDb25maXJtYXRpb24iLCJyZW1vdmVTaWduYXR1cmVMaXN0ZW5lciIsImV4cGlyeVByb21pc2UiLCJjaGVja0Jsb2NrSGVpZ2h0IiwiX2UiLCJjdXJyZW50QmxvY2tIZWlnaHQiLCJCTE9DS0hFSUdIVF9FWENFRURFRCIsImNhbmNlbGxhdGlvblByb21pc2UiLCJvdXRjb21lIiwicmFjZSIsImN1cnJlbnROb25jZVZhbHVlIiwibGFzdENoZWNrZWRTbG90IiwiZ2V0Q3VycmVudE5vbmNlVmFsdWUiLCJnZXROb25jZUFuZENvbnRleHQiLCJOT05DRV9JTlZBTElEIiwic2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2UiLCJzaWduYXR1cmVTdGF0dXMiLCJjb21taXRtZW50Rm9yU3RhdHVzIiwidGltZW91dElkIiwidGltZW91dE1zIiwiVElNRURfT1VUIiwiY2xlYXJUaW1lb3V0IiwiZ2V0Q2x1c3Rlck5vZGVzIiwiZ2V0Vm90ZUFjY291bnRzIiwiZ2V0U2xvdExlYWRlciIsImdldFNsb3RMZWFkZXJzIiwic3RhcnRTbG90IiwibGltaXQiLCJ2YWx1ZXMiLCJnZXRTaWduYXR1cmVTdGF0dXNlcyIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJnZXRUb3RhbFN1cHBseSIsImV4Y2x1ZGVOb25DaXJjdWxhdGluZ0FjY291bnRzTGlzdCIsImdldEluZmxhdGlvbkdvdmVybm9yIiwiZ2V0SW5mbGF0aW9uUmV3YXJkIiwiZ2V0SW5mbGF0aW9uUmF0ZSIsImdldEVwb2NoSW5mbyIsImdldEVwb2NoU2NoZWR1bGUiLCJlcG9jaFNjaGVkdWxlIiwiZ2V0TGVhZGVyU2NoZWR1bGUiLCJnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0IiwiZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dCIsImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlcyIsImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2giLCJ3aXJlTWVzc2FnZSIsImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyIsImxvY2tlZFdyaXRhYmxlQWNjb3VudHMiLCJnZXRSZWNlbnRCbG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJpc0Jsb2NraGFzaFZhbGlkIiwiZ2V0VmVyc2lvbiIsImdldEdlbmVzaXNIYXNoIiwiZ2V0QmxvY2siLCJfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZCIsInRyYW5zYWN0aW9uRGV0YWlscyIsIl9jb250ZXh0NjUiLCJnZXRQYXJzZWRCbG9jayIsImdldEJsb2NrUHJvZHVjdGlvbiIsImV4dHJhIiwiYyIsImdldFBhcnNlZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkVHJhbnNhY3Rpb25zIiwiZ2V0VHJhbnNhY3Rpb25zIiwiZ2V0Q29uZmlybWVkQmxvY2siLCJfY29udGV4dDY2IiwiX2NvbnRleHQ2NyIsImJsb2NrIiwiZ2V0QmxvY2tzIiwiZW5kU2xvdCIsImdldEJsb2NrU2lnbmF0dXJlcyIsImdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyIsImdldENvbmZpcm1lZFRyYW5zYWN0aW9uIiwiZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb24iLCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbnMiLCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyIsImZpcnN0QXZhaWxhYmxlQmxvY2siLCJ1bnRpbCIsIl9jb250ZXh0NjgiLCJoaWdoZXN0Q29uZmlybWVkUm9vdCIsImJlZm9yZSIsIl9jb250ZXh0NjkiLCJjb25maXJtZWRTaWduYXR1cmVJbmZvIiwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyIiwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MiLCJnZXRBZGRyZXNzTG9va3VwVGFibGUiLCJhY2NvdW50SW5mbyIsImdldE5vbmNlIiwicmVxdWVzdEFpcmRyb3AiLCJ0byIsIl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQiLCJkaXNhYmxlQ2FjaGUiLCJ0aW1lU2luY2VGZXRjaCIsImV4cGlyZWQiLCJfcG9sbE5ld0Jsb2NraGFzaCIsInN0YXJ0VGltZSIsImNhY2hlZExhdGVzdEJsb2NraGFzaCIsImNhY2hlZEJsb2NraGFzaCIsImdldFN0YWtlTWluaW11bURlbGVnYXRpb24iLCJzaW11bGF0ZVRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25Pck1lc3NhZ2UiLCJjb25maWdPclNpZ25lcnMiLCJpbmNsdWRlQWNjb3VudHMiLCJ2ZXJzaW9uZWRUeCIsImVuY29kZWRUcmFuc2FjdGlvbiIsIm9yaWdpbmFsVHgiLCJfY29udGV4dDcwIiwiX2NvbnRleHQ3MSIsIl9jb250ZXh0NzIiLCJzaWdWZXJpZnkiLCJ0cmFjZUluZGVudCIsImxvZ1RyYWNlIiwic2lnbmVyc09yT3B0aW9ucyIsInNlbmRSYXdUcmFuc2FjdGlvbiIsIl9jb250ZXh0NzMiLCJyYXdUcmFuc2FjdGlvbiIsInNlbmRFbmNvZGVkVHJhbnNhY3Rpb24iLCJfdXBkYXRlU3Vic2NyaXB0aW9ucyIsIl9jb250ZXh0NzQiLCJjbGVhckludGVydmFsIiwiaGFzaCIsIl9zZXRTdWJzY3JpcHRpb24iLCJuZXh0U3Vic2NyaXB0aW9uIiwicHJldlN0YXRlIiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJjYiIsImNsaWVudFN1YnNjcmlwdGlvbklkIiwiX2NvbnRleHQ3NSIsImNsb3NlIiwiY29ubmVjdCIsImFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24iLCJpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUiLCJjYWxsYmFja3MiLCJzZXJ2ZXJTdWJzY3JpcHRpb25JZCIsInVuc3Vic2NyaWJlTWV0aG9kIiwiX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbiIsImNhbGxiYWNrQXJncyIsIm5vdGlmaWNhdGlvbiIsIl9tYWtlU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uQ29uZmlnIiwiZXhpc3RpbmdTdWJzY3JpcHRpb24iLCJvbkFjY291bnRDaGFuZ2UiLCJyZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIiLCJfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24iLCJhY2NvdW50SWQiLCJvblByb2dyYW1BY2NvdW50Q2hhbmdlIiwibWF5YmVGaWx0ZXJzIiwicmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lciIsIm9uTG9ncyIsIm1lbnRpb25zIiwicmVtb3ZlT25Mb2dzTGlzdGVuZXIiLCJvblNsb3RDaGFuZ2UiLCJyZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIiLCJvblNsb3RVcGRhdGUiLCJyZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIiLCJzdWJzY3JpcHRpb25OYW1lIiwiZGlzcG9zZSIsIm92ZXJyaWRlIiwiX2NvbnRleHQ3NiIsIl9lcnIiLCJvblNpZ25hdHVyZVdpdGhPcHRpb25zIiwiX29wdGlvbnMkY29tbWl0bWVudCIsIm9uUm9vdENoYW5nZSIsInJlbW92ZVJvb3RDaGFuZ2VMaXN0ZW5lciIsIktleXBhaXIiLCJrZXlwYWlyIiwiX2tleXBhaXIiLCJnZW5lcmF0ZSIsImZyb21TZWNyZXRLZXkiLCJza2lwVmFsaWRhdGlvbiIsImNvbXB1dGVkUHVibGljS2V5IiwiaWkiLCJmcm9tU2VlZCIsIkxPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTIiwiQ3JlYXRlTG9va3VwVGFibGUiLCJGcmVlemVMb29rdXBUYWJsZSIsIkV4dGVuZExvb2t1cFRhYmxlIiwiRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQ2xvc2VMb29rdXBUYWJsZSIsIkFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIiwibGF5b3V0VHlwZSIsImRlY29kZUNyZWF0ZUxvb2t1cFRhYmxlIiwiY2hlY2tLZXlzTGVuZ3RoIiwicmVjZW50U2xvdCIsIk51bWJlciIsImRlY29kZUV4dGVuZExvb2t1cFRhYmxlIiwiZGVjb2RlQ2xvc2VMb29rdXBUYWJsZSIsInJlY2lwaWVudCIsImRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlIiwiZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlIiwiQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSIsImNyZWF0ZUxvb2t1cFRhYmxlIiwibG9va3VwVGFibGVBZGRyZXNzIiwiYnVtcFNlZWQiLCJmcmVlemVMb29rdXBUYWJsZSIsImV4dGVuZExvb2t1cFRhYmxlIiwiX2NvbnRleHQ3NyIsImFkZHIiLCJkZWFjdGl2YXRlTG9va3VwVGFibGUiLCJjbG9zZUxvb2t1cFRhYmxlIiwiQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uIiwiQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZVJlcXVlc3RVbml0cyIsInVuaXRzIiwiYWRkaXRpb25hbEZlZSIsIlJlcXVlc3RVbml0cyIsImRlY29kZVJlcXVlc3RIZWFwRnJhbWUiLCJSZXF1ZXN0SGVhcEZyYW1lIiwiZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdCIsIlNldENvbXB1dGVVbml0TGltaXQiLCJkZWNvZGVTZXRDb21wdXRlVW5pdFByaWNlIiwibWljcm9MYW1wb3J0cyIsIlNldENvbXB1dGVVbml0UHJpY2UiLCJDb21wdXRlQnVkZ2V0UHJvZ3JhbSIsInJlcXVlc3RVbml0cyIsInJlcXVlc3RIZWFwRnJhbWUiLCJzZXRDb21wdXRlVW5pdExpbWl0Iiwic2V0Q29tcHV0ZVVuaXRQcmljZSIsIlBSSVZBVEVfS0VZX0JZVEVTJDEiLCJQVUJMSUNfS0VZX0JZVEVTJDEiLCJTSUdOQVRVUkVfQllURVMiLCJFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCIsInUxNiIsIkVkMjU1MTlQcm9ncmFtIiwiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5IiwiaW5zdHJ1Y3Rpb25JbmRleCIsInB1YmxpY0tleU9mZnNldCIsInNpZ25hdHVyZU9mZnNldCIsIm1lc3NhZ2VEYXRhT2Zmc2V0IiwibnVtU2lnbmF0dXJlcyIsInBhZGRpbmciLCJzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4IiwicHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCIsIm1lc3NhZ2VEYXRhU2l6ZSIsIm1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4IiwiY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHJpdmF0ZUtleSIsInByaXZhdGVLZXkiLCJlY2RzYVNpZ24iLCJtc2dIYXNoIiwicHJpdktleSIsInRvQ29tcGFjdFJhd0J5dGVzIiwicmVjb3ZlcnkiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInB1YmxpY0tleUNyZWF0ZSIsIlBSSVZBVEVfS0VZX0JZVEVTIiwiRVRIRVJFVU1fQUREUkVTU19CWVRFUyIsIlBVQkxJQ19LRVlfQllURVMiLCJTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUiLCJTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUIiwiU2VjcDI1NmsxUHJvZ3JhbSIsInB1YmxpY0tleVRvRXRoQWRkcmVzcyIsIl9jb250ZXh0NzgiLCJrZWNjYWtfMjU2IiwicmVjb3ZlcnlJZCIsImNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MiLCJldGhBZGRyZXNzIiwicmF3QWRkcmVzcyIsInN1YnN0ciIsImRhdGFTdGFydCIsImV0aEFkZHJlc3NPZmZzZXQiLCJldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCIsInBrZXkiLCJfY29udGV4dDc5IiwibWVzc2FnZUhhc2giLCJfTG9ja3VwIiwiU1RBS0VfQ09ORklHX0lEIiwiQXV0aG9yaXplZCIsInN0YWtlciIsIndpdGhkcmF3ZXIiLCJMb2NrdXAiLCJ1bml4VGltZXN0YW1wIiwiY3VzdG9kaWFuIiwiU3Rha2VJbnN0cnVjdGlvbiIsIlNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMiLCJkZWNvZGVJbml0aWFsaXplIiwiSW5pdGlhbGl6ZSIsInN0YWtlUHVia2V5IiwiZGVjb2RlRGVsZWdhdGUiLCJEZWxlZ2F0ZSIsImRlY29kZUF1dGhvcml6ZSIsIm5ld0F1dGhvcml6ZWQiLCJzdGFrZUF1dGhvcml6YXRpb25UeXBlIiwiQXV0aG9yaXplIiwiY3VzdG9kaWFuUHVia2V5IiwiZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQiLCJhdXRob3JpdHlTZWVkIiwiYXV0aG9yaXR5T3duZXIiLCJBdXRob3JpemVXaXRoU2VlZCIsImF1dGhvcml0eUJhc2UiLCJkZWNvZGVTcGxpdCIsIlNwbGl0Iiwic3BsaXRTdGFrZVB1YmtleSIsImRlY29kZU1lcmdlIiwiTWVyZ2UiLCJzb3VyY2VTdGFrZVB1YktleSIsImRlY29kZVdpdGhkcmF3IiwiV2l0aGRyYXciLCJkZWNvZGVEZWFjdGl2YXRlIiwiRGVhY3RpdmF0ZSIsIlN0YWtlUHJvZ3JhbSIsIlN0YWtlQXV0aG9yaXphdGlvbkxheW91dCIsIlN0YWtlciIsIldpdGhkcmF3ZXIiLCJpbml0aWFsaXplIiwibWF5YmVMb2NrdXAiLCJkZWxlZ2F0ZSIsImF1dGhvcml6ZSIsImF1dGhvcml6ZVdpdGhTZWVkIiwic3BsaXRJbnN0cnVjdGlvbiIsInJlbnRFeGVtcHRSZXNlcnZlIiwic3BsaXRXaXRoU2VlZCIsIm1lcmdlIiwid2l0aGRyYXciLCJkZWFjdGl2YXRlIiwiVm90ZUluaXQiLCJhdXRob3JpemVkVm90ZXIiLCJhdXRob3JpemVkV2l0aGRyYXdlciIsIlZvdGVJbnN0cnVjdGlvbiIsIlZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUyIsImRlY29kZUluaXRpYWxpemVBY2NvdW50IiwiSW5pdGlhbGl6ZUFjY291bnQiLCJ2b3RlQXV0aG9yaXphdGlvblR5cGUiLCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5IiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkIiwiY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5IiwiYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkiLCJWb3RlUHJvZ3JhbSIsIlVwZGF0ZVZhbGlkYXRvcklkZW50aXR5IiwiVm90ZUF1dGhvcml6YXRpb25MYXlvdXQiLCJWb3RlciIsImluaXRpYWxpemVBY2NvdW50Iiwic2FmZVdpdGhkcmF3IiwiY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSIsInJlbnRFeGVtcHRNaW5pbXVtIiwidXBkYXRlVmFsaWRhdG9ySWRlbnRpdHkiLCJWQUxJREFUT1JfSU5GT19LRVkiLCJJbmZvU3RyaW5nIiwid2Vic2l0ZSIsImRldGFpbHMiLCJpY29uVXJsIiwia2V5YmFzZVVzZXJuYW1lIiwiVmFsaWRhdG9ySW5mbyIsImZyb21Db25maWdEYXRhIiwiY29uZmlnS2V5Q291bnQiLCJjb25maWdLZXlzIiwicmF3SW5mbyIsIkpTT04iLCJWT1RFX1BST0dSQU1fSUQiLCJWb3RlQWNjb3VudExheW91dCIsIlZvdGVBY2NvdW50Iiwidm90ZXMiLCJhdXRob3JpemVkVm90ZXJzIiwicHJpb3JWb3RlcnMiLCJsYXN0VGltZXN0YW1wIiwiX2NvbnRleHQ4MCIsInZlcnNpb25PZmZzZXQiLCJ2YSIsInJvb3RTbG90VmFsaWQiLCJwYXJzZUF1dGhvcml6ZWRWb3RlciIsImdldFByaW9yVm90ZXJzIiwicGFyc2VQcmlvclZvdGVycyIsImVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCIsInRhcmdldEVwb2NoIiwiaWR4IiwiaXNFbXB0eSIsIl9jb250ZXh0ODEiLCJfY29udGV4dDgyIiwiaHR0cCIsImRldm5ldCIsInRlc3RuZXQiLCJodHRwcyIsImNsdXN0ZXJBcGlVcmwiLCJjbHVzdGVyIiwidGxzIiwic2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbiIsImNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyIsIm1heWJlQ29uZmlybU9wdGlvbnMiLCJjb25maXJtYXRpb25TdHJhdGVneSIsIkxBTVBPUlRTX1BFUl9TT0wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/.pnpm/@solana+web3.js@1.98.0_bufferutil@4.0.9_encoding@0.1.13_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.cjs.js\n");

/***/ })

};
;